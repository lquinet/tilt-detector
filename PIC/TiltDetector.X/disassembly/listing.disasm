Disassembly Listing for TiltDetector
Generated From:
F:/PICOS18/TiltDetector/TiltDetector.X/dist/default/debug/TiltDetector.X.debug.cof
27-May-2015 11:10:51

---  F:/PICOS18/TiltDetector/tsk_task_Main.c  -----------------------------------------------------------
1:             /**********************************************************************/
2:             /*                                                                   */
3:             /* File name: TASK_Main.c                                             */
4:             /*                                                                    */
5:             /* Since:     2004-Sept-20                                            */
6:             /*                                                                    */
7:             /* Version:   PICos18 v3.00                                           */
8:             /*            Copyright (C) 2003, 2004, 2005 Pragmatec.               */
9:             /*                                                                    */
10:            /* Author:    Designed by Pragmatec S.A.R.L.        www.pragmatec.net */
11:            /*            MONTAGNE Xavier [XM]      xavier.montagne@pragmatec.net */
12:            /*                                                                    */
13:            /* Purpose:   First task of the tutorial.                             */
14:            /*                                                                    */
15:            /* Distribution: This file is part of PICos18.                        */
16:            /*            PICos18 is free software; you can redistribute it       */
17:            /*            and/or modify it under the terms of the GNU General     */
18:            /*            Public License as published by the Free Software        */
19:            /*            Foundation; either version 2, or (at your option)       */
20:            /*            any later version.                                      */
21:            /*                                                                    */
22:            /*            PICos18 is distributed in the hope that it will be      */
23:            /*            useful, but WITHOUT ANY WARRANTY; without even the      */
24:            /*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
25:            /*            PARTICULAR PURPOSE.  See the GNU General Public         */
26:            /*            License for more details.                               */
27:            /*                                                                    */
28:            /*            You should have received a copy of the GNU General      */
29:            /*            Public License along with gpsim; see the file           */
30:            /*            COPYING.txt. If not, write to the Free Software         */
31:            /*            Foundation, 59 Temple Place - Suite 330,                */
32:            /*            Boston, MA 02111-1307, USA.                             */
33:            /*                                                                    */
34:            /*          > A special exception to the GPL can be applied should    */
35:            /*            you wish to distribute a combined work that includes    */
36:            /*            PICos18, without being obliged to provide the source    */
37:            /*            code for any proprietary components.                    */
38:            /*                                                                    */
39:            /* History:                                                           */
40:            /* 2004/09/20 [XM]  Create this file.                                 */
41:            /*                                                                    */
42:            /**********************************************************************/
43:            #include <stdlib.h>
44:            #include <string.h>
45:            #include "define.h"
46:            #include "user.h"
47:            #include "adc.h"
48:            #include "ftoa.h"
49:            #include "math.h"
50:            #include "menu.h"
51:            #include "tsk_task_main.h"
52:            #include "Config.h" 
53:            #include "rs232.h"
54:            #include "delays.h"
55:            #include "user.h"
56:            #include "Acc_FXLS8471Q.h"
57:            #include "STTS751.h"
58:            
59:            /**********************************************************************
60:             * Definition dedicated to the local functions.
61:             **********************************************************************/
62:            
63:            // Specify sensor full scale
64:            
65:            uint8_t accelFSR = AFS_2g;
66:            uint8_t accelODR = AODR_200HZ;
67:            float aRes; // scale resolutions per LSB for the sensor
68:            // Set the scale below either 2, 4 or 8
69:            
70:            // Pin definitions
71:            int int1Pin = 12;  // These can be changed, 2 and 3 are the Arduinos ext int pins
72:            int ledPin  = 13;  // Pro Mini led
73:            
74:            int16_t accelCount[3];  // Stores the 12-bit signed value
75:            float ax, ay, az;       // Stores the real accel value in g's
76:            uint32_t count = 0;
77:            boolean sleepMode = FALSE;
78:            
79:            //Variables globales initialisées.
80:            
81:            //#pragma idata bank1=0x800
82:            EventMaskType TASK_Main_event;
83:            RS_message_t RS_msg;
84:            I2C_message_t My_I2C_Message;
85:            unsigned char Etat = 1;
86:            float temperature=0.0;
87:            unsigned char buffer[40];
88:            
89:            char input;
90:            unsigned char Mode;
91:            
92:            extern unsigned char state; // holds the current state, according to "menu.h"
93:            extern unsigned char nextstate;
94:            extern unsigned char laststate;
95:            extern PGM_P statetext;
96:            extern char (*pStateFunc)(char);
97:            
98:            extern volatile char KEY;
99:            
100:           void Delay_ms(unsigned int delay);
101:           
102:           
103:           //#pragma idata bank2=0x800
104:           
105:           /**********************************************************************
106:            ------------------------------- TASK_Main ----------------------------
107:            **********************************************************************/
108:           
109:           TASK(TASK_Main)
110:           {
111:               
112:               state = ST_S1_;
32D6  0107     MOVLB 0x7
32D8  0E01     MOVLW 0x1
32DA  6FD8     MOVWF 0xD8, BANKED
113:               nextstate = ST_S1_;
32DC  0107     MOVLB 0x7
32DE  6FD9     MOVWF 0xD9, BANKED
114:               statetext = NULL;
32E0  0107     MOVLB 0x7
32E2  6BDB     CLRF 0xDB, BANKED
32E4  6BDC     CLRF 0xDC, BANKED
115:               pStateFunc = NULL;
32E6  0107     MOVLB 0x7
32E8  6BDD     CLRF 0xDD, BANKED
32EA  6BDE     CLRF 0xDE, BANKED
116:               
117:               SetRelAlarm(ALARM_TASK_Main, ALARME_TASK_MAIN, ALARME_TASK_MAIN);
32EC  0E0A     MOVLW 0xA
32EE  6EE6     MOVWF POSTINC1, ACCESS
32F0  6AE6     CLRF POSTINC1, ACCESS
32F2  6EE6     MOVWF POSTINC1, ACCESS
32F4  6AE6     CLRF POSTINC1, ACCESS
32F6  6AE6     CLRF POSTINC1, ACCESS
32F8  ECA3     CALL 0x146, 0
32FA  F000     NOP
32FC  6E14     MOVWF __tmp_0, ACCESS
32FE  0E05     MOVLW 0x5
3300  5EE1     SUBWF FSR1, F, ACCESS
3302  5014     MOVF __tmp_0, W, ACCESS
118:               
119:               while (1)
335A  D7D4     BRA 0x3304
120:               {
121:                   WaitEvent(ALARM_EVENT );
3304  0E02     MOVLW 0x2
3306  6EE6     MOVWF POSTINC1, ACCESS
3308  EC74     CALL 0x18E8, 0
330A  F00C     NOP
330C  52E5     MOVF POSTDEC1, F, ACCESS
122:                   GetEvent(TASK_Main_ID, &TASK_Main_event);
330E  0E8A     MOVLW 0x8A
3310  6EE6     MOVWF POSTINC1, ACCESS
3312  0E07     MOVLW 0x7
3314  6EE6     MOVWF POSTINC1, ACCESS
3316  0E01     MOVLW 0x1
3318  6EE6     MOVWF POSTINC1, ACCESS
331A  EC11     CALL 0x1822, 0
331C  F00C     NOP
331E  52E5     MOVF POSTDEC1, F, ACCESS
3320  52E5     MOVF POSTDEC1, F, ACCESS
3322  52E5     MOVF POSTDEC1, F, ACCESS
123:                   if (TASK_Main_event & ALARM_EVENT)
3324  0107     MOVLB 0x7
3326  A38A     BTFSS event_11, 1, BANKED
3328  D018     BRA 0x335A
124:                   {
125:                       ClearEvent(ALARM_EVENT);
332A  0E02     MOVLW 0x2
332C  6EE6     MOVWF POSTINC1, ACCESS
332E  ECAA     CALL 0x1754, 0
3330  F00B     NOP
3332  52E5     MOVF POSTDEC1, F, ACCESS
126:                       input = getkey();
3334  EC2D     CALL 0x345A, 0
3336  F01A     NOP
3338  0107     MOVLB 0x7
333A  6FC6     MOVWF 0xC6, BANKED
127:                       StateMachine(input); //Exécution de la machine d'état pour faire évaluer le process.
333C  C7C6     MOVFF input, POSTINC1
333E  FFE6     NOP
3340  EC94     CALL 0x3128, 0
3342  F018     NOP
3344  52E5     MOVF POSTDEC1, F, ACCESS
128:                       temperature= ReatTemperatureSTTS751();
3346  EC12     CALL 0x3624, 0
3348  F01B     NOP
334A  C004     MOVFF 0x4, temperature
334C  F7D4     NOP
334E  C005     MOVFF 0x5, 0x7D5
3350  F7D5     NOP
3352  C006     MOVFF 0x6, 0x7D6
3354  F7D6     NOP
3356  C007     MOVFF 0x7, 0x7D7
3358  F7D7     NOP
129:                   }
130:                       
131:                   }//Fin while WaitEvent(ALARM_EVENT);
132:           }
335C  0012     RETURN 0
133:           
134:           
135:           /**********************************************************************
136:            * Generic routine to create a delay of many milliseconds.
137:            *
138:            * @param  delay     IN  time to wait in ms
139:            * @return void 
140:            **********************************************************************/
141:           void Delay_ms(unsigned int delay)
335E  CFD9     MOVFF FSR2, POSTINC1
3360  FFE6     NOP
3362  CFE1     MOVFF FSR1, FSR2
3364  FFD9     NOP
142:           {
143:               CancelAlarm(ALARM_TASK_Main_Delay);
3366  0E01     MOVLW 0x1
3368  6EE6     MOVWF POSTINC1, ACCESS
336A  ECBD     CALL 0x57A, 0
336C  F002     NOP
336E  52E5     MOVF POSTDEC1, F, ACCESS
144:               SetRelAlarm(ALARM_TASK_Main_Delay, delay, 0);
3370  0E00     MOVLW 0x0
3372  6EE6     MOVWF POSTINC1, ACCESS
3374  6AE6     CLRF POSTINC1, ACCESS
3376  0EFD     MOVLW 0xFD
3378  CFDB     MOVFF PLUSW2, POSTINC1
337A  FFE6     NOP
337C  0EFE     MOVLW 0xFE
337E  CFDB     MOVFF PLUSW2, POSTINC1
3380  FFE6     NOP
3382  0E01     MOVLW 0x1
3384  6EE6     MOVWF POSTINC1, ACCESS
3386  ECA3     CALL 0x146, 0
3388  F000     NOP
338A  6E14     MOVWF __tmp_0, ACCESS
338C  0E05     MOVLW 0x5
338E  5EE1     SUBWF FSR1, F, ACCESS
3390  5014     MOVF __tmp_0, W, ACCESS
145:               WaitEvent(DELAY_EVENT);
3392  0E10     MOVLW 0x10
3394  6EE6     MOVWF POSTINC1, ACCESS
3396  EC74     CALL 0x18E8, 0
3398  F00C     NOP
339A  52E5     MOVF POSTDEC1, F, ACCESS
146:               GetEvent(TASK_Main_ID, &TASK_Main_event);
339C  0E8A     MOVLW 0x8A
339E  6EE6     MOVWF POSTINC1, ACCESS
33A0  0E07     MOVLW 0x7
33A2  6EE6     MOVWF POSTINC1, ACCESS
33A4  0E01     MOVLW 0x1
33A6  6EE6     MOVWF POSTINC1, ACCESS
33A8  EC11     CALL 0x1822, 0
33AA  F00C     NOP
33AC  52E5     MOVF POSTDEC1, F, ACCESS
33AE  52E5     MOVF POSTDEC1, F, ACCESS
33B0  52E5     MOVF POSTDEC1, F, ACCESS
147:               if (TASK_Main_event & DELAY_EVENT)
33B2  0107     MOVLB 0x7
33B4  A98A     BTFSS event_11, 4, BANKED
33B6  D005     BRA 0x33C2
148:                   ClearEvent(DELAY_EVENT);
33B8  0E10     MOVLW 0x10
33BA  6EE6     MOVWF POSTINC1, ACCESS
33BC  ECAA     CALL 0x1754, 0
33BE  F00B     NOP
33C0  52E5     MOVF POSTDEC1, F, ACCESS
149:               return;
33C2  D000     BRA 0x33C4
150:           }
33C4  52E5     MOVF POSTDEC1, F, ACCESS
33C6  CFE7     MOVFF INDF1, FSR2
33C8  FFD9     NOP
33CA  0012     RETURN 0
151:           
152:           //***********************************************************************
153:           
154:           
155:           //int ConvertVoltToDutyCycle(float Voltage)
156:           //{
157:           //    float ValTemp = 0;
158:           //    ValTemp = Voltage / (U_PIC * COEF_AMP); //le pic travail avec un rapport cyclique de 0-1000.
159:           //
160:           //    if (ValTemp < PWM_MIN)
161:           //        return PWM_MIN;
162:           //    if (ValTemp > PWM_MAX)
163:           //        return PWM_MAX;
164:           //    return ValTemp;
165:           //}
166:           
167:           
168:           
169:           
170:           
171:           /* End of File : TASK_Main.c */
---  F:/PICOS18/TiltDetector/menu.c  --------------------------------------------------------------------
1:             #include "define.h"
2:             #include "menu.h"
3:             #include "user.h"
4:             
5:             unsigned char state; // holds the current state, according to "menu.h"
6:             unsigned char nextstate;
7:             unsigned char laststate;
8:             PGM_P statetext;
9:             char (*pStateFunc)(char);
10:            //char input;
11:            unsigned char i, j;
12:            
13:            //const rom char MT_S1_MENU_TEST_PROD[] = "TEST-\rPROD";
14:            //const rom char MT_S2_MENU_MODE_TEST[] = "MODE\rTEST";
15:            //const rom char MT_S49_[] = "";
16:            //const rom char MT_S50_[] = "";
17:            
18:            
19:            unsigned char ShiftStates(char state, unsigned char stimuli);
20:            unsigned char StateMachine(unsigned char input);
21:            
22:            
23:            const rom MENU_NEXTSTATE menu_nextstate[] = {
24:                //  STATE                       	INPUT       		NEXT STATE
25:            
26:            //    {ST_S1_MENU_TEST_PROD, TEST_PROD_LONG, ST_S2_MENU_MODE_TEST},
27:            //    {ST_S1_MENU_TEST_PROD, TEST_PROD, ST_S21_MENU_NEW_BIDON},
28:            
29:                {0, 0, 0}
30:            
31:            };
32:            
33:            const rom MENU_STATE menu_state[] = {
34:                //  STATE                              	STATE TEXT                  	STATE_FUNC
35:            
36:                {ST_S1_, NULL, NULL},
37:            
38:                
39:            
40:            };
41:            
42:            /****************************************************************************
43:             *
44:             *   Function name : StateMachine
45:             *
46:             *   Returns :
47:             *
48:             *   Parameters :    input
49:             *
50:             *   Purpose :       Shifts between the different states
51:             *
52:             *****************************************************************************/
53:            
54:            unsigned char StateMachine(unsigned char input)
3128  CFD9     MOVFF FSR2, POSTINC1
312A  FFE6     NOP
312C  CFE1     MOVFF FSR1, FSR2
312E  FFD9     NOP
55:            {
56:            
57:                if (statetext)
3130  0107     MOVLB 0x7
3132  51DB     MOVF 0xDB, W, BANKED
3134  11DC     IORWF 0xDC, W, BANKED
3136  E003     BZ 0x313E
58:                {
59:                    statetext = NULL;
3138  0107     MOVLB 0x7
313A  6BDB     CLRF 0xDB, BANKED
313C  6BDC     CLRF 0xDC, BANKED
60:                }
61:            
62:                if (pStateFunc)
313E  0107     MOVLB 0x7
3140  51DD     MOVF 0xDD, W, BANKED
3142  11DE     IORWF 0xDE, W, BANKED
3144  E00E     BZ 0x3162
63:                {// When in this state, we must call the state function
64:                    nextstate = pStateFunc(input);
3146  0EFE     MOVLW 0xFE
3148  CFDB     MOVFF PLUSW2, POSTINC1
314A  FFE6     NOP
314C  D005     BRA 0x3158
314E  C7DE     MOVFF 0x7DE, PCLATH
3150  FFFA     NOP
3152  0107     MOVLB 0x7
3154  51DD     MOVF 0xDD, W, BANKED
3156  6EF9     MOVWF PCL, ACCESS
3158  DFFA     RCALL 0x314E
315A  52E5     MOVF POSTDEC1, F, ACCESS
315C  0107     MOVLB 0x7
315E  6FD9     MOVWF 0xD9, BANKED
65:                } else
3160  D00D     BRA 0x317C
66:                    if (input != KEY_NULL)
3162  0EFE     MOVLW 0xFE
3164  50DB     MOVF PLUSW2, W, ACCESS
3166  E00A     BZ 0x317C
67:                { // Plain menu, clock the state machine
68:                    nextstate = ShiftStates(state, input);
3168  0EFE     MOVLW 0xFE
316A  CFDB     MOVFF PLUSW2, POSTINC1
316C  FFE6     NOP
316E  C7D8     MOVFF state, POSTINC1
3170  FFE6     NOP
3172  D855     RCALL ShiftStates
3174  52E5     MOVF POSTDEC1, F, ACCESS
3176  52E5     MOVF POSTDEC1, F, ACCESS
3178  0107     MOVLB 0x7
317A  6FD9     MOVWF 0xD9, BANKED
69:                }
70:                if (nextstate != state)
317C  0107     MOVLB 0x7
317E  51D8     MOVF 0xD8, W, BANKED
3180  0107     MOVLB 0x7
3182  5DD9     SUBWF 0xD9, W, BANKED
3184  E048     BZ 0x3216
71:                {
72:                    laststate = state;
3186  C7D8     MOVFF state, laststate
3188  F7DA     NOP
73:                    state = nextstate;
318A  C7D9     MOVFF nextstate, state
318C  F7D8     NOP
74:                    for (i = 0; (j = menu_state[i].state); i++)
318E  0107     MOVLB 0x7
3190  6BDF     CLRF 0xDF, BANKED
3192  0107     MOVLB 0x7
3194  51DF     MOVF 0xDF, W, BANKED
3196  0D05     MULLW 0x5
3198  CFF3     MOVFF PROD, TBLPTR
319A  FFF6     NOP
319C  CFF4     MOVFF PRODH, TBLPTRH
319E  FFF7     NOP
31A0  0EF1     MOVLW 0xF1
31A2  26F6     ADDWF TBLPTR, F, ACCESS
31A4  0E35     MOVLW 0x35
31A6  22F7     ADDWFC TBLPTRH, F, ACCESS
31A8  0008     TBLRD*
31AA  CFF5     MOVFF TABLAT, j
31AC  F7E0     NOP
31AE  50F5     MOVF TABLAT, W, ACCESS
31B0  E032     BZ 0x3216
3210  0107     MOVLB 0x7
3212  2BDF     INCF 0xDF, F, BANKED
3214  D7BE     BRA 0x3192
75:                    {
76:                        if (j == state)
31B2  0107     MOVLB 0x7
31B4  51D8     MOVF 0xD8, W, BANKED
31B6  0107     MOVLB 0x7
31B8  5DE0     SUBWF 0xE0, W, BANKED
31BA  E12A     BNZ 0x3210
77:                        {
78:                            statetext = (menu_state[i].pText);
31BC  0107     MOVLB 0x7
31BE  51DF     MOVF 0xDF, W, BANKED
31C0  0D05     MULLW 0x5
31C2  CFF3     MOVFF PROD, TBLPTR
31C4  FFF6     NOP
31C6  CFF4     MOVFF PRODH, TBLPTRH
31C8  FFF7     NOP
31CA  0EF1     MOVLW 0xF1
31CC  26F6     ADDWF TBLPTR, F, ACCESS
31CE  0E35     MOVLW 0x35
31D0  22F7     ADDWFC TBLPTRH, F, ACCESS
31D2  2AF6     INCF TBLPTR, F, ACCESS
31D4  0E00     MOVLW 0x0
31D6  22F7     ADDWFC TBLPTRH, F, ACCESS
31D8  0009     TBLRD*+
31DA  CFF5     MOVFF TABLAT, statetext
31DC  F7DB     NOP
31DE  000A     TBLRD*-
31E0  CFF5     MOVFF TABLAT, 0x7DC
31E2  F7DC     NOP
79:                            pStateFunc = (menu_state[i].pFunc);
31E4  0107     MOVLB 0x7
31E6  51DF     MOVF 0xDF, W, BANKED
31E8  0D05     MULLW 0x5
31EA  CFF3     MOVFF PROD, TBLPTR
31EC  FFF6     NOP
31EE  CFF4     MOVFF PRODH, TBLPTRH
31F0  FFF7     NOP
31F2  0EF1     MOVLW 0xF1
31F4  26F6     ADDWF TBLPTR, F, ACCESS
31F6  0E35     MOVLW 0x35
31F8  22F7     ADDWFC TBLPTRH, F, ACCESS
31FA  0E03     MOVLW 0x3
31FC  26F6     ADDWF TBLPTR, F, ACCESS
31FE  0E00     MOVLW 0x0
3200  22F7     ADDWFC TBLPTRH, F, ACCESS
3202  0009     TBLRD*+
3204  CFF5     MOVFF TABLAT, pStateFunc
3206  F7DD     NOP
3208  000A     TBLRD*-
320A  CFF5     MOVFF TABLAT, 0x7DE
320C  F7DE     NOP
80:                            break;
320E  D003     BRA 0x3216
81:                        }
82:                    }
83:                }
84:            }
3216  52E5     MOVF POSTDEC1, F, ACCESS
3218  CFE7     MOVFF INDF1, FSR2
321A  FFD9     NOP
321C  0012     RETURN 0
85:            
86:            /****************************************************************************
87:             *
88:             *   Function name : ShiftStates
89:             *
90:             *   Returns :       nextstate
91:             *
92:             *   Parameters :    state, stimuli
93:             *
94:             *   Purpose :       Shifts between the different states
95:             *
96:             *****************************************************************************/
97:            unsigned char ShiftStates(char state, unsigned char stimuli)
321E  CFD9     MOVFF FSR2, POSTINC1
3220  FFE6     NOP
3222  CFE1     MOVFF FSR1, FSR2
3224  FFD9     NOP
3226  0E03     MOVLW 0x3
3228  26E1     ADDWF FSR1, F, ACCESS
98:            {
99:                unsigned char nextstate = state; // Default stay in same state
322A  0EFE     MOVLW 0xFE
322C  50DB     MOVF PLUSW2, W, ACCESS
322E  6EDF     MOVWF INDF2, ACCESS
100:               unsigned char i, j;
101:               for (i = 0; (j = menu_nextstate[i].state); i++)
3230  0E01     MOVLW 0x1
3232  6ADB     CLRF PLUSW2, ACCESS
3234  0E01     MOVLW 0x1
3236  50DB     MOVF PLUSW2, W, ACCESS
3238  0D03     MULLW 0x3
323A  CFF3     MOVFF PROD, TBLPTR
323C  FFF6     NOP
323E  CFF4     MOVFF PRODH, TBLPTRH
3240  FFF7     NOP
3242  0EEE     MOVLW 0xEE
3244  26F6     ADDWF TBLPTR, F, ACCESS
3246  0E35     MOVLW 0x35
3248  22F7     ADDWFC TBLPTRH, F, ACCESS
324A  0008     TBLRD*
324C  0E02     MOVLW 0x2
324E  CFF5     MOVFF TABLAT, PLUSW2
3250  FFDB     NOP
3252  50F5     MOVF TABLAT, W, ACCESS
3254  E032     BZ 0x32BA
32B4  0E01     MOVLW 0x1
32B6  2ADB     INCF PLUSW2, F, ACCESS
32B8  D7BD     BRA 0x3234
102:               {
103:                   if ((j == state) && (menu_nextstate[i].input == stimuli))
3256  0EFE     MOVLW 0xFE
3258  50DB     MOVF PLUSW2, W, ACCESS
325A  6EF3     MOVWF PROD, ACCESS
325C  0E02     MOVLW 0x2
325E  50DB     MOVF PLUSW2, W, ACCESS
3260  5CF3     SUBWF PROD, W, ACCESS
3262  E128     BNZ 0x32B4
3264  0E01     MOVLW 0x1
3266  50DB     MOVF PLUSW2, W, ACCESS
3268  0D03     MULLW 0x3
326A  CFF3     MOVFF PROD, TBLPTR
326C  FFF6     NOP
326E  CFF4     MOVFF PRODH, TBLPTRH
3270  FFF7     NOP
3272  0EEE     MOVLW 0xEE
3274  26F6     ADDWF TBLPTR, F, ACCESS
3276  0E35     MOVLW 0x35
3278  22F7     ADDWFC TBLPTRH, F, ACCESS
327A  2AF6     INCF TBLPTR, F, ACCESS
327C  0E00     MOVLW 0x0
327E  22F7     ADDWFC TBLPTRH, F, ACCESS
3280  0008     TBLRD*
3282  CFF5     MOVFF TABLAT, __tmp_0
3284  F014     NOP
3286  0EFD     MOVLW 0xFD
3288  50DB     MOVF PLUSW2, W, ACCESS
328A  5C14     SUBWF __tmp_0, W, ACCESS
328C  E113     BNZ 0x32B4
104:                   {
105:                       nextstate = menu_nextstate[i].nextstate;
328E  0E01     MOVLW 0x1
3290  50DB     MOVF PLUSW2, W, ACCESS
3292  0D03     MULLW 0x3
3294  CFF3     MOVFF PROD, TBLPTR
3296  FFF6     NOP
3298  CFF4     MOVFF PRODH, TBLPTRH
329A  FFF7     NOP
329C  0EEE     MOVLW 0xEE
329E  26F6     ADDWF TBLPTR, F, ACCESS
32A0  0E35     MOVLW 0x35
32A2  22F7     ADDWFC TBLPTRH, F, ACCESS
32A4  0E02     MOVLW 0x2
32A6  26F6     ADDWF TBLPTR, F, ACCESS
32A8  0E00     MOVLW 0x0
32AA  22F7     ADDWFC TBLPTRH, F, ACCESS
32AC  0008     TBLRD*
32AE  50F5     MOVF TABLAT, W, ACCESS
32B0  6EDF     MOVWF INDF2, ACCESS
106:                       break;
32B2  D003     BRA 0x32BA
107:                   }
108:               }
109:               return nextstate;
32BA  50DF     MOVF INDF2, W, ACCESS
110:           }
32BC  6E14     MOVWF __tmp_0, ACCESS
32BE  0E03     MOVLW 0x3
32C0  5CE1     SUBWF FSR1, W, ACCESS
32C2  E203     BC 0x32CA
32C4  D000     BRA 0x32C6
32C6  6AE1     CLRF FSR1, ACCESS
32C8  52E5     MOVF POSTDEC1, F, ACCESS
32CA  6EE1     MOVWF FSR1, ACCESS
32CC  5014     MOVF __tmp_0, W, ACCESS
32CE  52E5     MOVF POSTDEC1, F, ACCESS
32D0  CFE7     MOVFF INDF1, FSR2
32D2  FFD9     NOP
32D4  0012     RETURN 0
111:           
112:           
---  F:/PICOS18/TiltDetector/main.c  --------------------------------------------------------------------
1:             /**********************************************************************/
2:             /*                                                                    */
3:             /* File name: main.c                                                  */
4:             /*                                                                    */
5:             /* Since:     2004-Sept-20                                            */
6:             /*                                                                    */
7:             /* Version:   PICos18 v3.00                                           */
8:             /*            Copyright (C) 2003, 2004, 2005 Pragmatec.               */
9:             /*                                                                    */
10:            /* Author:    Designed by Pragmatec S.A.R.L.        www.pragmatec.net */
11:            /*            MONTAGNE Xavier [XM]      xavier.montagne@pragmatec.net */
12:            /*                                                                    */
13:            /* Purpose:   Custom initialization and kernel start.                 */
14:            /*                                                                    */
15:            /* Distribution: This file is part of PICos18.                        */
16:            /*            PICos18 is free software; you can redistribute it       */
17:            /*            and/or modify it under the terms of the GNU General     */
18:            /*            Public License as published by the Free Software        */
19:            /*            Foundation; either version 2, or (at your option)       */
20:            /*            any later version.                                      */
21:            /*                                                                    */
22:            /*            PICos18 is distributed in the hope that it will be      */
23:            /*            useful, but WITHOUT ANY WARRANTY; without even the      */
24:            /*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
25:            /*            PARTICULAR PURPOSE.  See the GNU General Public         */
26:            /*            License for more details.                               */
27:            /*                                                                    */
28:            /*            You should have received a copy of the GNU General      */
29:            /*            Public License along with gpsim; see the file           */
30:            /*            COPYING.txt. If not, write to the Free Software         */
31:            /*            Foundation, 59 Temple Place - Suite 330,                */
32:            /*            Boston, MA 02111-1307, USA.                             */
33:            /*                                                                    */
34:            /*          > A special exception to the GPL can be applied should    */
35:            /*            you wish to distribute a combined work that includes    */
36:            /*            PICos18, without being obliged to provide the source    */
37:            /*            code for any proprietary components.                    */
38:            /*                                                                    */
39:            /* History:                                                           */
40:            /* 2004/09/20 [XM]  Create this file.                                 */
41:            /*                                                                    */
42:            /**********************************************************************/
43:            
44:            
45:            
46:            //#include <p18cxxx.h>
47:            #include <p18f45j50.h>
48:            #include "define.h"
49:            #include "user.h"
50:            #include  "pconfig.h"
51:            #include "main.h"
52:            #include "timers.h"
53:            #include "delays.h"
54:            #include "Config.h"
55:            //#include "menu.h"
56:            
57:            
58:            /**********************************************************************
59:             * Definition dedicated to the local functions.
60:             **********************************************************************/
61:            #define DEFAULT_MODE       0
62:            
63:            
64:            /**********************************************************************
65:             * Function prototypes.
66:             **********************************************************************/
67:            void main(void);
68:            void Init(void);
69:            void StartupHook(void);
70:            void ShutdownHook(StatusType error);
71:            void ErrorHook(StatusType error);
72:            void PreTaskHook(void);
73:            void PostTaskHook(void);
74:            volatile BOOL gKeyClickStatus = FALSE; // Variable to enable/disable keyclick
75:            
76:            extern union Timers Tmr0;
77:            extern unsigned char Mode;
78:            
79:            //#pragma idata bank5=0x850
80:            
81:            AppModeType SelectedMode;
82:            
83:            /**********************************************************************
84:             * -------------------------- main function ---------------------------
85:             *
86:             * Setup the different alarms and start the kernel.
87:             *
88:             **********************************************************************/
89:            void main(void)
90:            {
91:                STKPTR = 0;
356C  6AFC     CLRF STKPTR, ACCESS
92:                SelectedMode = DEFAULT_MODE;
356E  010E     MOVLB 0xE
3570  6B43     CLRF 0x43, BANKED
93:                Delay10KTCYx(255);
3572  68E6     SETF POSTINC1, ACCESS
3574  ECCA     CALL 0x2F94, 0
3576  F017     NOP
3578  52E5     MOVF POSTDEC1, F, ACCESS
94:                Delay10KTCYx(255);
357A  68E6     SETF POSTINC1, ACCESS
357C  ECCA     CALL 0x2F94, 0
357E  F017     NOP
3580  52E5     MOVF POSTDEC1, F, ACCESS
95:                Delay10KTCYx(255);
3582  68E6     SETF POSTINC1, ACCESS
3584  ECCA     CALL 0x2F94, 0
3586  F017     NOP
3588  52E5     MOVF POSTDEC1, F, ACCESS
96:                Init();
358A  D807     RCALL Init
97:            
98:                while (1)
3596  D7FA     BRA 0x358C
99:                {
100:                   StartOS(SelectedMode);
358C  CE43     MOVFF SelectedMode, POSTINC1
358E  FFE6     NOP
3590  EC62     CALL 0x12C4, 0
3592  F009     NOP
3594  52E5     MOVF POSTDEC1, F, ACCESS
101:               }
102:           }
3598  0012     RETURN 0
103:           
104:           /**********************************************************************
105:            * Clear all RAM memory and set PORTB to output mode.
106:            *
107:            * @return void
108:            **********************************************************************/
109:           void Init(void)
110:           {
111:               FSR0H = 0;
359A  6AEA     CLRF FSR0H, ACCESS
112:               FSR0L = 0;
359C  6AE9     CLRF FSR0, ACCESS
113:               /* User setting : actual PIC frequency */
114:               Tmr0.lt = TMR0_PRESET;
359E  0107     MOVLB 0x7
35A0  0EF0     MOVLW 0xF0
35A2  6FFE     MOVWF 0xFE, BANKED
35A4  0ED8     MOVLW 0xD8
35A6  6FFF     MOVWF 0xFF, BANKED
115:               /* Timer OFF - Enabled by Kernel */
116:               T0CON = 0x08;
35A8  0E08     MOVLW 0x8
35AA  6ED5     MOVWF T0CON, ACCESS
117:               TMR0H = Tmr0.bt[1];
35AC  C7FF     MOVFF 0x7FF, TMR0H
35AE  FFD7     NOP
118:               TMR0L = Tmr0.bt[0];
35B0  C7FE     MOVFF Tmr0, TMR0
35B2  FFD6     NOP
119:           
120:               //*****************************************
121:               //************Init IO's *********************
122:               //*****************************************
123:           //    TRISLED_ETAT_BIDON_R = 0;
124:           //    TRISLED_ETAT_BIDON_G = 0;
125:             
126:           
127:               //Set all analog input as digital input.
128:           //    ENABLE_ALL_DIG_0_7();
129:           //    ENABLE_ALL_DIG_8_15();
130:           //    ENABLE_ALL_DIG_16_23();
131:           
132:              
133:               //*****************************************
134:               //************* Intrerruption *************
135:               //*****************************************
136:           
137:               //	RCON		//RESET CONTROL REGISTER
138:               RCONbits.IPEN = 1; //RESET CONTROL REGISTER
35B4  8ED0     BSF RCON, 7, ACCESS
139:           
140:               //	INTCON
141:               INTCONbits.GIE = 0; //Global Interrupt Enable bit
35B6  9EF2     BCF INTCON, 7, ACCESS
142:               INTCONbits.PEIE = 1; //Peripheral Interrupt Enable bit
35B8  8CF2     BSF INTCON, 6, ACCESS
143:           
144:           
145:               //	INTCON2
146:               INTCON2bits.RBPU = 0; //RBPU 1 = All PORTB pull-ups are disabled 0 = PORTB pull-ups are enabled
35BA  9EF1     BCF INTCON2, 7, ACCESS
147:               INTCON2bits.INTEDG0 = 0; //INTEDG0: External Interrupt 0 Edge Select 1 =rising; 0 =falling
35BC  9CF1     BCF INTCON2, 6, ACCESS
148:               INTCON2bits.INTEDG1 = 0; //INTEDG1: External Interrupt 1
35BE  9AF1     BCF INTCON2, 5, ACCESS
149:               INTCON2bits.INTEDG2 = 0; //INTEDG2: External Interrupt 2
35C0  98F1     BCF INTCON2, 4, ACCESS
150:               INTCON2bits.TMR0IP = 0; //TMR0IP: TMR0 Overflow Interrupt Priority bit 1 = High, 0 = Low priority.
35C2  94F1     BCF INTCON2, 2, ACCESS
151:               INTCON2bits.RBIP = 0; //RBIP: RB Port Change Interrupt Priority bit
35C4  90F1     BCF INTCON2, 0, ACCESS
152:           
153:               //I2C_V6_1
154:           
155:           }
35C6  0012     RETURN 0
156:           
157:           /**********************************************************************
158:            * Hook routine called just before entering in kernel.
159:            *
160:            * @param error      IN The new error stored in buffer
161:            * @return error     Error level
162:            **********************************************************************/
163:           void StartupHook(void)
164:           {
165:           }
35C8  0012     RETURN 0
166:           
167:           /**********************************************************************
168:            * Hook routine called just after leaving the kernel.
169:            *
170:            * @param error      IN The last error detected by OS
171:            * @return void
172:            **********************************************************************/
173:           void ShutdownHook(StatusType error)
35CA  CFD9     MOVFF FSR2, POSTINC1
35CC  FFE6     NOP
35CE  CFE1     MOVFF FSR1, FSR2
35D0  FFD9     NOP
174:           {
175:           }
35D2  52E5     MOVF POSTDEC1, F, ACCESS
35D4  CFE7     MOVFF INDF1, FSR2
35D6  FFD9     NOP
35D8  0012     RETURN 0
176:           
177:           /**********************************************************************
178:            * Store a new error in a global buffer keeping a track of the 
179:            * application history.
180:            *
181:            * @param error      IN The new error stored in buffer
182:            * @return void
183:            **********************************************************************/
184:           void ErrorHook(StatusType error)
35DA  CFD9     MOVFF FSR2, POSTINC1
35DC  FFE6     NOP
35DE  CFE1     MOVFF FSR1, FSR2
35E0  FFD9     NOP
185:           {
186:           }
35E2  52E5     MOVF POSTDEC1, F, ACCESS
35E4  CFE7     MOVFF INDF1, FSR2
35E6  FFD9     NOP
35E8  0012     RETURN 0
187:           
188:           /**********************************************************************
189:            * Hook routine called just before entering in a task.
190:            *
191:            * @return void
192:            **********************************************************************/
193:           void PreTaskHook(void)
194:           {
195:           }
35EA  0012     RETURN 0
196:           
197:           /**********************************************************************
198:            * Hook routine called just after leaving a task.
199:            *
200:            * @return void
201:            **********************************************************************/
202:           void PostTaskHook(void)
203:           {
204:           }
35EC  0012     RETURN 0
205:           
206:           /* End of File : main.c */
---  F:/PICOS18/TiltDetector/int.c  ---------------------------------------------------------------------
1:             /**********************************************************************/
2:             /*                                                                    */
3:             /* File name: int.c                                                   */
4:             /*                                                                    */
5:             /* Since:     2004-Sept-20                                            */
6:             /*                                                                    */
7:             /* Version:   PICos18 v3.00                                           */
8:             /*            Copyright (C) 2003, 2004, 2005 Pragmatec.               */
9:             /*                                                                    */
10:            /* Author:    Designed by Pragmatec S.A.R.L.        www.pragmatec.net */
11:            /*            MONTAGNE Xavier [XM]      xavier.montagne@pragmatec.net */
12:            /*            KUSHNIR  Sergey [KS]                     icd2usb@tut.by */
13:            /*                                                                    */
14:            /* Purpose:   Interrupt vector location.                              */
15:            /*                                                                    */
16:            /* Distribution: This file is part of PICos18.                        */
17:            /*            PICos18 is free software; you can redistribute it       */
18:            /*            and/or modify it under the terms of the GNU General     */
19:            /*            Public License as published by the Free Software        */
20:            /*            Foundation; either version 2, or (at your option)       */
21:            /*            any later version.                                      */
22:            /*                                                                    */
23:            /*            PICos18 is distributed in the hope that it will be      */
24:            /*            useful, but WITHOUT ANY WARRANTY; without even the      */
25:            /*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
26:            /*            PARTICULAR PURPOSE.  See the GNU General Public         */
27:            /*            License for more details.                               */
28:            /*                                                                    */
29:            /*            You should have received a copy of the GNU General      */
30:            /*            Public License along with gpsim; see the file           */
31:            /*            COPYING.txt. If not, write to the Free Software         */
32:            /*            Foundation, 59 Temple Place - Suite 330,                */
33:            /*            Boston, MA 02111-1307, USA.                             */
34:            /*                                                                    */
35:            /*          > A special exception to the GPL can be applied should    */
36:            /*            you wish to distribute a combined work that includes    */
37:            /*            PICos18, without being obliged to provide the source    */
38:            /*            code for any proprietary components.                    */
39:            /*                                                                    */
40:            /* History:                                                           */
41:            /* 2004/12/01 [XM]  Create this file.                                 */
42:            /* 2005/10/29 [XM]  Removed the "save" statement for InterruptL.      */
43:            /*                  Added "nosave" statement for InterruptH.          */
44:            /* 2007/10/30 [KS]  Removed the InterruptVectorL statement for C18    */
45:            /*                  error reasons.Replaced by SAVE(RESTORE)_TASK_CTX. */
46:            /*                                                                    */
47:            /**********************************************************************/
48:            #include "define.h"
49:            
50:            #include "drv_rs.h"
51:            #include "user.h"
52:            #include "button.h"
53:            #include "tsk_task_main.h"
54:            #include "Config.h"
55:            #include <stdlib.h>
56:            #include "rs232.h"
57:            #include "drv_rs.h"
58:            
59:            /**********************************************************************
60:             * Function you want to call when an IT occurs.
61:             **********************************************************************/
62:              extern unsigned char stack_low, stack_high;
63:              extern void AddOneTick(void);
64:              //  /*extern void MyOwnISR(void); */
65:              void InterruptVectorL(void);
66:              void InterruptVectorH(void);
67:              
68:              
69:              extern  volatile char KEY;  				
70:              extern volatile char KEY_VALID;
71:              
72:              extern void I2C_INT(void);
73:            
74:              extern void RS_RX_INT(void);
75:              extern void RS_TX_INT(void);
76:            
77:            ////	#pragma idata bank4=0x725
78:            //	
79:            // // unsigned char StateLCDON=0, StateBefor=0;
80:            //  
81:            //  #pragma idata bank6=0x850
82:                unsigned char SW_STATE=0,MsgCanSended=1;
83:                unsigned int Duration=0;
84:                unsigned char KEY_Pressed_Befor=0;
85:                unsigned int TimeStep=0;
86:            
87:            /**********************************************************************
88:             * General interrupt vector. Do not modify.
89:             **********************************************************************/
90:            #pragma code IT_vector_low=0x18
91:            void Interrupt_low_vec(void)
92:            {
93:               _asm goto InterruptVectorL  _endasm
0018  EF00     GOTO 0x3000
001A  F018     NOP
94:            }
001C  0012     RETURN 0
95:            #pragma code
96:            
97:            #pragma code IT_vector_high=0x08
98:            void Interrupt_high_vec(void)
99:            {
100:              _asm goto InterruptVectorH  _endasm
0008  EF80     GOTO 0x3500
000A  F01A     NOP
101:           }
000C  0012     RETURN 0
102:           #pragma code
103:           
104:           /**********************************************************************
105:            * General ISR router. Complete the function core with the if or switch
106:            * case you need to jump to the function dedicated to the occuring IT.
107:            * .tmpdata and MATH_DATA are saved automaticaly with C18 v3.
108:            **********************************************************************/
109:           #pragma	code _INTERRUPT_VECTORL = 0x003000
110:           void InterruptVectorL(void)
111:           {
112:               SAVE_TASK_CTX(stack_low, stack_high);
3000  9CF2     BCF INTCON, 6, ACCESS
3002  CFD8     MOVFF STATUS, PREINC1
3004  FFE4     NOP
3006  CFE8     MOVFF WREG, PREINC1
3008  FFE4     NOP
300A  CFE0     MOVFF BSR, PREINC1
300C  FFE4     NOP
300E  CFD9     MOVFF FSR2, PREINC1
3010  FFE4     NOP
3012  CFDA     MOVFF FSR2H, PREINC1
3014  FFE4     NOP
3016  CFE9     MOVFF FSR0, PREINC1
3018  FFE4     NOP
301A  CFEA     MOVFF FSR0H, PREINC1
301C  FFE4     NOP
301E  CFF8     MOVFF TBLPTRU, PREINC1
3020  FFE4     NOP
3022  CFF7     MOVFF TBLPTRH, PREINC1
3024  FFE4     NOP
3026  CFF6     MOVFF TBLPTR, PREINC1
3028  FFE4     NOP
302A  CFF5     MOVFF TABLAT, PREINC1
302C  FFE4     NOP
302E  CFF4     MOVFF PRODH, PREINC1
3030  FFE4     NOP
3032  CFF3     MOVFF PROD, PREINC1
3034  FFE4     NOP
3036  CFFB     MOVFF PCLATU, PREINC1
3038  FFE4     NOP
303A  CFFA     MOVFF PCLATH, PREINC1
303C  FFE4     NOP
303E  0E1F     MOVLW 0x1F
3040  6AE9     CLRF FSR0, ACCESS
3042  6AEA     CLRF FSR0H, ACCESS
3044  50E8     MOVF WREG, W, ACCESS
3046  06E8     DECF WREG, F, ACCESS
3048  0900     IORLW 0x0
304A  E003     BZ 0x3052
304C  CFEE     MOVFF POSTINC0, PREINC1
304E  FFE4     NOP
3050  D7F9     BRA 0x3044
3052  CFFC     MOVFF STKPTR, FSR0
3054  FFE9     NOP
3056  50FC     MOVF STKPTR, W, ACCESS
3058  0800     SUBLW 0x0
305A  E208     BC 0x306C
305C  CFFD     MOVFF TOS, PREINC1
305E  FFE4     NOP
3060  CFFE     MOVFF TOSH, PREINC1
3062  FFE4     NOP
3064  CFFF     MOVFF TOSU, PREINC1
3066  FFE4     NOP
3068  0006     POP
306A  D7F5     BRA 0x3056
306C  CFE9     MOVFF FSR0, PREINC1
306E  FFE4     NOP
3070  52E4     MOVF PREINC1, F, ACCESS
3072  C06B     MOVFF stack_low, FSR0
3074  FFE9     NOP
3076  C06C     MOVFF stack_high, FSR0H
3078  FFEA     NOP
307A  CFE1     MOVFF FSR1, POSTINC0
307C  FFEE     NOP
307E  CFE2     MOVFF FSR1H, POSTINC0
3080  FFEE     NOP
113:               EnterISR();
3082  EC90     CALL 0x120, 0
3084  F000     NOP
114:               if (INTCONbits.TMR0IF == 1)
3086  A4F2     BTFSS INTCON, 2, ACCESS
3088  D002     BRA 0x308E
115:               {
116:               	AddOneTick();
308A  ECF3     CALL 0x9E6, 0
308C  F004     NOP
117:               }
118:           
119:           	//******************************************************
120:             	/*Here is the next interrupts you want to manage */
121:             
122:           //************************************************
123:           //Gestion des inputs
124:           	
125:           	if(SW_UP==1)
308E  A081     BTFSS PORTB, 0, ACCESS
3090  D009     BRA 0x30A4
126:           	{	KEY=UP;SW_STATE=UP;
3092  010E     MOVLB 0xE
3094  0E04     MOVLW 0x4
3096  6F3F     MOVWF 0x3F, BANKED
3098  0107     MOVLB 0x7
309A  0E04     MOVLW 0x4
309C  6FF1     MOVWF 0xF1, BANKED
127:           	    MsgCanSended=0;	    
309E  0107     MOVLB 0x7
30A0  6BF2     CLRF 0xF2, BANKED
128:           	}
129:           	else 
30A2  D017     BRA 0x30D2
130:           	if(SW_DOWN==1)
30A4  A281     BTFSS PORTB, 1, ACCESS
30A6  D009     BRA 0x30BA
131:           	{
132:           		KEY=DOWN;SW_STATE=DOWN;	    
30A8  010E     MOVLB 0xE
30AA  0E05     MOVLW 0x5
30AC  6F3F     MOVWF 0x3F, BANKED
30AE  0107     MOVLB 0x7
30B0  0E05     MOVLW 0x5
30B2  6FF1     MOVWF 0xF1, BANKED
133:           	    MsgCanSended=0;
30B4  0107     MOVLB 0x7
30B6  6BF2     CLRF 0xF2, BANKED
134:           	}
135:           	else 
30B8  D00C     BRA 0x30D2
136:           //***********************************************************	  
137:           	if(SW_TEST_PROD)
30BA  B481     BTFSC PORTB, 2, ACCESS
138:           	{	
139:           		
140:           	}else
30BC  D00A     BRA 0x30D2
141:           	
142:           //****************************************************************
143:           	 
144:           	if (KEY_VALID==0)              
30BE  010E     MOVLB 0xE
30C0  5140     MOVF 0x40, W, BANKED
30C2  E107     BNZ 0x30D2
145:               	{
146:               	KEY=KEY_NULL;  
30C4  010E     MOVLB 0xE
30C6  6B3F     CLRF 0x3F, BANKED
147:           		
148:                       KEY_Pressed_Befor=0;
30C8  0107     MOVLB 0x7
30CA  6BF5     CLRF 0xF5, BANKED
149:                       TimeStep=0;
30CC  0107     MOVLB 0x7
30CE  6BF6     CLRF 0xF6, BANKED
30D0  6BF7     CLRF 0xF7, BANKED
150:           	}
151:           	  	  
152:           //***************************************************************	  
153:           	 if((KEY!=KEY_NULL)&&(KEY_Pressed_Befor==0))
30D2  010E     MOVLB 0xE
30D4  513F     MOVF 0x3F, W, BANKED
30D6  E009     BZ 0x30EA
30D8  0107     MOVLB 0x7
30DA  51F5     MOVF 0xF5, W, BANKED
30DC  E106     BNZ 0x30EA
154:           	 {	
155:                       KEY_Pressed_Befor=1;
30DE  0107     MOVLB 0x7
30E0  0E01     MOVLW 0x1
30E2  6FF5     MOVWF 0xF5, BANKED
156:                       KEY_VALID = TRUE;
30E4  010E     MOVLB 0xE
30E6  0E01     MOVLW 0x1
30E8  6F40     MOVWF 0x40, BANKED
157:                      // SetEvent(TASK_Main_ID,STATE_MENU_EVENT);	 //??? A verifier
158:           	 }
159:           	
160:           	if ((PIR1bits.RCIF)&(PIE1bits.RCIE))
30EA  509D     MOVF PIE1, W, ACCESS
30EC  0B20     ANDLW 0x20
30EE  E001     BZ 0x30F2
30F0  0E01     MOVLW 0x1
30F2  6E14     MOVWF __tmp_0, ACCESS
30F4  509E     MOVF PIR1, W, ACCESS
30F6  0B20     ANDLW 0x20
30F8  E001     BZ 0x30FC
30FA  0E01     MOVLW 0x1
30FC  1414     ANDWF __tmp_0, W, ACCESS
30FE  E002     BZ 0x3104
161:                       RS_RX_INT();
3100  ECB9     CALL 0x2B72, 0
3102  F015     NOP
162:             	if ((PIR1bits.TXIF)&(PIE1bits.TXIE))
3104  509D     MOVF PIE1, W, ACCESS
3106  0B10     ANDLW 0x10
3108  E001     BZ 0x310C
310A  0E01     MOVLW 0x1
310C  6E14     MOVWF __tmp_0, ACCESS
310E  509E     MOVF PIR1, W, ACCESS
3110  0B10     ANDLW 0x10
3112  E001     BZ 0x3116
3114  0E01     MOVLW 0x1
3116  1414     ANDWF __tmp_0, W, ACCESS
3118  E002     BZ 0x311E
163:                       RS_TX_INT();
311A  EC69     CALL 0x2AD2, 0
311C  F015     NOP
164:           	
165:             	LeaveISR();
311E  EC96     CALL 0x12C, 0
3120  F000     NOP
166:             	RESTORE_TASK_CTX;
3122  EF9B     GOTO 0x1D36
3124  F00E     NOP
167:           }
3126  0012     RETURN 0
168:           #pragma	code
169:           
170:           /* BE CARREFULL : ONLY BSR, WREG AND STATUS REGISTERS ARE SAVED  */
171:           /* DO NOT CALL ANY FUNCTION AND USE PLEASE VERY SIMPLE CODE LIKE */
172:           /* VARIABLE OR FLAG SETTINGS. CHECK THE ASM CODE PRODUCED BY C18 */
173:           /* IN THE LST FILE.                                              */
174:           #pragma	code _INTERRUPT_VECTORH = 0x003500
175:           #pragma interrupt InterruptVectorH nosave=FSR0, TBLPTRL, TBLPTRH, TBLPTRU, TABLAT, PCLATH, PCLATU, PROD, section(".tmpdata"), section("MATH_DATA")
176:           void InterruptVectorH(void)
3500  CFDA     MOVFF FSR2H, PREINC1
3502  FFE4     NOP
3504  CFE2     MOVFF FSR1H, FSR2H
3506  FFDA     NOP
3508  52E6     MOVF POSTINC1, F, ACCESS
177:           {
178:             	if (INTCONbits.INT0IF == 1)
350A  B2F2     BTFSC INTCON, 1, ACCESS
179:               	INTCONbits.INT0IF = 0;
350C  92F2     BCF INTCON, 1, ACCESS
180:           }
350E  52E5     MOVF POSTDEC1, F, ACCESS
3510  CFE5     MOVFF POSTDEC1, FSR2H
3512  FFDA     NOP
3514  0011     RETFIE 1
181:           #pragma	code
182:           
183:           extern void _startup (void);
184:           #pragma code _RESET_INTERRUPT_VECTOR = 0x003600
185:           void _reset (void)
186:           {
187:               _asm goto _startup _endasm
3600  EFE1     GOTO 0x2FC2
3602  F017     NOP
188:           }
3604  0012     RETURN 0
189:           #pragma code
190:           
191:           
192:           /* End of file : int.c */
---  F:/PICOS18/TiltDetector/drv_rs.c  ------------------------------------------------------------------
1:             /**********************************************************************/
2:             /*                                                                    */
3:             /* File name: drv_rs.c                                                */
4:             /*                                                                    */
5:             /* Since:     2005-Jan-08                                             */
6:             /*                                                                    */
7:             /* Version:   PICos18 v2.03                                           */
8:             /*            Copyright (C) 2003, 2004, 2005 Pragmatec.               */
9:             /*            RS232 driver v1.07                                      */
10:            /*                                                                    */
11:            /* Author:    Designed by Pragmatec S.A.R.L.        www.pragmatec.net */
12:            /*            MONTAGNE Xavier [XM]      xavier.montagne@pragmatec.net */
13:            /*                                                                    */
14:            /* Purpose:   Manage RS232 generic buffers through the PIC18 USART.   */
15:            /*            Can send ASCII (with printf) or binary string of data.  */
16:            /*                                                                    */
17:            /* Distribution: This file is part of PICos18.                        */
18:            /*            PICos18 is free software; you can redistribute it       */
19:            /*            and/or modify it under the terms of the GNU General     */
20:            /*            Public License as published by the Free Software        */
21:            /*            Foundation; either version 2, or (at your option)       */
22:            /*            any later version.                                      */
23:            /*                                                                    */
24:            /*            PICos18 is distributed in the hope that it will be      */
25:            /*            useful, but WITHOUT ANY WARRANTY; without even the      */
26:            /*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
27:            /*            PARTICULAR PURPOSE.  See the GNU General Public         */
28:            /*            License for more details.                               */
29:            /*                                                                    */
30:            /*            You should have received a copy of the GNU General      */
31:            /*            Public License along with gpsim; see the file           */
32:            /*            COPYING.txt. If not, write to the Free Software         */
33:            /*            Foundation, 59 Temple Place - Suite 330,                */
34:            /*            Boston, MA 02111-1307, USA.                             */
35:            /*                                                                    */
36:            /*          > A special exception to the GPL can be applied should    */
37:            /*            you wish to distribute a combined work that includes    */
38:            /*            PICos18, without being obliged to provide the source    */
39:            /*            code for any proprietary components.                    */
40:            /*                                                                    */
41:            /* History:                                                           */
42:            /* 2005/01/08 [XM]  Create this file.                                 */
43:            /* 2005/01/11 [XM]  Modified RS_TX_INT to avoid space character at    */
44:            /*                  the beginning of the new line.                    */
45:            /* 2005/02/27 [XM]  Set TXREG before "TXSTAbits.TXEN = 1;" in the task*/
46:            /*                  code to avoid a NULL character to be transmited   */
47:            /*                  when the transfer starts.                         */
48:            /* 2005/03/10 [XM]  Used PIR1bits.TXIF and PIE1bits.TXIE instead of   */
49:            /*                  TXEN to enable or disable the transfer.           */
50:            /* 2005/03/15 [XM]  Fixed a bug in "RS_RX_INT" and set RX_ByteNumber  */
51:            /*                  to 0 in RS_RCV_Register.                          */
52:            /* 2005/05/04 [XM]  Added the "pattern" field of the RS_RCV_Register  */
53:            /*                  function to be awaked on a special character.     */
54:            /*                                                                    */
55:            /**********************************************************************/
56:            
57:            #include "define.h"
58:            #include "drv_rs.h"
59:            
60:            #include <stdio.h>
61:            #include <string.h>
62:            
63:            /* Callback function dedicated to printf output interface */
64:            int _user_putc (char c);
65:            
66:            
67:            /**********************************************************************
68:             * Definition dedicated to the local functions.
69:             **********************************************************************/
70:            EventMaskType   RS_event;
71:            
72:            RS_message_tRef	RS_list_head;			//	Start of message queue
73:            RS_message_tRef	RS_current_message;		//	Current message
74:            unsigned char	RS_list_count = 0;		//	Number of items currently in queue
75:            
76:            RS_message_tRef	RS_list_head_rcv;		//	Start of message queue
77:            unsigned char	RS_list_count_rcv = 0;	//	Number of items currently in queue
78:            
79:            unsigned int    TX_ByteNumber = 0;
80:            unsigned int    RX_ByteNumber = 0;
81:            
82:            /**********************************************************************
83:             * ----------------- RS DRIVER - PIC18 USART MANAGEMENT ---------------
84:             *
85:             * void
86:             *
87:             **********************************************************************/
88:            TASK(RS_Drv)
89:            {  
90:              /* Reset USART registers to POR state */
91:              TXSTA            = 0; 
265C  6AAD     CLRF TXSTA1, ACCESS
92:              RCSTA            = 0;
265E  6AAC     CLRF RCSTA1, ACCESS
93:              
94:              /* Change baud rate here  [cf datasheet]*/
95:              /* SPBRG = 255; for   9600 [40MHZ only]*/
96:              /* SPBRG =  21; for 115200 [40MHZ only]*/
97:              SPBRG            = 21;
2660  0E15     MOVLW 0x15
2662  6EB0     MOVWF SPBRG1, ACCESS
98:              TXSTAbits.BRGH   = 1;
2664  84AD     BSF TXSTA1, 2, ACCESS
99:              
100:             TXSTAbits.SYNC   = 0;
2666  98AD     BCF TXSTA1, 4, ACCESS
101:             RCSTAbits.SPEN   = 1;
2668  8EAC     BSF RCSTA1, 7, ACCESS
102:             TXSTAbits.TXEN   = 0;
266A  9AAD     BCF TXSTA1, 5, ACCESS
103:             RCSTAbits.CREN   = 1;
266C  88AC     BSF RCSTA1, 4, ACCESS
104:             TRISCbits.TRISC7 = 1;
266E  8E94     BSF TRISC, 7, ACCESS
105:             TRISCbits.TRISC6 = 0;
2670  9C94     BCF TRISC, 6, ACCESS
106:             
107:             PIR1bits.TXIF    = 0;
2672  989E     BCF PIR1, 4, ACCESS
108:             PIR1bits.RCIF    = 0;
2674  9A9E     BCF PIR1, 5, ACCESS
109:             PIE1bits.RCIE    = 0;//La reception n'est pas utilisée.
2676  9A9D     BCF PIE1, 5, ACCESS
110:             PIE1bits.TXIE    = 0;  
2678  989D     BCF PIE1, 4, ACCESS
111:             RS_current_message = NULL;
267A  0107     MOVLB 0x7
267C  6BED     CLRF 0xED, BANKED
267E  6BEE     CLRF 0xEE, BANKED
112:           
113:             /* for 'printf' function redirection */
114:             stdout = _H_USER;
2680  010E     MOVLB 0xE
2682  6941     SETF 0x41, BANKED
2684  6942     SETF 0x42, BANKED
115:           
116:             while(1)
272C  D7AC     BRA 0x2686
117:             {
118:               WaitEvent(RS_NEW_MSG | RS_RCV_MSG);
2686  0E30     MOVLW 0x30
2688  6EE6     MOVWF POSTINC1, ACCESS
268A  EC74     CALL 0x18E8, 0
268C  F00C     NOP
268E  52E5     MOVF POSTDEC1, F, ACCESS
119:               GetEvent(RS_DRV_ID, &RS_event);
2690  0EEA     MOVLW 0xEA
2692  6EE6     MOVWF POSTINC1, ACCESS
2694  0E07     MOVLW 0x7
2696  6EE6     MOVWF POSTINC1, ACCESS
2698  0E02     MOVLW 0x2
269A  6EE6     MOVWF POSTINC1, ACCESS
269C  EC11     CALL 0x1822, 0
269E  F00C     NOP
26A0  52E5     MOVF POSTDEC1, F, ACCESS
26A2  52E5     MOVF POSTDEC1, F, ACCESS
26A4  52E5     MOVF POSTDEC1, F, ACCESS
120:               
121:               if (RS_event & RS_RCV_MSG)
26A6  0107     MOVLB 0x7
26A8  ABEA     BTFSS 0xEA, 5, BANKED
26AA  D005     BRA 0x26B6
122:                 ClearEvent(RS_RCV_MSG);
26AC  0E20     MOVLW 0x20
26AE  6EE6     MOVWF POSTINC1, ACCESS
26B0  ECAA     CALL 0x1754, 0
26B2  F00B     NOP
26B4  52E5     MOVF POSTDEC1, F, ACCESS
123:           
124:               if (RS_event & RS_NEW_MSG)
26B6  0107     MOVLB 0x7
26B8  A9EA     BTFSS 0xEA, 4, BANKED
26BA  D038     BRA 0x272C
125:               {
126:                 ClearEvent(RS_NEW_MSG);
26BC  0E10     MOVLW 0x10
26BE  6EE6     MOVWF POSTINC1, ACCESS
26C0  ECAA     CALL 0x1754, 0
26C2  F00B     NOP
26C4  52E5     MOVF POSTDEC1, F, ACCESS
127:                 if (PIE1bits.TXIE == 0)
26C6  B89D     BTFSC PIE1, 4, ACCESS
26C8  D031     BRA 0x272C
128:                 {
129:                   if (RS_current_message != NULL)
26CA  0107     MOVLB 0x7
26CC  51ED     MOVF 0xED, W, BANKED
26CE  11EE     IORWF 0xEE, W, BANKED
26D0  E015     BZ 0x26FC
130:                   {
131:                     RS_current_message->length = 0;
26D2  C7ED     MOVFF RS_current_message, FSR0
26D4  FFE9     NOP
26D6  C7EE     MOVFF 0x7EE, FSR0H
26D8  FFEA     NOP
26DA  0E02     MOVLW 0x2
26DC  6AEB     CLRF PLUSW0, ACCESS
26DE  0E03     MOVLW 0x3
26E0  6AEB     CLRF PLUSW0, ACCESS
132:                     SetEvent(RS_current_message->CallerID, RS_QUEUE_EMPTY);
26E2  0E10     MOVLW 0x10
26E4  6EE6     MOVWF POSTINC1, ACCESS
26E6  C7ED     MOVFF RS_current_message, FSR0
26E8  FFE9     NOP
26EA  C7EE     MOVFF 0x7EE, FSR0H
26EC  FFEA     NOP
26EE  0E05     MOVLW 0x5
26F0  50EB     MOVF PLUSW0, W, ACCESS
26F2  6EE6     MOVWF POSTINC1, ACCESS
26F4  EC17     CALL 0x162E, 0
26F6  F00B     NOP
26F8  52E5     MOVF POSTDEC1, F, ACCESS
26FA  52E5     MOVF POSTDEC1, F, ACCESS
133:                   }
134:                   RS_current_message = RS_deqMsg();
26FC  D8A6     RCALL RS_deqMsg
26FE  CFF3     MOVFF PROD, RS_current_message
2700  F7ED     NOP
2702  CFF4     MOVFF PRODH, 0x7EE
2704  F7EE     NOP
135:                   if (RS_current_message != NULL)
2706  0107     MOVLB 0x7
2708  51ED     MOVF 0xED, W, BANKED
270A  11EE     IORWF 0xEE, W, BANKED
270C  E00F     BZ 0x272C
136:                   {
137:                     TX_ByteNumber = 0;
270E  0107     MOVLB 0x7
2710  6BFA     CLRF 0xFA, BANKED
2712  6BFB     CLRF 0xFB, BANKED
138:                     TXREG = RS_current_message->data[0];
2714  C7ED     MOVFF RS_current_message, FSR0
2716  FFE9     NOP
2718  C7EE     MOVFF 0x7EE, FSR0H
271A  FFEA     NOP
271C  50EE     MOVF POSTINC0, W, ACCESS
271E  CFEF     MOVFF INDF0, FSR0H
2720  FFEA     NOP
2722  6EE9     MOVWF FSR0, ACCESS
2724  50EF     MOVF INDF0, W, ACCESS
2726  6EAE     MOVWF TXREG1, ACCESS
139:                     TXSTAbits.TXEN = 1;
2728  8AAD     BSF TXSTA1, 5, ACCESS
140:                     PIE1bits.TXIE = 1;
272A  889D     BSF PIE1, 4, ACCESS
141:                   }
142:                 }
143:               }
144:             }
145:           }
272E  0012     RETURN 0
146:           
147:           /**********************************************************************
148:            *	Enqueue a client packet object into the RS task queue.
149:            *
150:            *	Once placed in queue, client must not modify the data
151:            *	otherwise unpredictable results. To safely change the object,
152:            *	dequeue, modify, re-enqueue.
153:            *
154:            *  The code in mainly executed in critical region [SuspendAllInterrupt]
155:            *  because many tasks can call this function at the same time and break
156:            *  the FIFO list.
157:            *
158:            * @param  toEnqueue  IN  New message structure reference
159:            * @param  data       IN  Buffer which contains the string of data
160:            * @param  length     IN  Length of the Buffer field
161:            * @return Status         E_OK if toEnqueue is well attached to the list
162:            *                        E_OS_STATE if message could not be enqueued
163:            **********************************************************************/
164:           StatusType RS_enqMsg(RS_message_tRef toEnqueue, unsigned char *data, unsigned int length)
2730  CFD9     MOVFF FSR2, POSTINC1
2732  FFE6     NOP
2734  CFE1     MOVFF FSR1, FSR2
2736  FFD9     NOP
2738  0E02     MOVLW 0x2
273A  26E1     ADDWF FSR1, F, ACCESS
165:           {
166:             RS_message_tRef RS_list_itor;
167:           
168:             if (toEnqueue != NULL)
273C  50D9     MOVF FSR2, W, ACCESS
273E  0FFD     ADDLW 0xFD
2740  6EE9     MOVWF FSR0, ACCESS
2742  0EFF     MOVLW 0xFF
2744  20DA     ADDWFC FSR2H, W, ACCESS
2746  6EEA     MOVWF FSR0H, ACCESS
2748  50EE     MOVF POSTINC0, W, ACCESS
274A  10ED     IORWF POSTDEC0, W, ACCESS
274C  E070     BZ 0x282E
169:             {
170:               SuspendOSInterrupts();
274E  EC8E     CALL 0x11C, 0
2750  F000     NOP
171:               if (RS_list_head == NULL)
2752  0107     MOVLB 0x7
2754  51EB     MOVF 0xEB, W, BANKED
2756  11EC     IORWF 0xEC, W, BANKED
2758  E107     BNZ 0x2768
172:                 RS_list_head = toEnqueue;
275A  0EFD     MOVLW 0xFD
275C  CFDB     MOVFF PLUSW2, RS_list_head
275E  F7EB     NOP
2760  0EFE     MOVLW 0xFE
2762  CFDB     MOVFF PLUSW2, 0x7EC
2764  F7EC     NOP
173:               else
2766  D02A     BRA 0x27BC
174:               {
175:                 RS_list_itor = RS_list_head;
2768  C7EB     MOVFF RS_list_head, POSTINC2
276A  FFDE     NOP
276C  C7EC     MOVFF 0x7EC, POSTDEC2
276E  FFDD     NOP
176:                 while (RS_list_itor->next != NULL)
2770  CFDE     MOVFF POSTINC2, FSR0
2772  FFE9     NOP
2774  CFDD     MOVFF POSTDEC2, FSR0H
2776  FFEA     NOP
2778  0E06     MOVLW 0x6
277A  26E9     ADDWF FSR0, F, ACCESS
277C  0E00     MOVLW 0x0
277E  22EA     ADDWFC FSR0H, F, ACCESS
2780  50EE     MOVF POSTINC0, W, ACCESS
2782  10ED     IORWF POSTDEC0, W, ACCESS
2784  E00D     BZ 0x27A0
279E  D7E8     BRA 0x2770
177:                   RS_list_itor = RS_list_itor->next;
2786  CFDE     MOVFF POSTINC2, FSR0
2788  FFE9     NOP
278A  CFDD     MOVFF POSTDEC2, FSR0H
278C  FFEA     NOP
278E  0E06     MOVLW 0x6
2790  26E9     ADDWF FSR0, F, ACCESS
2792  0E00     MOVLW 0x0
2794  22EA     ADDWFC FSR0H, F, ACCESS
2796  CFEE     MOVFF POSTINC0, POSTINC2
2798  FFDE     NOP
279A  CFED     MOVFF POSTDEC0, POSTDEC2
279C  FFDD     NOP
178:                 RS_list_itor->next = toEnqueue;
27A0  CFDE     MOVFF POSTINC2, FSR0
27A2  FFE9     NOP
27A4  CFDD     MOVFF POSTDEC2, FSR0H
27A6  FFEA     NOP
27A8  0E06     MOVLW 0x6
27AA  26E9     ADDWF FSR0, F, ACCESS
27AC  0E00     MOVLW 0x0
27AE  22EA     ADDWFC FSR0H, F, ACCESS
27B0  0EFD     MOVLW 0xFD
27B2  CFDB     MOVFF PLUSW2, POSTINC0
27B4  FFEE     NOP
27B6  0EFE     MOVLW 0xFE
27B8  CFDB     MOVFF PLUSW2, POSTDEC0
27BA  FFED     NOP
179:               }
180:               toEnqueue->next     = NULL;
27BC  0EFD     MOVLW 0xFD
27BE  CFDB     MOVFF PLUSW2, FSR0
27C0  FFE9     NOP
27C2  0EFE     MOVLW 0xFE
27C4  CFDB     MOVFF PLUSW2, FSR0H
27C6  FFEA     NOP
27C8  0E06     MOVLW 0x6
27CA  6AEB     CLRF PLUSW0, ACCESS
27CC  0E07     MOVLW 0x7
27CE  6AEB     CLRF PLUSW0, ACCESS
181:               toEnqueue->CallerID = id_tsk_run;
27D0  0EFD     MOVLW 0xFD
27D2  CFDB     MOVFF PLUSW2, FSR0
27D4  FFE9     NOP
27D6  0EFE     MOVLW 0xFE
27D8  CFDB     MOVFF PLUSW2, FSR0H
27DA  FFEA     NOP
27DC  0E05     MOVLW 0x5
27DE  26E9     ADDWF FSR0, F, ACCESS
27E0  0E00     MOVLW 0x0
27E2  22EA     ADDWFC FSR0H, F, ACCESS
27E4  C06D     MOVFF id_tsk_run, INDF0
27E6  FFEF     NOP
182:               toEnqueue->length   = length;
27E8  0EFD     MOVLW 0xFD
27EA  CFDB     MOVFF PLUSW2, FSR0
27EC  FFE9     NOP
27EE  0EFE     MOVLW 0xFE
27F0  CFDB     MOVFF PLUSW2, FSR0H
27F2  FFEA     NOP
27F4  0E02     MOVLW 0x2
27F6  26E9     ADDWF FSR0, F, ACCESS
27F8  0E00     MOVLW 0x0
27FA  22EA     ADDWFC FSR0H, F, ACCESS
27FC  0EF9     MOVLW 0xF9
27FE  CFDB     MOVFF PLUSW2, POSTINC0
2800  FFEE     NOP
2802  0EFA     MOVLW 0xFA
2804  CFDB     MOVFF PLUSW2, POSTDEC0
2806  FFED     NOP
183:               toEnqueue->data     = data;
2808  0EFD     MOVLW 0xFD
280A  CFDB     MOVFF PLUSW2, FSR0
280C  FFE9     NOP
280E  0EFE     MOVLW 0xFE
2810  CFDB     MOVFF PLUSW2, FSR0H
2812  FFEA     NOP
2814  0EFB     MOVLW 0xFB
2816  CFDB     MOVFF PLUSW2, POSTINC0
2818  FFEE     NOP
281A  0EFC     MOVLW 0xFC
281C  CFDB     MOVFF PLUSW2, POSTDEC0
281E  FFED     NOP
184:               RS_list_count++;
2820  0107     MOVLB 0x7
2822  2BF8     INCF 0xF8, F, BANKED
185:               ResumeOSInterrupts();
2824  EC8C     CALL 0x118, 0
2826  F000     NOP
186:               return E_OK;
2828  0E00     MOVLW 0x0
282A  D003     BRA 0x2832
187:             }
188:             else
282C  D002     BRA 0x2832
189:               return E_OS_STATE;
282E  0E07     MOVLW 0x7
2830  D000     BRA 0x2832
190:           }
2832  6E14     MOVWF __tmp_0, ACCESS
2834  0E02     MOVLW 0x2
2836  5CE1     SUBWF FSR1, W, ACCESS
2838  E202     BC 0x283E
283A  6AE1     CLRF FSR1, ACCESS
283C  52E5     MOVF POSTDEC1, F, ACCESS
283E  6EE1     MOVWF FSR1, ACCESS
2840  5014     MOVF __tmp_0, W, ACCESS
2842  52E5     MOVF POSTDEC1, F, ACCESS
2844  CFE7     MOVFF INDF1, FSR2
2846  FFD9     NOP
2848  0012     RETURN 0
191:           
192:           /**********************************************************************
193:            *	Dequeue a client message from the RS task queue.
194:            *
195:            * @param  void
196:            * @return RS_list_itor   Reference of the top of the FIFO list
197:            *                        (next enqueued message)
198:            *********************************************************************/
199:           RS_message_tRef RS_deqMsg(void)
284A  CFD9     MOVFF FSR2, POSTINC1
284C  FFE6     NOP
284E  CFE1     MOVFF FSR1, FSR2
2850  FFD9     NOP
2852  0E02     MOVLW 0x2
2854  26E1     ADDWF FSR1, F, ACCESS
200:           {
201:             RS_message_tRef RS_list_itor;
202:           
203:             RS_list_itor = NULL;
2856  6ADE     CLRF POSTINC2, ACCESS
2858  6ADD     CLRF POSTDEC2, ACCESS
204:             if (RS_list_head != NULL)
285A  0107     MOVLB 0x7
285C  51EB     MOVF 0xEB, W, BANKED
285E  11EC     IORWF 0xEC, W, BANKED
2860  E012     BZ 0x2886
205:             {
206:               RS_list_itor = RS_list_head;
2862  C7EB     MOVFF RS_list_head, POSTINC2
2864  FFDE     NOP
2866  C7EC     MOVFF 0x7EC, POSTDEC2
2868  FFDD     NOP
207:               RS_list_head = RS_list_head->next;
286A  C7EB     MOVFF RS_list_head, FSR0
286C  FFE9     NOP
286E  C7EC     MOVFF 0x7EC, FSR0H
2870  FFEA     NOP
2872  0E06     MOVLW 0x6
2874  26E9     ADDWF FSR0, F, ACCESS
2876  0E00     MOVLW 0x0
2878  22EA     ADDWFC FSR0H, F, ACCESS
287A  CFEE     MOVFF POSTINC0, RS_list_head
287C  F7EB     NOP
287E  CFED     MOVFF POSTDEC0, 0x7EC
2880  F7EC     NOP
208:               RS_list_count--;
2882  0107     MOVLB 0x7
2884  07F8     DECF 0xF8, F, BANKED
209:             }
210:             return RS_list_itor;
2886  CFDE     MOVFF POSTINC2, __tmp_0
2888  F014     NOP
288A  CFDD     MOVFF POSTDEC2, 0x15
288C  F015     NOP
288E  C014     MOVFF __tmp_0, PROD
2890  FFF3     NOP
2892  C015     MOVFF 0x15, PRODH
2894  FFF4     NOP
211:           } 
2896  0E02     MOVLW 0x2
2898  5CE1     SUBWF FSR1, W, ACCESS
289A  E203     BC 0x28A2
289C  D000     BRA 0x289E
289E  6AE1     CLRF FSR1, ACCESS
28A0  52E5     MOVF POSTDEC1, F, ACCESS
28A2  6EE1     MOVWF FSR1, ACCESS
28A4  52E5     MOVF POSTDEC1, F, ACCESS
28A6  CFE7     MOVFF INDF1, FSR2
28A8  FFD9     NOP
28AA  0012     RETURN 0
212:           
213:           /**********************************************************************
214:            *	Enqueue a client packet object into the RS task queue.
215:            *
216:            *	Once placed in queue, client must not modify the data
217:            *	otherwise unpredictable results. To safely change the object,
218:            *	dequeue, modify, re-enqueue.
219:            *
220:            *  The code in mainly executed in critical region [SuspendAllInterrupt]
221:            *  because many tasks can call this function at the same time and break
222:            *  the FIFO list.
223:            *
224:            * @param  toEnqueue  IN  New message structure reference
225:            * @return Status         E_OK if toEnqueue is well attached to the list
226:            *                        E_OS_STATE if message could not be enqueued
227:            **********************************************************************/
228:           StatusType RS_RCV_Register(RS_message_tRef toEnqueue, unsigned char *data, 
28AC  CFD9     MOVFF FSR2, POSTINC1
28AE  FFE6     NOP
28B0  CFE1     MOVFF FSR1, FSR2
28B2  FFD9     NOP
28B4  0E02     MOVLW 0x2
28B6  26E1     ADDWF FSR1, F, ACCESS
229:                                      unsigned int length, unsigned char pattern)
230:           {
231:             RS_message_tRef RS_list_itor;
232:           
233:             if (toEnqueue != NULL)
28B8  50D9     MOVF FSR2, W, ACCESS
28BA  0FFD     ADDLW 0xFD
28BC  6EE9     MOVWF FSR0, ACCESS
28BE  0EFF     MOVLW 0xFF
28C0  20DA     ADDWFC FSR2H, W, ACCESS
28C2  6EEA     MOVWF FSR0H, ACCESS
28C4  50EE     MOVF POSTINC0, W, ACCESS
28C6  10ED     IORWF POSTDEC0, W, ACCESS
28C8  E101     BNZ 0x28CC
28CA  D080     BRA 0x29CC
234:             {
235:               SuspendOSInterrupts();
28CC  EC8E     CALL 0x11C, 0
28CE  F000     NOP
236:               if (RS_list_head_rcv == NULL)
28D0  0107     MOVLB 0x7
28D2  51EF     MOVF 0xEF, W, BANKED
28D4  11F0     IORWF 0xF0, W, BANKED
28D6  E107     BNZ 0x28E6
237:                 RS_list_head_rcv = toEnqueue;
28D8  0EFD     MOVLW 0xFD
28DA  CFDB     MOVFF PLUSW2, RS_list_head_rcv
28DC  F7EF     NOP
28DE  0EFE     MOVLW 0xFE
28E0  CFDB     MOVFF PLUSW2, 0x7F0
28E2  F7F0     NOP
238:               else
28E4  D02A     BRA 0x293A
239:               {
240:                 RS_list_itor = RS_list_head_rcv;
28E6  C7EF     MOVFF RS_list_head_rcv, POSTINC2
28E8  FFDE     NOP
28EA  C7F0     MOVFF 0x7F0, POSTDEC2
28EC  FFDD     NOP
241:                 while (RS_list_itor->next != NULL)
28EE  CFDE     MOVFF POSTINC2, FSR0
28F0  FFE9     NOP
28F2  CFDD     MOVFF POSTDEC2, FSR0H
28F4  FFEA     NOP
28F6  0E06     MOVLW 0x6
28F8  26E9     ADDWF FSR0, F, ACCESS
28FA  0E00     MOVLW 0x0
28FC  22EA     ADDWFC FSR0H, F, ACCESS
28FE  50EE     MOVF POSTINC0, W, ACCESS
2900  10ED     IORWF POSTDEC0, W, ACCESS
2902  E00D     BZ 0x291E
291C  D7E8     BRA 0x28EE
242:                   RS_list_itor = RS_list_itor->next;
2904  CFDE     MOVFF POSTINC2, FSR0
2906  FFE9     NOP
2908  CFDD     MOVFF POSTDEC2, FSR0H
290A  FFEA     NOP
290C  0E06     MOVLW 0x6
290E  26E9     ADDWF FSR0, F, ACCESS
2910  0E00     MOVLW 0x0
2912  22EA     ADDWFC FSR0H, F, ACCESS
2914  CFEE     MOVFF POSTINC0, POSTINC2
2916  FFDE     NOP
2918  CFED     MOVFF POSTDEC0, POSTDEC2
291A  FFDD     NOP
243:                 RS_list_itor->next = toEnqueue;
291E  CFDE     MOVFF POSTINC2, FSR0
2920  FFE9     NOP
2922  CFDD     MOVFF POSTDEC2, FSR0H
2924  FFEA     NOP
2926  0E06     MOVLW 0x6
2928  26E9     ADDWF FSR0, F, ACCESS
292A  0E00     MOVLW 0x0
292C  22EA     ADDWFC FSR0H, F, ACCESS
292E  0EFD     MOVLW 0xFD
2930  CFDB     MOVFF PLUSW2, POSTINC0
2932  FFEE     NOP
2934  0EFE     MOVLW 0xFE
2936  CFDB     MOVFF PLUSW2, POSTDEC0
2938  FFED     NOP
244:               }
245:               toEnqueue->next     = NULL;
293A  0EFD     MOVLW 0xFD
293C  CFDB     MOVFF PLUSW2, FSR0
293E  FFE9     NOP
2940  0EFE     MOVLW 0xFE
2942  CFDB     MOVFF PLUSW2, FSR0H
2944  FFEA     NOP
2946  0E06     MOVLW 0x6
2948  6AEB     CLRF PLUSW0, ACCESS
294A  0E07     MOVLW 0x7
294C  6AEB     CLRF PLUSW0, ACCESS
246:               toEnqueue->CallerID = id_tsk_run;
294E  0EFD     MOVLW 0xFD
2950  CFDB     MOVFF PLUSW2, FSR0
2952  FFE9     NOP
2954  0EFE     MOVLW 0xFE
2956  CFDB     MOVFF PLUSW2, FSR0H
2958  FFEA     NOP
295A  0E05     MOVLW 0x5
295C  26E9     ADDWF FSR0, F, ACCESS
295E  0E00     MOVLW 0x0
2960  22EA     ADDWFC FSR0H, F, ACCESS
2962  C06D     MOVFF id_tsk_run, INDF0
2964  FFEF     NOP
247:               toEnqueue->length   = length;
2966  0EFD     MOVLW 0xFD
2968  CFDB     MOVFF PLUSW2, FSR0
296A  FFE9     NOP
296C  0EFE     MOVLW 0xFE
296E  CFDB     MOVFF PLUSW2, FSR0H
2970  FFEA     NOP
2972  0E02     MOVLW 0x2
2974  26E9     ADDWF FSR0, F, ACCESS
2976  0E00     MOVLW 0x0
2978  22EA     ADDWFC FSR0H, F, ACCESS
297A  0EF9     MOVLW 0xF9
297C  CFDB     MOVFF PLUSW2, POSTINC0
297E  FFEE     NOP
2980  0EFA     MOVLW 0xFA
2982  CFDB     MOVFF PLUSW2, POSTDEC0
2984  FFED     NOP
248:               toEnqueue->data     = data;
2986  0EFD     MOVLW 0xFD
2988  CFDB     MOVFF PLUSW2, FSR0
298A  FFE9     NOP
298C  0EFE     MOVLW 0xFE
298E  CFDB     MOVFF PLUSW2, FSR0H
2990  FFEA     NOP
2992  0EFB     MOVLW 0xFB
2994  CFDB     MOVFF PLUSW2, POSTINC0
2996  FFEE     NOP
2998  0EFC     MOVLW 0xFC
299A  CFDB     MOVFF PLUSW2, POSTDEC0
299C  FFED     NOP
249:               toEnqueue->pattern  = pattern;
299E  0EFD     MOVLW 0xFD
29A0  CFDB     MOVFF PLUSW2, FSR0
29A2  FFE9     NOP
29A4  0EFE     MOVLW 0xFE
29A6  CFDB     MOVFF PLUSW2, FSR0H
29A8  FFEA     NOP
29AA  0E04     MOVLW 0x4
29AC  26E9     ADDWF FSR0, F, ACCESS
29AE  0E00     MOVLW 0x0
29B0  22EA     ADDWFC FSR0H, F, ACCESS
29B2  0EF8     MOVLW 0xF8
29B4  CFDB     MOVFF PLUSW2, INDF0
29B6  FFEF     NOP
250:               RS_list_count_rcv++;
29B8  0107     MOVLB 0x7
29BA  2BF9     INCF 0xF9, F, BANKED
251:               RX_ByteNumber = 0;
29BC  0107     MOVLB 0x7
29BE  6BFC     CLRF 0xFC, BANKED
29C0  6BFD     CLRF 0xFD, BANKED
252:               ResumeOSInterrupts();
29C2  EC8C     CALL 0x118, 0
29C4  F000     NOP
253:               return E_OK;
29C6  0E00     MOVLW 0x0
29C8  D003     BRA 0x29D0
254:             }
255:             else
29CA  D002     BRA 0x29D0
256:               return E_OS_STATE;
29CC  0E07     MOVLW 0x7
29CE  D000     BRA 0x29D0
257:           }
29D0  6E14     MOVWF __tmp_0, ACCESS
29D2  0E02     MOVLW 0x2
29D4  5CE1     SUBWF FSR1, W, ACCESS
29D6  E202     BC 0x29DC
29D8  6AE1     CLRF FSR1, ACCESS
29DA  52E5     MOVF POSTDEC1, F, ACCESS
29DC  6EE1     MOVWF FSR1, ACCESS
29DE  5014     MOVF __tmp_0, W, ACCESS
29E0  52E5     MOVF POSTDEC1, F, ACCESS
29E2  CFE7     MOVFF INDF1, FSR2
29E4  FFD9     NOP
29E6  0012     RETURN 0
258:           
259:           /**********************************************************************
260:            *	Fill the structure with the printf content.
261:            *
262:            *  The code in mainly executed in critical region [SuspendAllInterrupt]
263:            *  because many tasks can call this function at the same time and break
264:            *  the FIFO list.
265:            *
266:            * @param  c          IN  Next character coming from the printf function
267:            * @return ByteNumber     Current char index in the buffer
268:            *********************************************************************/
269:           int _user_putc (char c)
29E8  CFD9     MOVFF FSR2, POSTINC1
29EA  FFE6     NOP
29EC  CFE1     MOVFF FSR1, FSR2
29EE  FFD9     NOP
29F0  0E02     MOVLW 0x2
29F2  26E1     ADDWF FSR1, F, ACCESS
270:           {
271:             RS_message_tRef RS_list_itor;
272:           
273:             SuspendOSInterrupts();
29F4  EC8E     CALL 0x11C, 0
29F6  F000     NOP
274:             RS_list_itor = RS_list_head;
29F8  C7EB     MOVFF RS_list_head, POSTINC2
29FA  FFDE     NOP
29FC  C7EC     MOVFF 0x7EC, POSTDEC2
29FE  FFDD     NOP
275:             while (RS_list_itor->CallerID != id_tsk_run)
2A00  CFDE     MOVFF POSTINC2, FSR0
2A02  FFE9     NOP
2A04  CFDD     MOVFF POSTDEC2, FSR0H
2A06  FFEA     NOP
2A08  0E05     MOVLW 0x5
2A0A  26E9     ADDWF FSR0, F, ACCESS
2A0C  0E00     MOVLW 0x0
2A0E  22EA     ADDWFC FSR0H, F, ACCESS
2A10  50EF     MOVF INDF0, W, ACCESS
2A12  0100     MOVLB 0x0
2A14  5D6D     SUBWF id_tsk_run, W, BANKED
2A16  E01B     BZ 0x2A4E
2A4C  D7D9     BRA 0x2A00
276:             {
277:               if (RS_list_itor->next == NULL)
2A18  CFDE     MOVFF POSTINC2, FSR0
2A1A  FFE9     NOP
2A1C  CFDD     MOVFF POSTDEC2, FSR0H
2A1E  FFEA     NOP
2A20  0E06     MOVLW 0x6
2A22  26E9     ADDWF FSR0, F, ACCESS
2A24  0E00     MOVLW 0x0
2A26  22EA     ADDWFC FSR0H, F, ACCESS
2A28  50EE     MOVF POSTINC0, W, ACCESS
2A2A  10ED     IORWF POSTDEC0, W, ACCESS
2A2C  E103     BNZ 0x2A34
278:                 return 0;
2A2E  6AF3     CLRF PROD, ACCESS
2A30  6AF4     CLRF PRODH, ACCESS
2A32  D045     BRA 0x2ABE
279:               RS_list_itor = RS_list_itor->next;
2A34  CFDE     MOVFF POSTINC2, FSR0
2A36  FFE9     NOP
2A38  CFDD     MOVFF POSTDEC2, FSR0H
2A3A  FFEA     NOP
2A3C  0E06     MOVLW 0x6
2A3E  26E9     ADDWF FSR0, F, ACCESS
2A40  0E00     MOVLW 0x0
2A42  22EA     ADDWFC FSR0H, F, ACCESS
2A44  CFEE     MOVFF POSTINC0, POSTINC2
2A46  FFDE     NOP
2A48  CFED     MOVFF POSTDEC0, POSTDEC2
2A4A  FFDD     NOP
280:             }
281:             RS_list_itor->data[RS_list_itor->length] = c;
2A4E  CFDE     MOVFF POSTINC2, FSR0
2A50  FFE9     NOP
2A52  CFDD     MOVFF POSTDEC2, FSR0H
2A54  FFEA     NOP
2A56  CFEE     MOVFF POSTINC0, __tmp_0
2A58  F014     NOP
2A5A  CFEF     MOVFF INDF0, 0x15
2A5C  F015     NOP
2A5E  CFDE     MOVFF POSTINC2, FSR0
2A60  FFE9     NOP
2A62  CFDD     MOVFF POSTDEC2, FSR0H
2A64  FFEA     NOP
2A66  0E02     MOVLW 0x2
2A68  26E9     ADDWF FSR0, F, ACCESS
2A6A  0E00     MOVLW 0x0
2A6C  22EA     ADDWFC FSR0H, F, ACCESS
2A6E  5014     MOVF __tmp_0, W, ACCESS
2A70  24EE     ADDWF POSTINC0, W, ACCESS
2A72  6EE7     MOVWF INDF1, ACCESS
2A74  5015     MOVF 0x15, W, ACCESS
2A76  20EE     ADDWFC POSTINC0, W, ACCESS
2A78  6EEA     MOVWF FSR0H, ACCESS
2A7A  CFE7     MOVFF INDF1, FSR0
2A7C  FFE9     NOP
2A7E  0EFE     MOVLW 0xFE
2A80  CFDB     MOVFF PLUSW2, INDF0
2A82  FFEF     NOP
282:             RS_list_itor->length++;
2A84  CFDE     MOVFF POSTINC2, FSR0
2A86  FFE9     NOP
2A88  CFDD     MOVFF POSTDEC2, FSR0H
2A8A  FFEA     NOP
2A8C  0E02     MOVLW 0x2
2A8E  26E9     ADDWF FSR0, F, ACCESS
2A90  0E00     MOVLW 0x0
2A92  22EA     ADDWFC FSR0H, F, ACCESS
2A94  2AEE     INCF POSTINC0, F, ACCESS
2A96  22EF     ADDWFC INDF0, F, ACCESS
283:             ResumeOSInterrupts();
2A98  EC8C     CALL 0x118, 0
2A9A  F000     NOP
284:             return RS_list_itor->length;
2A9C  CFDE     MOVFF POSTINC2, FSR0
2A9E  FFE9     NOP
2AA0  CFDD     MOVFF POSTDEC2, FSR0H
2AA2  FFEA     NOP
2AA4  0E02     MOVLW 0x2
2AA6  26E9     ADDWF FSR0, F, ACCESS
2AA8  0E00     MOVLW 0x0
2AAA  22EA     ADDWFC FSR0H, F, ACCESS
2AAC  CFEE     MOVFF POSTINC0, __tmp_0
2AAE  F014     NOP
2AB0  CFEF     MOVFF INDF0, 0x15
2AB2  F015     NOP
2AB4  C014     MOVFF __tmp_0, PROD
2AB6  FFF3     NOP
2AB8  C015     MOVFF 0x15, PRODH
2ABA  FFF4     NOP
2ABC  D000     BRA 0x2ABE
285:           }
2ABE  0E02     MOVLW 0x2
2AC0  5CE1     SUBWF FSR1, W, ACCESS
2AC2  E202     BC 0x2AC8
2AC4  6AE1     CLRF FSR1, ACCESS
2AC6  52E5     MOVF POSTDEC1, F, ACCESS
2AC8  6EE1     MOVWF FSR1, ACCESS
2ACA  52E5     MOVF POSTDEC1, F, ACCESS
2ACC  CFE7     MOVFF INDF1, FSR2
2ACE  FFD9     NOP
2AD0  0012     RETURN 0
286:           
287:           /**********************************************************************
288:            * Part of the transmiter interrupt.
289:            *
290:            * @param  void
291:            * @return void 
292:            **********************************************************************/
293:           void RS_TX_INT(void)
294:           {   
295:             if ((TX_ByteNumber > 0) && (TX_ByteNumber < RS_current_message->length))
2AD2  0107     MOVLB 0x7
2AD4  0E00     MOVLW 0x0
2AD6  80D8     BSF STATUS, 0, ACCESS
2AD8  55FA     SUBFWB 0xFA, W, BANKED
2ADA  0E00     MOVLW 0x0
2ADC  55FB     SUBFWB 0xFB, W, BANKED
2ADE  E224     BC 0x2B28
2AE0  C7ED     MOVFF RS_current_message, FSR0
2AE2  FFE9     NOP
2AE4  C7EE     MOVFF 0x7EE, FSR0H
2AE6  FFEA     NOP
2AE8  0E02     MOVLW 0x2
2AEA  26E9     ADDWF FSR0, F, ACCESS
2AEC  0E00     MOVLW 0x0
2AEE  22EA     ADDWFC FSR0H, F, ACCESS
2AF0  CFEE     MOVFF POSTINC0, __tmp_0
2AF2  F014     NOP
2AF4  CFEF     MOVFF INDF0, 0x15
2AF6  F015     NOP
2AF8  0107     MOVLB 0x7
2AFA  5014     MOVF __tmp_0, W, ACCESS
2AFC  5DFA     SUBWF 0xFA, W, BANKED
2AFE  5015     MOVF 0x15, W, ACCESS
2B00  59FB     SUBWFB 0xFB, W, BANKED
2B02  E212     BC 0x2B28
296:             {
297:               TXREG = RS_current_message->data[TX_ByteNumber];
2B04  C7ED     MOVFF RS_current_message, FSR0
2B06  FFE9     NOP
2B08  C7EE     MOVFF 0x7EE, FSR0H
2B0A  FFEA     NOP
2B0C  0107     MOVLB 0x7
2B0E  0107     MOVLB 0x7
2B10  51FA     MOVF 0xFA, W, BANKED
2B12  24EE     ADDWF POSTINC0, W, ACCESS
2B14  6EE7     MOVWF INDF1, ACCESS
2B16  0107     MOVLB 0x7
2B18  0107     MOVLB 0x7
2B1A  51FB     MOVF 0xFB, W, BANKED
2B1C  20EE     ADDWFC POSTINC0, W, ACCESS
2B1E  6EEA     MOVWF FSR0H, ACCESS
2B20  CFE7     MOVFF INDF1, FSR0
2B22  FFE9     NOP
2B24  50EF     MOVF INDF0, W, ACCESS
2B26  6EAE     MOVWF TXREG1, ACCESS
298:             }
299:             if (TX_ByteNumber  == (RS_current_message->length))
2B28  C7ED     MOVFF RS_current_message, FSR0
2B2A  FFE9     NOP
2B2C  C7EE     MOVFF 0x7EE, FSR0H
2B2E  FFEA     NOP
2B30  0E02     MOVLW 0x2
2B32  26E9     ADDWF FSR0, F, ACCESS
2B34  0E00     MOVLW 0x0
2B36  22EA     ADDWFC FSR0H, F, ACCESS
2B38  CFEE     MOVFF POSTINC0, __tmp_0
2B3A  F014     NOP
2B3C  CFEF     MOVFF INDF0, 0x15
2B3E  F015     NOP
2B40  5014     MOVF __tmp_0, W, ACCESS
2B42  0107     MOVLB 0x7
2B44  19FA     XORWF 0xFA, W, BANKED
2B46  E102     BNZ 0x2B4C
2B48  5015     MOVF 0x15, W, ACCESS
2B4A  19FB     XORWF 0xFB, W, BANKED
2B4C  E10C     BNZ 0x2B66
300:             {
301:               PIE1bits.TXIE = 0;
2B4E  989D     BCF PIE1, 4, ACCESS
302:               SetEvent(RS_DRV_ID, RS_NEW_MSG);
2B50  0E10     MOVLW 0x10
2B52  6EE6     MOVWF POSTINC1, ACCESS
2B54  0E02     MOVLW 0x2
2B56  6EE6     MOVWF POSTINC1, ACCESS
2B58  EC17     CALL 0x162E, 0
2B5A  F00B     NOP
2B5C  52E5     MOVF POSTDEC1, F, ACCESS
2B5E  52E5     MOVF POSTDEC1, F, ACCESS
303:               TX_ByteNumber = -1;
2B60  0107     MOVLB 0x7
2B62  69FA     SETF 0xFA, BANKED
2B64  69FB     SETF 0xFB, BANKED
304:             }
305:             TX_ByteNumber++;
2B66  0107     MOVLB 0x7
2B68  2BFA     INCF 0xFA, F, BANKED
2B6A  0E00     MOVLW 0x0
2B6C  23FB     ADDWFC 0xFB, F, BANKED
306:             return;
2B6E  D000     BRA 0x2B70
307:           }
2B70  0012     RETURN 0
308:           
309:           /**********************************************************************
310:            * Part of the recepteur interrupt.
311:            *
312:            * @param  void
313:            * @return void 
314:            **********************************************************************/
315:           void RS_RX_INT(void)
316:           {
317:             PIR1bits.RCIF = 0;
2B72  9A9E     BCF PIR1, 5, ACCESS
318:             /* A length is expected */
319:             if (RS_list_head_rcv->length != 0)
2B74  C7EF     MOVFF RS_list_head_rcv, FSR0
2B76  FFE9     NOP
2B78  C7F0     MOVFF 0x7F0, FSR0H
2B7A  FFEA     NOP
2B7C  0E02     MOVLW 0x2
2B7E  26E9     ADDWF FSR0, F, ACCESS
2B80  0E00     MOVLW 0x0
2B82  22EA     ADDWFC FSR0H, F, ACCESS
2B84  50EE     MOVF POSTINC0, W, ACCESS
2B86  10ED     IORWF POSTDEC0, W, ACCESS
2B88  E054     BZ 0x2C32
320:             {
321:               if ((RX_ByteNumber >= 0) && 
2B8A  0107     MOVLB 0x7
2B8C  0E00     MOVLW 0x0
2B8E  5DFC     SUBWF 0xFC, W, BANKED
2B90  0E00     MOVLW 0x0
2B92  59FD     SUBWFB 0xFD, W, BANKED
322:                   (RX_ByteNumber < RS_list_head_rcv->length))
2B94  E324     BNC 0x2BDE
2B96  C7EF     MOVFF RS_list_head_rcv, FSR0
2B98  FFE9     NOP
2B9A  C7F0     MOVFF 0x7F0, FSR0H
2B9C  FFEA     NOP
2B9E  0E02     MOVLW 0x2
2BA0  26E9     ADDWF FSR0, F, ACCESS
2BA2  0E00     MOVLW 0x0
2BA4  22EA     ADDWFC FSR0H, F, ACCESS
2BA6  CFEE     MOVFF POSTINC0, __tmp_0
2BA8  F014     NOP
2BAA  CFEF     MOVFF INDF0, 0x15
2BAC  F015     NOP
2BAE  0107     MOVLB 0x7
2BB0  5014     MOVF __tmp_0, W, ACCESS
2BB2  5DFC     SUBWF 0xFC, W, BANKED
2BB4  5015     MOVF 0x15, W, ACCESS
2BB6  59FD     SUBWFB 0xFD, W, BANKED
2BB8  E212     BC 0x2BDE
323:                 RS_list_head_rcv->data[RX_ByteNumber] = RCREG;
2BBA  C7EF     MOVFF RS_list_head_rcv, FSR0
2BBC  FFE9     NOP
2BBE  C7F0     MOVFF 0x7F0, FSR0H
2BC0  FFEA     NOP
2BC2  0107     MOVLB 0x7
2BC4  0107     MOVLB 0x7
2BC6  51FC     MOVF 0xFC, W, BANKED
2BC8  24EE     ADDWF POSTINC0, W, ACCESS
2BCA  6EE7     MOVWF INDF1, ACCESS
2BCC  0107     MOVLB 0x7
2BCE  0107     MOVLB 0x7
2BD0  51FD     MOVF 0xFD, W, BANKED
2BD2  20EE     ADDWFC POSTINC0, W, ACCESS
2BD4  6EEA     MOVWF FSR0H, ACCESS
2BD6  CFE7     MOVFF INDF1, FSR0
2BD8  FFE9     NOP
2BDA  CFAF     MOVFF RCREG1, INDF0
2BDC  FFEF     NOP
324:               if (RX_ByteNumber == (RS_list_head_rcv->length) - 1)
2BDE  C7EF     MOVFF RS_list_head_rcv, FSR0
2BE0  FFE9     NOP
2BE2  C7F0     MOVFF 0x7F0, FSR0H
2BE4  FFEA     NOP
2BE6  0E02     MOVLW 0x2
2BE8  26E9     ADDWF FSR0, F, ACCESS
2BEA  0E00     MOVLW 0x0
2BEC  22EA     ADDWFC FSR0H, F, ACCESS
2BEE  CFEE     MOVFF POSTINC0, __tmp_0
2BF0  F014     NOP
2BF2  CFEF     MOVFF INDF0, 0x15
2BF4  F015     NOP
2BF6  0614     DECF __tmp_0, F, ACCESS
2BF8  5A15     SUBWFB 0x15, F, ACCESS
2BFA  5014     MOVF __tmp_0, W, ACCESS
2BFC  0107     MOVLB 0x7
2BFE  19FC     XORWF 0xFC, W, BANKED
2C00  E102     BNZ 0x2C06
2C02  5015     MOVF 0x15, W, ACCESS
2C04  19FD     XORWF 0xFD, W, BANKED
2C06  E110     BNZ 0x2C28
325:               {
326:                 SetEvent(RS_list_head_rcv->CallerID, RS_QUEUE_FULL);
2C08  0E20     MOVLW 0x20
2C0A  6EE6     MOVWF POSTINC1, ACCESS
2C0C  C7EF     MOVFF RS_list_head_rcv, FSR0
2C0E  FFE9     NOP
2C10  C7F0     MOVFF 0x7F0, FSR0H
2C12  FFEA     NOP
2C14  0E05     MOVLW 0x5
2C16  50EB     MOVF PLUSW0, W, ACCESS
2C18  6EE6     MOVWF POSTINC1, ACCESS
2C1A  EC17     CALL 0x162E, 0
2C1C  F00B     NOP
2C1E  52E5     MOVF POSTDEC1, F, ACCESS
2C20  52E5     MOVF POSTDEC1, F, ACCESS
327:                 RX_ByteNumber = -1;
2C22  0107     MOVLB 0x7
2C24  69FC     SETF 0xFC, BANKED
2C26  69FD     SETF 0xFD, BANKED
328:               }
329:               RX_ByteNumber++;
2C28  0107     MOVLB 0x7
2C2A  2BFC     INCF 0xFC, F, BANKED
2C2C  0E00     MOVLW 0x0
2C2E  23FD     ADDWFC 0xFD, F, BANKED
330:             }
331:             /* A special character is expected */
332:             else
2C30  D02E     BRA 0x2C8E
333:             {
334:               RS_list_head_rcv->data[RX_ByteNumber] = RCREG;
2C32  C7EF     MOVFF RS_list_head_rcv, FSR0
2C34  FFE9     NOP
2C36  C7F0     MOVFF 0x7F0, FSR0H
2C38  FFEA     NOP
2C3A  0107     MOVLB 0x7
2C3C  0107     MOVLB 0x7
2C3E  51FC     MOVF 0xFC, W, BANKED
2C40  24EE     ADDWF POSTINC0, W, ACCESS
2C42  6EE7     MOVWF INDF1, ACCESS
2C44  0107     MOVLB 0x7
2C46  0107     MOVLB 0x7
2C48  51FD     MOVF 0xFD, W, BANKED
2C4A  20EE     ADDWFC POSTINC0, W, ACCESS
2C4C  6EEA     MOVWF FSR0H, ACCESS
2C4E  CFE7     MOVFF INDF1, FSR0
2C50  FFE9     NOP
2C52  CFAF     MOVFF RCREG1, INDF0
2C54  FFEF     NOP
335:               if (RS_list_head_rcv->pattern == RCREG)
2C56  C7EF     MOVFF RS_list_head_rcv, FSR0
2C58  FFE9     NOP
2C5A  C7F0     MOVFF 0x7F0, FSR0H
2C5C  FFEA     NOP
2C5E  0E04     MOVLW 0x4
2C60  50EB     MOVF PLUSW0, W, ACCESS
2C62  5CAF     SUBWF RCREG1, W, ACCESS
2C64  E110     BNZ 0x2C86
336:               {
337:                 SetEvent(RS_list_head_rcv->CallerID, RS_QUEUE_FULL);
2C66  0E20     MOVLW 0x20
2C68  6EE6     MOVWF POSTINC1, ACCESS
2C6A  C7EF     MOVFF RS_list_head_rcv, FSR0
2C6C  FFE9     NOP
2C6E  C7F0     MOVFF 0x7F0, FSR0H
2C70  FFEA     NOP
2C72  0E05     MOVLW 0x5
2C74  50EB     MOVF PLUSW0, W, ACCESS
2C76  6EE6     MOVWF POSTINC1, ACCESS
2C78  EC17     CALL 0x162E, 0
2C7A  F00B     NOP
2C7C  52E5     MOVF POSTDEC1, F, ACCESS
2C7E  52E5     MOVF POSTDEC1, F, ACCESS
338:                 RX_ByteNumber = -1;
2C80  0107     MOVLB 0x7
2C82  69FC     SETF 0xFC, BANKED
2C84  69FD     SETF 0xFD, BANKED
339:               }
340:               RX_ByteNumber++;
2C86  0107     MOVLB 0x7
2C88  2BFC     INCF 0xFC, F, BANKED
2C8A  0E00     MOVLW 0x0
2C8C  23FD     ADDWFC 0xFD, F, BANKED
341:             }
342:             return;
2C8E  D000     BRA 0x2C90
343:           }
2C90  0012     RETURN 0
344:           
345:           /* End of file : drv_rs.c */
---  F:/PICOS18/TiltDetector/drv_i2c.c  -----------------------------------------------------------------
1:             /**********************************************************************/
2:             /*                                                                    */
3:             /* File name: drv_i2c.c                                               */
4:             /*                                                                    */
5:             /* Since:     2004-Aug-10                                             */
6:             /*                                                                    */
7:             /* Version:   PICos18 v2.00                                           */
8:             /*            Copyright (C) 2003, 2004 Pragmatec.                     */
9:             /*            I2C driver v1.04                                        */
10:            /*                                                                    */
11:            /* Author:    DEVINE, Dan [DD] (ddevine@nwi-online.com) 			  */
12:            /*			  ROZIER Bertrand [RZR] bertrand.rozier@pragmatec.net     */
13:            /*																	  */
14:            /* Purpose:   I2C communications task, allowing other client          */
15:            /*            tasks to share operation of the PIC18 MSSP module.      */
16:            /*                                                                    */
17:            /* Distribution: This file is part of PICos18.                        */
18:            /*            PICos18 is free software; you can redistribute it       */
19:            /*            and/or modify it under the terms of the GNU General     */
20:            /*            Public License as published by the Free Software        */
21:            /*            Foundation; either version 2, or (at your option)       */
22:            /*            any later version.                                      */
23:            /*                                                                    */
24:            /*            PICos18 is distributed in the hope that it will be      */
25:            /*            useful, but WITHOUT ANY WARRANTY; without even the      */
26:            /*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
27:            /*            PARTICULAR PURPOSE.  See the GNU General Public         */
28:            /*            License for more details.                               */
29:            /*                                                                    */
30:            /*            You should have received a copy of the GNU General      */
31:            /*            Public License along with gpsim; see the file           */
32:            /*            COPYING.txt. If not, write to the Free Software         */
33:            /*            Foundation, 59 Temple Place - Suite 330,                */
34:            /*            Boston, MA 02111-1307, USA.                             */
35:            /*                                                                    */
36:            /*          > A special exception to the GPL can be applied should    */
37:            /*            you wish to distribute a combined work that includes    */
38:            /*            PICos18, without being obliged to provide the source    */
39:            /*            code for any proprietary components.                    */
40:            /*                                                                    */
41:            /* History:                                                           */
42:            /*   2004/09/10  [DD]  Create this file.                              */
43:            /*	 2004/11/23	 [RZR] Update for PICos18 V2 & Add TimeOut			  */
44:            /*	 2004/11/23	 [XM]  Added Suspend(Resume)OSInterrupts() calls in   */
45:            /*                     I2C_deqMsg function.                           */
46:            /*                                                                    */
47:            /**********************************************************************/
48:            
49:            
50:            #include "drv_i2c.h"
51:            
52:            
53:            /**********************************************************************
54:             *      Forward declarations of local functions not for public
55:             *
56:             *********************************************************************/
57:            
58:            
59:            I2C_message_tRef	I2C_deqMsg(void); 
60:            
61:            I2C_message_tRef	I2C_list_head;		//	Start of message queue
62:            I2C_message_tRef	I2C_current_message;//	Current message
63:            
64:            //#pragma udata bank5=0x850
65:            unsigned char		I2C_list_count;		//	Number of items currently in queue
66:            unsigned char 		I2C_bus_state;		//	Current/next I2C state/action
67:            
68:            unsigned char		*p_data;			//	Pointer into message data
69:            unsigned char		I2C_byte_count;		//	Counts from 0 to 
70:            										//	current_message.num_bytes
71:            
72:            
73:            /**********************************************************************
74:             *
75:             *							I2C DRIVER
76:             *
77:             *********************************************************************/
78:            TASK(I2C_Drv)
2000  CFD9     MOVFF FSR2, POSTINC1
2002  FFE6     NOP
2004  CFE1     MOVFF FSR1, FSR2
2006  FFD9     NOP
2008  52E6     MOVF POSTINC1, F, ACCESS
79:            {
80:            	EventMaskType  Mask_event;
81:            	
82:            	// Set up the I2C port
83:            	TRISC |= 0b00011000;
200A  0E18     MOVLW 0x18
200C  1294     IORWF TRISC, F, ACCESS
84:            	
85:            	PIE1  |= 0b00001000;
200E  869D     BSF PIE1, 3, ACCESS
86:            	PIE2  |= 0b00001000;
2010  86A0     BSF PIE2, 3, ACCESS
87:            	
88:            	SSPCON1 = 0b00101000;
2012  0E28     MOVLW 0x28
2014  6EC6     MOVWF SSP1CON1, ACCESS
89:            	SSPADD= 0x63;           // Assuming 40MHz speed - 100KHz
2016  0E63     MOVLW 0x63
2018  6EC8     MOVWF SSP1ADD, ACCESS
90:            	//SSPADD= 0x27;         // Assuming 16MHz speed - 100KHz
91:            	//SSPADD  = 0x09;       // Assuming 04MHz speed - 100KHz
92:            	SSPSTAT = 0b10000000;   // 100Khz
201A  0E80     MOVLW 0x80
201C  6EC7     MOVWF SSP1STAT, ACCESS
93:            	PIR2bits.BCLIF = 0;
201E  96A1     BCF PIR2, 3, ACCESS
94:            	
95:            	// Initialize Task/module variables
96:            	I2C_list_count = 0;
2020  0107     MOVLB 0x7
2022  6BE5     CLRF 0xE5, BANKED
97:            	I2C_list_head  = NULL;
2024  0107     MOVLB 0x7
2026  6BE1     CLRF 0xE1, BANKED
2028  6BE2     CLRF 0xE2, BANKED
98:            	
99:            	//	Initiate a stop condition to clear bus
100:           	I2C_bus_state   = BUS_STOP;
202A  0107     MOVLB 0x7
202C  0E03     MOVLW 0x3
202E  6FE6     MOVWF 0xE6, BANKED
101:           	SSPCON2bits.PEN = 1;
2030  84C5     BSF SSP1CON2, 2, ACCESS
102:           
103:           	while (1)	
2250  D6F0     BRA 0x2032
104:           	{	// Wait for another task to post 1 or more messages to send
105:           		WaitEvent(I2C_NEW_MSG);
2032  0E02     MOVLW 0x2
2034  6EE6     MOVWF POSTINC1, ACCESS
2036  EC74     CALL 0x18E8, 0
2038  F00C     NOP
203A  52E5     MOVF POSTDEC1, F, ACCESS
106:           		ClearEvent(0xFF); //Clear all Event
203C  68E6     SETF POSTINC1, ACCESS
203E  ECAA     CALL 0x1754, 0
2040  F00B     NOP
2042  52E5     MOVF POSTDEC1, F, ACCESS
107:           		while (I2C_list_count > 0)
2044  0107     MOVLB 0x7
2046  51E5     MOVF 0xE5, W, BANKED
2048  0800     SUBLW 0x0
204A  E301     BNC 0x204E
204C  D100     BRA 0x224E
224C  D6FB     BRA 0x2044
108:           		{
109:           			I2C_current_message = I2C_deqMsg();
204E  D977     RCALL I2C_deqMsg
2050  CFF3     MOVFF PROD, I2C_current_message
2052  F7E3     NOP
2054  CFF4     MOVFF PRODH, 0x7E4
2056  F7E4     NOP
110:           			I2C_byte_count = I2C_current_message->num_bytes;
2058  C7E3     MOVFF I2C_current_message, FSR0
205A  FFE9     NOP
205C  C7E4     MOVFF 0x7E4, FSR0H
205E  FFEA     NOP
2060  0E05     MOVLW 0x5
2062  50EB     MOVF PLUSW0, W, ACCESS
2064  0107     MOVLB 0x7
2066  6FE9     MOVWF 0xE9, BANKED
111:           			p_data = I2C_current_message->ram_data;
2068  C7E3     MOVFF I2C_current_message, FSR0
206A  FFE9     NOP
206C  C7E4     MOVFF 0x7E4, FSR0H
206E  FFEA     NOP
2070  0E03     MOVLW 0x3
2072  26E9     ADDWF FSR0, F, ACCESS
2074  0E00     MOVLW 0x0
2076  22EA     ADDWFC FSR0H, F, ACCESS
2078  CFEE     MOVFF POSTINC0, p_data
207A  F7E7     NOP
207C  CFED     MOVFF POSTDEC0, 0x7E8
207E  F7E8     NOP
112:           			// Specific settings for SMBus
113:           			if (I2C_current_message->flags.SMBus == 1)
2080  C7E3     MOVFF I2C_current_message, FSR0
2082  FFE9     NOP
2084  C7E4     MOVFF 0x7E4, FSR0H
2086  FFEA     NOP
2088  0E0A     MOVLW 0xA
208A  26E9     ADDWF FSR0, F, ACCESS
208C  0E00     MOVLW 0x0
208E  22EA     ADDWFC FSR0H, F, ACCESS
2090  50EF     MOVF INDF0, W, ACCESS
2092  0B04     ANDLW 0x4
2094  E002     BZ 0x209A
114:           			{
115:           				// Enable SMBus specific inputs
116:           				SSPSTATbits.CKE = 1; 
2096  8CC7     BSF SSP1STAT, 6, ACCESS
117:           			}
118:           			else
2098  D001     BRA 0x209C
119:           			{
120:           				// Disble SMBus specific inputs
121:           				SSPSTATbits.CKE = 0;
209A  9CC7     BCF SSP1STAT, 6, ACCESS
122:           			}
123:           			// Set the timeout at 30ms//10ms
124:           			CancelAlarm(I2C_TIMEOUT_ALARM);
209C  0E04     MOVLW 0x4
209E  6EE6     MOVWF POSTINC1, ACCESS
20A0  ECBD     CALL 0x57A, 0
20A2  F002     NOP
20A4  52E5     MOVF POSTDEC1, F, ACCESS
125:           			SetRelAlarm(I2C_TIMEOUT_ALARM, 30, 0);
20A6  0E00     MOVLW 0x0
20A8  6EE6     MOVWF POSTINC1, ACCESS
20AA  6AE6     CLRF POSTINC1, ACCESS
20AC  0E1E     MOVLW 0x1E
20AE  6EE6     MOVWF POSTINC1, ACCESS
20B0  6AE6     CLRF POSTINC1, ACCESS
20B2  0E04     MOVLW 0x4
20B4  6EE6     MOVWF POSTINC1, ACCESS
20B6  ECA3     CALL 0x146, 0
20B8  F000     NOP
20BA  6E14     MOVWF __tmp_0, ACCESS
20BC  0E05     MOVLW 0x5
20BE  5EE1     SUBWF FSR1, F, ACCESS
20C0  5014     MOVF __tmp_0, W, ACCESS
126:           			// Start I2C transfert
127:           			I2C_bus_state = BUS_START;
20C2  0107     MOVLB 0x7
20C4  0E01     MOVLW 0x1
20C6  6FE6     MOVWF 0xE6, BANKED
128:           			SSPCON2bits.SEN = 1;
20C8  80C5     BSF SSP1CON2, 0, ACCESS
129:           			// Wait for transfert result
130:           			WaitEvent(TIMEOUT_EVENT | BUSERROR_EVENT | IDLE_EVENT);
20CA  0E18     MOVLW 0x18
20CC  6EE6     MOVWF POSTINC1, ACCESS
20CE  EC74     CALL 0x18E8, 0
20D0  F00C     NOP
20D2  52E5     MOVF POSTDEC1, F, ACCESS
131:           			GetEvent(I2C_DRV_ID, &Mask_event);
20D4  CFD9     MOVFF FSR2, POSTINC1
20D6  FFE6     NOP
20D8  CFDA     MOVFF FSR2H, POSTINC1
20DA  FFE6     NOP
20DC  0E03     MOVLW 0x3
20DE  6EE6     MOVWF POSTINC1, ACCESS
20E0  EC11     CALL 0x1822, 0
20E2  F00C     NOP
20E4  52E5     MOVF POSTDEC1, F, ACCESS
20E6  52E5     MOVF POSTDEC1, F, ACCESS
20E8  52E5     MOVF POSTDEC1, F, ACCESS
132:           			// Timeout occured (10 ms)
133:           			if (Mask_event & TIMEOUT_EVENT)
20EA  A6DF     BTFSS INDF2, 3, ACCESS
20EC  D030     BRA 0x214E
134:               		{
135:           				ClearEvent(TIMEOUT_EVENT);
20EE  0E08     MOVLW 0x8
20F0  6EE6     MOVWF POSTINC1, ACCESS
20F2  ECAA     CALL 0x1754, 0
20F4  F00B     NOP
20F6  52E5     MOVF POSTDEC1, F, ACCESS
136:           				I2C_current_message->error = ERR_I2C_TIMEOUT;
20F8  C7E3     MOVFF I2C_current_message, FSR0
20FA  FFE9     NOP
20FC  C7E4     MOVFF 0x7E4, FSR0H
20FE  FFEA     NOP
2100  0E06     MOVLW 0x6
2102  26E9     ADDWF FSR0, F, ACCESS
2104  0E00     MOVLW 0x0
2106  22EA     ADDWFC FSR0H, F, ACCESS
2108  0EE0     MOVLW 0xE0
210A  14EF     ANDWF INDF0, W, ACCESS
210C  0910     IORLW 0x10
210E  6EEF     MOVWF INDF0, ACCESS
137:           				I2C_current_message->flags.busy = 0;
2110  C7E3     MOVFF I2C_current_message, FSR0
2112  FFE9     NOP
2114  C7E4     MOVFF 0x7E4, FSR0H
2116  FFEA     NOP
2118  0E0A     MOVLW 0xA
211A  26E9     ADDWF FSR0, F, ACCESS
211C  0E00     MOVLW 0x0
211E  22EA     ADDWFC FSR0H, F, ACCESS
2120  9AEF     BCF INDF0, 5, ACCESS
138:           				I2C_current_message->flags.error = 1;
2122  C7E3     MOVFF I2C_current_message, FSR0
2124  FFE9     NOP
2126  C7E4     MOVFF 0x7E4, FSR0H
2128  FFEA     NOP
212A  0E0A     MOVLW 0xA
212C  26E9     ADDWF FSR0, F, ACCESS
212E  0E00     MOVLW 0x0
2130  22EA     ADDWFC FSR0H, F, ACCESS
2132  88EF     BSF INDF0, 4, ACCESS
139:           				SetEvent(I2C_current_message->CallerID,I2C_QUEUE_EMPTY);
2134  0E20     MOVLW 0x20
2136  6EE6     MOVWF POSTINC1, ACCESS
2138  C7E3     MOVFF I2C_current_message, FSR0
213A  FFE9     NOP
213C  C7E4     MOVFF 0x7E4, FSR0H
213E  FFEA     NOP
2140  0E07     MOVLW 0x7
2142  50EB     MOVF PLUSW0, W, ACCESS
2144  6EE6     MOVWF POSTINC1, ACCESS
2146  EC17     CALL 0x162E, 0
2148  F00B     NOP
214A  52E5     MOVF POSTDEC1, F, ACCESS
214C  52E5     MOVF POSTDEC1, F, ACCESS
140:           			}
141:           			// BUS ERROR occured
142:           			if (Mask_event & BUSERROR_EVENT)
214E  A6DF     BTFSS INDF2, 3, ACCESS
2150  D064     BRA 0x221A
143:               		{
144:           				ClearEvent(BUSERROR_EVENT);
2152  0E08     MOVLW 0x8
2154  6EE6     MOVWF POSTINC1, ACCESS
2156  ECAA     CALL 0x1754, 0
2158  F00B     NOP
215A  52E5     MOVF POSTDEC1, F, ACCESS
145:           				// If the automatic retry is used
146:           				if (I2C_current_message->retry_counter != 0)
215C  C7E3     MOVFF I2C_current_message, FSR0
215E  FFE9     NOP
2160  C7E4     MOVFF 0x7E4, FSR0H
2162  FFEA     NOP
2164  0E06     MOVLW 0x6
2166  26E9     ADDWF FSR0, F, ACCESS
2168  0E00     MOVLW 0x0
216A  22EA     ADDWFC FSR0H, F, ACCESS
216C  50EF     MOVF INDF0, W, ACCESS
216E  0BE0     ANDLW 0xE0
2170  42E8     RRNCF WREG, F, ACCESS
2172  42E8     RRNCF WREG, F, ACCESS
2174  42E8     RRNCF WREG, F, ACCESS
2176  42E8     RRNCF WREG, F, ACCESS
2178  42E8     RRNCF WREG, F, ACCESS
217A  0900     IORLW 0x0
217C  E02F     BZ 0x21DC
147:           				{
148:           					I2C_current_message->retry_counter--;
217E  C7E3     MOVFF I2C_current_message, FSR0
2180  FFE9     NOP
2182  C7E4     MOVFF 0x7E4, FSR0H
2184  FFEA     NOP
2186  0E06     MOVLW 0x6
2188  26E9     ADDWF FSR0, F, ACCESS
218A  0E00     MOVLW 0x0
218C  22EA     ADDWFC FSR0H, F, ACCESS
218E  50EF     MOVF INDF0, W, ACCESS
2190  0BE0     ANDLW 0xE0
2192  42E8     RRNCF WREG, F, ACCESS
2194  42E8     RRNCF WREG, F, ACCESS
2196  42E8     RRNCF WREG, F, ACCESS
2198  42E8     RRNCF WREG, F, ACCESS
219A  42E8     RRNCF WREG, F, ACCESS
219C  06E8     DECF WREG, F, ACCESS
219E  6EF3     MOVWF PROD, ACCESS
21A0  50F3     MOVF PROD, W, ACCESS
21A2  0B07     ANDLW 0x7
21A4  6EF3     MOVWF PROD, ACCESS
21A6  6EF4     MOVWF PRODH, ACCESS
21A8  46F3     RLNCF PROD, F, ACCESS
21AA  46F3     RLNCF PROD, F, ACCESS
21AC  46F3     RLNCF PROD, F, ACCESS
21AE  46F3     RLNCF PROD, F, ACCESS
21B0  46F3     RLNCF PROD, F, ACCESS
21B2  0E1F     MOVLW 0x1F
21B4  14EF     ANDWF INDF0, W, ACCESS
21B6  10F3     IORWF PROD, W, ACCESS
21B8  6EEF     MOVWF INDF0, ACCESS
149:           					I2C_current_message->flags.busy = 1;
21BA  C7E3     MOVFF I2C_current_message, FSR0
21BC  FFE9     NOP
21BE  C7E4     MOVFF 0x7E4, FSR0H
21C0  FFEA     NOP
21C2  0E0A     MOVLW 0xA
21C4  26E9     ADDWF FSR0, F, ACCESS
21C6  0E00     MOVLW 0x0
21C8  22EA     ADDWFC FSR0H, F, ACCESS
21CA  8AEF     BSF INDF0, 5, ACCESS
150:           					I2C_enqMsg(I2C_current_message);
21CC  C7E3     MOVFF I2C_current_message, POSTINC1
21CE  FFE6     NOP
21D0  C7E4     MOVFF 0x7E4, POSTINC1
21D2  FFE6     NOP
21D4  D843     RCALL I2C_enqMsg
21D6  52E5     MOVF POSTDEC1, F, ACCESS
21D8  52E5     MOVF POSTDEC1, F, ACCESS
151:           				}
152:           				else 
21DA  D01F     BRA 0x221A
153:           				{
154:           					I2C_current_message->flags.busy = 0;
21DC  C7E3     MOVFF I2C_current_message, FSR0
21DE  FFE9     NOP
21E0  C7E4     MOVFF 0x7E4, FSR0H
21E2  FFEA     NOP
21E4  0E0A     MOVLW 0xA
21E6  26E9     ADDWF FSR0, F, ACCESS
21E8  0E00     MOVLW 0x0
21EA  22EA     ADDWFC FSR0H, F, ACCESS
21EC  9AEF     BCF INDF0, 5, ACCESS
155:           					I2C_current_message->flags.error = 1;
21EE  C7E3     MOVFF I2C_current_message, FSR0
21F0  FFE9     NOP
21F2  C7E4     MOVFF 0x7E4, FSR0H
21F4  FFEA     NOP
21F6  0E0A     MOVLW 0xA
21F8  26E9     ADDWF FSR0, F, ACCESS
21FA  0E00     MOVLW 0x0
21FC  22EA     ADDWFC FSR0H, F, ACCESS
21FE  88EF     BSF INDF0, 4, ACCESS
156:           					SetEvent(I2C_current_message->CallerID,I2C_QUEUE_EMPTY);
2200  0E20     MOVLW 0x20
2202  6EE6     MOVWF POSTINC1, ACCESS
2204  C7E3     MOVFF I2C_current_message, FSR0
2206  FFE9     NOP
2208  C7E4     MOVFF 0x7E4, FSR0H
220A  FFEA     NOP
220C  0E07     MOVLW 0x7
220E  50EB     MOVF PLUSW0, W, ACCESS
2210  6EE6     MOVWF POSTINC1, ACCESS
2212  EC17     CALL 0x162E, 0
2214  F00B     NOP
2216  52E5     MOVF POSTDEC1, F, ACCESS
2218  52E5     MOVF POSTDEC1, F, ACCESS
157:           				}
158:           			}
159:           			if (Mask_event & IDLE_EVENT)
221A  A8DF     BTFSS INDF2, 4, ACCESS
221C  D017     BRA 0x224C
160:              			{
161:           				// Message sent successfully
162:           				ClearEvent(IDLE_EVENT);
221E  0E10     MOVLW 0x10
2220  6EE6     MOVWF POSTINC1, ACCESS
2222  ECAA     CALL 0x1754, 0
2224  F00B     NOP
2226  52E5     MOVF POSTDEC1, F, ACCESS
163:           				// Disabled TIMEOUT counter
164:           				CancelAlarm(I2C_TIMEOUT_ALARM);
2228  0E04     MOVLW 0x4
222A  6EE6     MOVWF POSTINC1, ACCESS
222C  ECBD     CALL 0x57A, 0
222E  F002     NOP
2230  52E5     MOVF POSTDEC1, F, ACCESS
165:           				SetEvent(I2C_current_message->CallerID,I2C_QUEUE_EMPTY);
2232  0E20     MOVLW 0x20
2234  6EE6     MOVWF POSTINC1, ACCESS
2236  C7E3     MOVFF I2C_current_message, FSR0
2238  FFE9     NOP
223A  C7E4     MOVFF 0x7E4, FSR0H
223C  FFEA     NOP
223E  0E07     MOVLW 0x7
2240  50EB     MOVF PLUSW0, W, ACCESS
2242  6EE6     MOVWF POSTINC1, ACCESS
2244  EC17     CALL 0x162E, 0
2246  F00B     NOP
2248  52E5     MOVF POSTDEC1, F, ACCESS
224A  52E5     MOVF POSTDEC1, F, ACCESS
166:           			}
167:           		}// End of list_count_loop
168:           		Nop();				
224E  0000     NOP
169:           	} // End of the infinte loop
170:           }// End of task
2252  52E5     MOVF POSTDEC1, F, ACCESS
2254  52E5     MOVF POSTDEC1, F, ACCESS
2256  CFE7     MOVFF INDF1, FSR2
2258  FFD9     NOP
225A  0012     RETURN 0
171:            
172:           
173:           /**********************************************************************
174:            *
175:            *	Enqueue a client packet object into the I2C task queue.
176:            *
177:            *	Once placed in queue, client must not modify the data
178:            *	otherwise unpredictable results. To safely change the object,
179:            *	dequeue, modify, re-enqueue.
180:            *
181:            *	Returns 1 if successfull, 0 if message could not be enqueued
182:            **********************************************************************/
183:           unsigned char I2C_enqMsg(I2C_message_tRef toEnqueue)
225C  CFD9     MOVFF FSR2, POSTINC1
225E  FFE6     NOP
2260  CFE1     MOVFF FSR1, FSR2
2262  FFD9     NOP
2264  0E02     MOVLW 0x2
2266  26E1     ADDWF FSR1, F, ACCESS
184:           {
185:             I2C_message_tRef I2C_list_itor;
186:           
187:             if (toEnqueue != NULL)
2268  50D9     MOVF FSR2, W, ACCESS
226A  0FFD     ADDLW 0xFD
226C  6EE9     MOVWF FSR0, ACCESS
226E  0EFF     MOVLW 0xFF
2270  20DA     ADDWFC FSR2H, W, ACCESS
2272  6EEA     MOVWF FSR0H, ACCESS
2274  50EE     MOVF POSTINC0, W, ACCESS
2276  10ED     IORWF POSTDEC0, W, ACCESS
2278  E054     BZ 0x2322
188:             {
189:               SuspendOSInterrupts();
227A  EC8E     CALL 0x11C, 0
227C  F000     NOP
190:               if (I2C_list_head == NULL)
227E  0107     MOVLB 0x7
2280  51E1     MOVF 0xE1, W, BANKED
2282  11E2     IORWF 0xE2, W, BANKED
2284  E107     BNZ 0x2294
191:                 I2C_list_head = toEnqueue;
2286  0EFD     MOVLW 0xFD
2288  CFDB     MOVFF PLUSW2, I2C_list_head
228A  F7E1     NOP
228C  0EFE     MOVLW 0xFE
228E  CFDB     MOVFF PLUSW2, 0x7E2
2290  F7E2     NOP
192:               else
2292  D02A     BRA 0x22E8
193:               {
194:                 I2C_list_itor = I2C_list_head;
2294  C7E1     MOVFF I2C_list_head, POSTINC2
2296  FFDE     NOP
2298  C7E2     MOVFF 0x7E2, POSTDEC2
229A  FFDD     NOP
195:                 while (I2C_list_itor->next != NULL)
229C  CFDE     MOVFF POSTINC2, FSR0
229E  FFE9     NOP
22A0  CFDD     MOVFF POSTDEC2, FSR0H
22A2  FFEA     NOP
22A4  0E08     MOVLW 0x8
22A6  26E9     ADDWF FSR0, F, ACCESS
22A8  0E00     MOVLW 0x0
22AA  22EA     ADDWFC FSR0H, F, ACCESS
22AC  50EE     MOVF POSTINC0, W, ACCESS
22AE  10ED     IORWF POSTDEC0, W, ACCESS
22B0  E00D     BZ 0x22CC
22CA  D7E8     BRA 0x229C
196:                   I2C_list_itor = I2C_list_itor->next;
22B2  CFDE     MOVFF POSTINC2, FSR0
22B4  FFE9     NOP
22B6  CFDD     MOVFF POSTDEC2, FSR0H
22B8  FFEA     NOP
22BA  0E08     MOVLW 0x8
22BC  26E9     ADDWF FSR0, F, ACCESS
22BE  0E00     MOVLW 0x0
22C0  22EA     ADDWFC FSR0H, F, ACCESS
22C2  CFEE     MOVFF POSTINC0, POSTINC2
22C4  FFDE     NOP
22C6  CFED     MOVFF POSTDEC0, POSTDEC2
22C8  FFDD     NOP
197:                 I2C_list_itor->next = toEnqueue;
22CC  CFDE     MOVFF POSTINC2, FSR0
22CE  FFE9     NOP
22D0  CFDD     MOVFF POSTDEC2, FSR0H
22D2  FFEA     NOP
22D4  0E08     MOVLW 0x8
22D6  26E9     ADDWF FSR0, F, ACCESS
22D8  0E00     MOVLW 0x0
22DA  22EA     ADDWFC FSR0H, F, ACCESS
22DC  0EFD     MOVLW 0xFD
22DE  CFDB     MOVFF PLUSW2, POSTINC0
22E0  FFEE     NOP
22E2  0EFE     MOVLW 0xFE
22E4  CFDB     MOVFF PLUSW2, POSTDEC0
22E6  FFED     NOP
198:               }
199:               toEnqueue->next     = NULL;
22E8  0EFD     MOVLW 0xFD
22EA  CFDB     MOVFF PLUSW2, FSR0
22EC  FFE9     NOP
22EE  0EFE     MOVLW 0xFE
22F0  CFDB     MOVFF PLUSW2, FSR0H
22F2  FFEA     NOP
22F4  0E08     MOVLW 0x8
22F6  6AEB     CLRF PLUSW0, ACCESS
22F8  0E09     MOVLW 0x9
22FA  6AEB     CLRF PLUSW0, ACCESS
200:               toEnqueue->CallerID = id_tsk_run;
22FC  0EFD     MOVLW 0xFD
22FE  CFDB     MOVFF PLUSW2, FSR0
2300  FFE9     NOP
2302  0EFE     MOVLW 0xFE
2304  CFDB     MOVFF PLUSW2, FSR0H
2306  FFEA     NOP
2308  0E07     MOVLW 0x7
230A  26E9     ADDWF FSR0, F, ACCESS
230C  0E00     MOVLW 0x0
230E  22EA     ADDWFC FSR0H, F, ACCESS
2310  C06D     MOVFF id_tsk_run, INDF0
2312  FFEF     NOP
201:               I2C_list_count++;
2314  0107     MOVLB 0x7
2316  2BE5     INCF 0xE5, F, BANKED
202:               ResumeOSInterrupts();
2318  EC8C     CALL 0x118, 0
231A  F000     NOP
203:               return 1;
231C  0E01     MOVLW 0x1
231E  D003     BRA 0x2326
204:             }
205:             else
2320  D002     BRA 0x2326
206:               return 0;
2322  0E00     MOVLW 0x0
2324  D000     BRA 0x2326
207:           }
2326  6E14     MOVWF __tmp_0, ACCESS
2328  0E02     MOVLW 0x2
232A  5CE1     SUBWF FSR1, W, ACCESS
232C  E202     BC 0x2332
232E  6AE1     CLRF FSR1, ACCESS
2330  52E5     MOVF POSTDEC1, F, ACCESS
2332  6EE1     MOVWF FSR1, ACCESS
2334  5014     MOVF __tmp_0, W, ACCESS
2336  52E5     MOVF POSTDEC1, F, ACCESS
2338  CFE7     MOVFF INDF1, FSR2
233A  FFD9     NOP
233C  0012     RETURN 0
208:           
209:           /**********************************************************************
210:            *
211:            *	Dequeue a client message from the I2c task queue.
212:            *
213:            *
214:            *********************************************************************/
215:           I2C_message_tRef I2C_deqMsg(void)
233E  CFD9     MOVFF FSR2, POSTINC1
2340  FFE6     NOP
2342  CFE1     MOVFF FSR1, FSR2
2344  FFD9     NOP
2346  0E02     MOVLW 0x2
2348  26E1     ADDWF FSR1, F, ACCESS
216:           {
217:             I2C_message_tRef I2C_list_itor;
218:           
219:             SuspendOSInterrupts();
234A  EC8E     CALL 0x11C, 0
234C  F000     NOP
220:             I2C_list_itor = NULL;
234E  6ADE     CLRF POSTINC2, ACCESS
2350  6ADD     CLRF POSTDEC2, ACCESS
221:             if (I2C_list_head != NULL)
2352  0107     MOVLB 0x7
2354  51E1     MOVF 0xE1, W, BANKED
2356  11E2     IORWF 0xE2, W, BANKED
2358  E012     BZ 0x237E
222:             {
223:               I2C_list_itor = I2C_list_head;
235A  C7E1     MOVFF I2C_list_head, POSTINC2
235C  FFDE     NOP
235E  C7E2     MOVFF 0x7E2, POSTDEC2
2360  FFDD     NOP
224:               I2C_list_head = I2C_list_head->next;
2362  C7E1     MOVFF I2C_list_head, FSR0
2364  FFE9     NOP
2366  C7E2     MOVFF 0x7E2, FSR0H
2368  FFEA     NOP
236A  0E08     MOVLW 0x8
236C  26E9     ADDWF FSR0, F, ACCESS
236E  0E00     MOVLW 0x0
2370  22EA     ADDWFC FSR0H, F, ACCESS
2372  CFEE     MOVFF POSTINC0, I2C_list_head
2374  F7E1     NOP
2376  CFED     MOVFF POSTDEC0, 0x7E2
2378  F7E2     NOP
225:               I2C_list_count--;
237A  0107     MOVLB 0x7
237C  07E5     DECF 0xE5, F, BANKED
226:             }
227:             ResumeOSInterrupts();
237E  EC8C     CALL 0x118, 0
2380  F000     NOP
228:             SetEvent(I2C_DRV_ID, I2C_NEW_MSG);
2382  0E02     MOVLW 0x2
2384  6EE6     MOVWF POSTINC1, ACCESS
2386  0E03     MOVLW 0x3
2388  6EE6     MOVWF POSTINC1, ACCESS
238A  EC17     CALL 0x162E, 0
238C  F00B     NOP
238E  52E5     MOVF POSTDEC1, F, ACCESS
2390  52E5     MOVF POSTDEC1, F, ACCESS
229:             return I2C_list_itor;
2392  CFDE     MOVFF POSTINC2, __tmp_0
2394  F014     NOP
2396  CFDD     MOVFF POSTDEC2, 0x15
2398  F015     NOP
239A  C014     MOVFF __tmp_0, PROD
239C  FFF3     NOP
239E  C015     MOVFF 0x15, PRODH
23A0  FFF4     NOP
230:           } 
23A2  0E02     MOVLW 0x2
23A4  5CE1     SUBWF FSR1, W, ACCESS
23A6  E203     BC 0x23AE
23A8  D000     BRA 0x23AA
23AA  6AE1     CLRF FSR1, ACCESS
23AC  52E5     MOVF POSTDEC1, F, ACCESS
23AE  6EE1     MOVWF FSR1, ACCESS
23B0  52E5     MOVF POSTDEC1, F, ACCESS
23B2  CFE7     MOVFF INDF1, FSR2
23B4  FFD9     NOP
23B6  0012     RETURN 0
231:           
232:           
233:           /**********************************************************************
234:            *
235:            *			I2C Interrupt Service Routine
236:            * 
237:            *			Operates as state machine with case statements
238:            *			while interrupt handler is large as whole, only
239:            *			small ammount of code should be executed at any
240:            *			one time
241:            *
242:            *			The I2C_bus_state when entering the switch statement relates
243:            *			to what event was called for prior to the interrupt occuring.
244:            *			example:set I2C_bus_state to "stop", enable stop bit and wait
245:            *			for interrupt to return here in (hopefully) stopped condition
246:            *			after completion of the event.
247:            *		
248:            **********************************************************************/
249:           void I2C_INT (void)
250:           {
251:             PIR1bits.SSPIF = 0;
23B8  969E     BCF PIR1, 3, ACCESS
252:            // PIR2bits.BCLIF = 0;// ajout personnel
253:           //  if(STKPTR>PtrMax)
254:           //	while(1);
255:             switch (I2C_bus_state)
23BA  0107     MOVLB 0x7
23BC  51E6     MOVF 0xE6, W, BANKED
23BE  0A0B     XORLW 0xB
23C0  E101     BNZ 0x23C4
23C2  D113     BRA 0x25EA
23C4  0A08     XORLW 0x8
23C6  E101     BNZ 0x23CA
23C8  D104     BRA 0x25D2
23CA  0A07     XORLW 0x7
23CC  E101     BNZ 0x23D0
23CE  D0F4     BRA 0x25B8
23D0  0A02     XORLW 0x2
23D2  E101     BNZ 0x23D6
23D4  D0DA     BRA 0x258A
23D6  0A01     XORLW 0x1
23D8  E101     BNZ 0x23DC
23DA  D0C5     BRA 0x2566
23DC  0A05     XORLW 0x5
23DE  E101     BNZ 0x23E2
23E0  D0B8     BRA 0x2552
23E2  0A0B     XORLW 0xB
23E4  E101     BNZ 0x23E8
23E6  D080     BRA 0x24E8
23E8  0A03     XORLW 0x3
23EA  E05A     BZ 0x24A0
23EC  0A02     XORLW 0x2
23EE  E01C     BZ 0x2428
23F0  0A09     XORLW 0x9
23F2  E001     BZ 0x23F6
256:           	{
257:           	    // Received interrupt after calling start event
258:           		case (BUS_START): 
259:           		{
260:           			// Got control of bus ?
261:           			if (SSPSTATbits.S) 
23F6  A6C7     BTFSS SSP1STAT, 3, ACCESS
23F8  D00B     BRA 0x2410
262:           			{	// Launch into sending next byte
263:           				SSPSTATbits.S = 0;
23FA  96C7     BCF SSP1STAT, 3, ACCESS
264:           				SSPBUF = I2C_current_message->control & 0xFE;
23FC  C7E3     MOVFF I2C_current_message, FSR0
23FE  FFE9     NOP
2400  C7E4     MOVFF 0x7E4, FSR0H
2402  FFEA     NOP
2404  50EF     MOVF INDF0, W, ACCESS
2406  0BFE     ANDLW 0xFE
2408  6EC9     MOVWF SSP1BUF, ACCESS
265:           				I2C_bus_state = BUS_CTRL_WRITE;
240A  0107     MOVLB 0x7
240C  0E08     MOVLW 0x8
240E  6FE6     MOVWF 0xE6, BANKED
266:           			}
267:           					
268:           			if (PIR2bits.BCLIF)		//	Failed on bus collision
2410  A6A1     BTFSS PIR2, 3, ACCESS
2412  D009     BRA 0x2426
269:           			{	// FIXME:  Find a better way to keep looping while waiting for
270:           				// the bus to become idle.  Calling for another start will occur
271:           				// according to period TbaudRateGenerator...could have lots of frequent
272:           				// interrupts until bus is clear.
273:           				
274:           				SSPCON2bits.SEN = 1;
2414  80C5     BSF SSP1CON2, 0, ACCESS
275:           				SetEvent(I2C_DRV_ID,BUSERROR_EVENT);
2416  0E08     MOVLW 0x8
2418  6EE6     MOVWF POSTINC1, ACCESS
241A  0E03     MOVLW 0x3
241C  6EE6     MOVWF POSTINC1, ACCESS
241E  EC17     CALL 0x162E, 0
2420  F00B     NOP
2422  52E5     MOVF POSTDEC1, F, ACCESS
2424  52E5     MOVF POSTDEC1, F, ACCESS
276:           			}					
277:           			break;
2426  D118     BRA 0x2658
278:           		}
279:           			
280:           				
281:           		// Received interrupt after control write
282:           		case (BUS_CTRL_WRITE):
283:           				{
284:           					// Slave is answered
285:           					if (!SSPCON2bits.ACKSTAT)
2428  BCC5     BTFSC SSP1CON2, 6, ACCESS
242A  D021     BRA 0x246E
286:           					{
287:           						if (I2C_current_message->flags.long_addr == 1)
242C  C7E3     MOVFF I2C_current_message, FSR0
242E  FFE9     NOP
2430  C7E4     MOVFF 0x7E4, FSR0H
2432  FFEA     NOP
2434  0E0A     MOVLW 0xA
2436  26E9     ADDWF FSR0, F, ACCESS
2438  0E00     MOVLW 0x0
243A  22EA     ADDWFC FSR0H, F, ACCESS
243C  50EF     MOVF INDF0, W, ACCESS
243E  0B01     ANDLW 0x1
2440  E00B     BZ 0x2458
288:           						{
289:           							SSPBUF = I2C_current_message->addr_high;
2442  C7E3     MOVFF I2C_current_message, FSR0
2444  FFE9     NOP
2446  C7E4     MOVFF 0x7E4, FSR0H
2448  FFEA     NOP
244A  0E01     MOVLW 0x1
244C  50EB     MOVF PLUSW0, W, ACCESS
244E  6EC9     MOVWF SSP1BUF, ACCESS
290:           							I2C_bus_state = BUS_WRITE_ADDR_H;
2450  0107     MOVLB 0x7
2452  0E0A     MOVLW 0xA
2454  6FE6     MOVWF 0xE6, BANKED
291:           						}
292:           						else
2456  D00A     BRA 0x246C
293:           						{
294:           							SSPBUF = I2C_current_message->addr_low;
2458  C7E3     MOVFF I2C_current_message, FSR0
245A  FFE9     NOP
245C  C7E4     MOVFF 0x7E4, FSR0H
245E  FFEA     NOP
2460  0E02     MOVLW 0x2
2462  50EB     MOVF PLUSW0, W, ACCESS
2464  6EC9     MOVWF SSP1BUF, ACCESS
295:           							I2C_bus_state = BUS_WRITE_ADDR_L;
2466  0107     MOVLB 0x7
2468  0E09     MOVLW 0x9
246A  6FE6     MOVWF 0xE6, BANKED
296:           						}
297:           					}
298:           					// Slave not responding
299:           					else if (SSPCON2bits.ACKSTAT)
246C  D018     BRA 0x249E
246E  ACC5     BTFSS SSP1CON2, 6, ACCESS
2470  D016     BRA 0x249E
300:           					{
301:           						I2C_current_message->error = ERR_I2C_NOSLAVE;
2472  C7E3     MOVFF I2C_current_message, FSR0
2474  FFE9     NOP
2476  C7E4     MOVFF 0x7E4, FSR0H
2478  FFEA     NOP
247A  0E06     MOVLW 0x6
247C  26E9     ADDWF FSR0, F, ACCESS
247E  0E00     MOVLW 0x0
2480  22EA     ADDWFC FSR0H, F, ACCESS
2482  0EE0     MOVLW 0xE0
2484  14EF     ANDWF INDF0, W, ACCESS
2486  0902     IORLW 0x2
2488  6EEF     MOVWF INDF0, ACCESS
302:           						I2C_bus_state = BUS_IDLE;
248A  0107     MOVLB 0x7
248C  6BE6     CLRF 0xE6, BANKED
303:           						SetEvent(I2C_DRV_ID,BUSERROR_EVENT);
248E  0E08     MOVLW 0x8
2490  6EE6     MOVWF POSTINC1, ACCESS
2492  0E03     MOVLW 0x3
2494  6EE6     MOVWF POSTINC1, ACCESS
2496  EC17     CALL 0x162E, 0
2498  F00B     NOP
249A  52E5     MOVF POSTDEC1, F, ACCESS
249C  52E5     MOVF POSTDEC1, F, ACCESS
304:           					}
305:           				break;
249E  D0DC     BRA 0x2658
306:           				}
307:           
308:           				
309:           		// Received interrupt after send high addr
310:           		case (BUS_WRITE_ADDR_H):
311:           				{
312:           					// Slave ACK'd
313:           					if (!SSPCON2bits.ACKSTAT)
24A0  BCC5     BTFSC SSP1CON2, 6, ACCESS
24A2  D00B     BRA 0x24BA
314:           					{
315:           						SSPBUF = I2C_current_message->addr_low;
24A4  C7E3     MOVFF I2C_current_message, FSR0
24A6  FFE9     NOP
24A8  C7E4     MOVFF 0x7E4, FSR0H
24AA  FFEA     NOP
24AC  0E02     MOVLW 0x2
24AE  50EB     MOVF PLUSW0, W, ACCESS
24B0  6EC9     MOVWF SSP1BUF, ACCESS
316:           						I2C_bus_state = BUS_WRITE_ADDR_L;
24B2  0107     MOVLB 0x7
24B4  0E09     MOVLW 0x9
24B6  6FE6     MOVWF 0xE6, BANKED
317:           					}
318:           					else
24B8  D016     BRA 0x24E6
319:           					{
320:           						I2C_bus_state = BUS_IDLE;
24BA  0107     MOVLB 0x7
24BC  6BE6     CLRF 0xE6, BANKED
321:           						I2C_current_message->error = ERR_I2C_NACK_ADDR;
24BE  C7E3     MOVFF I2C_current_message, FSR0
24C0  FFE9     NOP
24C2  C7E4     MOVFF 0x7E4, FSR0H
24C4  FFEA     NOP
24C6  0E06     MOVLW 0x6
24C8  26E9     ADDWF FSR0, F, ACCESS
24CA  0E00     MOVLW 0x0
24CC  22EA     ADDWFC FSR0H, F, ACCESS
24CE  0EE0     MOVLW 0xE0
24D0  14EF     ANDWF INDF0, W, ACCESS
24D2  0904     IORLW 0x4
24D4  6EEF     MOVWF INDF0, ACCESS
322:           						SetEvent(I2C_DRV_ID,BUSERROR_EVENT);
24D6  0E08     MOVLW 0x8
24D8  6EE6     MOVWF POSTINC1, ACCESS
24DA  0E03     MOVLW 0x3
24DC  6EE6     MOVWF POSTINC1, ACCESS
24DE  EC17     CALL 0x162E, 0
24E0  F00B     NOP
24E2  52E5     MOVF POSTDEC1, F, ACCESS
24E4  52E5     MOVF POSTDEC1, F, ACCESS
323:           					}					
324:           					break;
24E6  D0B8     BRA 0x2658
325:           				}
326:           
327:           
328:           		// Received interrupt after send low addr
329:           		case (BUS_WRITE_ADDR_L):
330:           				{
331:           					// Slave responded
332:           					if (!SSPCON2bits.ACKSTAT)
24E8  BCC5     BTFSC SSP1CON2, 6, ACCESS
24EA  D01C     BRA 0x2524
333:           					{
334:           						if (I2C_current_message->control & 0x01)
24EC  C7E3     MOVFF I2C_current_message, FSR0
24EE  FFE9     NOP
24F0  C7E4     MOVFF 0x7E4, FSR0H
24F2  FFEA     NOP
24F4  50EF     MOVF INDF0, W, ACCESS
24F6  0B01     ANDLW 0x1
24F8  E005     BZ 0x2504
335:           						{	//	This is a read, initiate a restart condition
336:           							I2C_bus_state = BUS_RESTART;
24FA  0107     MOVLB 0x7
24FC  0E02     MOVLW 0x2
24FE  6FE6     MOVWF 0xE6, BANKED
337:           							SSPCON2bits.RSEN = 1;
2500  82C5     BSF SSP1CON2, 1, ACCESS
338:           						}					
339:           						else
2502  D00F     BRA 0x2522
340:           						{	//	Next operation is a data write, output first byte
341:           							I2C_bus_state = BUS_WRITE_DATA;
2504  0107     MOVLB 0x7
2506  0E0B     MOVLW 0xB
2508  6FE6     MOVWF 0xE6, BANKED
342:           							SSPBUF = *p_data;
250A  C7E7     MOVFF p_data, FSR0
250C  FFE9     NOP
250E  C7E8     MOVFF 0x7E8, FSR0H
2510  FFEA     NOP
2512  50EF     MOVF INDF0, W, ACCESS
2514  6EC9     MOVWF SSP1BUF, ACCESS
343:           							p_data++;
2516  0107     MOVLB 0x7
2518  2BE7     INCF 0xE7, F, BANKED
251A  0E00     MOVLW 0x0
251C  23E8     ADDWFC 0xE8, F, BANKED
344:           							I2C_byte_count--;
251E  0107     MOVLB 0x7
2520  07E9     DECF 0xE9, F, BANKED
345:           						}
346:           					}
347:           					// Slave did not respond
348:           					else
2522  D016     BRA 0x2550
349:           					{
350:           							I2C_bus_state = BUS_IDLE;
2524  0107     MOVLB 0x7
2526  6BE6     CLRF 0xE6, BANKED
351:           							I2C_current_message->error = ERR_I2C_NACK_ADDR;
2528  C7E3     MOVFF I2C_current_message, FSR0
252A  FFE9     NOP
252C  C7E4     MOVFF 0x7E4, FSR0H
252E  FFEA     NOP
2530  0E06     MOVLW 0x6
2532  26E9     ADDWF FSR0, F, ACCESS
2534  0E00     MOVLW 0x0
2536  22EA     ADDWFC FSR0H, F, ACCESS
2538  0EE0     MOVLW 0xE0
253A  14EF     ANDWF INDF0, W, ACCESS
253C  0904     IORLW 0x4
253E  6EEF     MOVWF INDF0, ACCESS
352:           							SetEvent(I2C_DRV_ID,BUSERROR_EVENT);
2540  0E08     MOVLW 0x8
2542  6EE6     MOVWF POSTINC1, ACCESS
2544  0E03     MOVLW 0x3
2546  6EE6     MOVWF POSTINC1, ACCESS
2548  EC17     CALL 0x162E, 0
254A  F00B     NOP
254C  52E5     MOVF POSTDEC1, F, ACCESS
254E  52E5     MOVF POSTDEC1, F, ACCESS
353:           					}
354:           					break;
2550  D083     BRA 0x2658
355:           				}
356:           
357:           
358:           
359:           			
360:           		// Received interrupt after calling for restart
361:           		case (BUS_RESTART):
362:           				{
363:           					SSPBUF = I2C_current_message->control;						
2552  C7E3     MOVFF I2C_current_message, FSR0
2554  FFE9     NOP
2556  C7E4     MOVFF 0x7E4, FSR0H
2558  FFEA     NOP
255A  50EF     MOVF INDF0, W, ACCESS
255C  6EC9     MOVWF SSP1BUF, ACCESS
364:           					I2C_bus_state = BUS_CTRL_READ;
255E  0107     MOVLB 0x7
2560  0E07     MOVLW 0x7
2562  6FE6     MOVWF 0xE6, BANKED
365:           					break;
2564  D079     BRA 0x2658
366:           				}
367:           
368:           
369:           					
370:           		// Received interrupt after calling for control read
371:           		case (BUS_CTRL_READ):
372:           				{
373:           					// Slave responded
374:           					if (!SSPCON2bits.ACKSTAT)
2566  BCC5     BTFSC SSP1CON2, 6, ACCESS
2568  D005     BRA 0x2574
375:           					{
376:           						SSPCON2bits.RCEN = 1;
256A  86C5     BSF SSP1CON2, 3, ACCESS
377:           						I2C_bus_state = BUS_READ_DATA;
256C  0107     MOVLB 0x7
256E  0E06     MOVLW 0x6
2570  6FE6     MOVWF 0xE6, BANKED
378:           					}
379:           					else
2572  D00A     BRA 0x2588
380:           					{
381:           						I2C_bus_state = BUS_IDLE;
2574  0107     MOVLB 0x7
2576  6BE6     CLRF 0xE6, BANKED
382:           						SetEvent(I2C_DRV_ID,BUSERROR_EVENT);
2578  0E08     MOVLW 0x8
257A  6EE6     MOVWF POSTINC1, ACCESS
257C  0E03     MOVLW 0x3
257E  6EE6     MOVWF POSTINC1, ACCESS
2580  EC17     CALL 0x162E, 0
2582  F00B     NOP
2584  52E5     MOVF POSTDEC1, F, ACCESS
2586  52E5     MOVF POSTDEC1, F, ACCESS
383:           					}
384:           					break;
2588  D067     BRA 0x2658
385:           				}
386:           
387:           
388:           		// Received interrupt after setting RCEN
389:           		case (BUS_READ_DATA):
390:           				{
391:           					*p_data = SSPBUF;
258A  50C9     MOVF SSP1BUF, W, ACCESS
258C  C7E7     MOVFF p_data, FSR0
258E  FFE9     NOP
2590  C7E8     MOVFF 0x7E8, FSR0H
2592  FFEA     NOP
2594  6EEF     MOVWF INDF0, ACCESS
392:           					p_data++;
2596  0107     MOVLB 0x7
2598  2BE7     INCF 0xE7, F, BANKED
259A  0E00     MOVLW 0x0
259C  23E8     ADDWFC 0xE8, F, BANKED
393:           					I2C_byte_count--;
259E  0107     MOVLB 0x7
25A0  07E9     DECF 0xE9, F, BANKED
394:           					
395:           					if (I2C_byte_count == 0)
25A2  0107     MOVLB 0x7
25A4  51E9     MOVF 0xE9, W, BANKED
25A6  E102     BNZ 0x25AC
396:           						SSPCON2bits.ACKDT = 1;
25A8  8AC5     BSF SSP1CON2, 5, ACCESS
397:           					else
25AA  D001     BRA 0x25AE
398:           						SSPCON2bits.ACKDT = 0;
25AC  9AC5     BCF SSP1CON2, 5, ACCESS
399:           						
400:           					I2C_bus_state = BUS_SEND_ACK_NACK;       
25AE  0107     MOVLB 0x7
25B0  0E04     MOVLW 0x4
25B2  6FE6     MOVWF 0xE6, BANKED
401:           		  	 		SSPCON2bits.ACKEN = 1;
25B4  88C5     BSF SSP1CON2, 4, ACCESS
402:           					break;
25B6  D050     BRA 0x2658
403:           				}
404:           		
405:           		
406:           		// Received interrupt after setting/clearing ACKDT 
407:           		case (BUS_SEND_ACK_NACK):
408:           				{
409:           					if (SSPCON2bits.ACKDT)
25B8  AAC5     BTFSS SSP1CON2, 5, ACCESS
25BA  D006     BRA 0x25C8
410:           					{	// Last was nack, so we're done..
411:           						SSPCON2bits.ACKDT = 0;
25BC  9AC5     BCF SSP1CON2, 5, ACCESS
412:           						I2C_bus_state = BUS_STOP;
25BE  0107     MOVLB 0x7
25C0  0E03     MOVLW 0x3
25C2  6FE6     MOVWF 0xE6, BANKED
413:           						SSPCON2bits.PEN = 1;
25C4  84C5     BSF SSP1CON2, 2, ACCESS
414:           					}
415:           					else
25C6  D004     BRA 0x25D0
416:           					{	//	Last was ack, so there must be more to transfer 
417:           						SSPCON2bits.RCEN = 1;
25C8  86C5     BSF SSP1CON2, 3, ACCESS
418:           						I2C_bus_state = BUS_READ_DATA;
25CA  0107     MOVLB 0x7
25CC  0E06     MOVLW 0x6
25CE  6FE6     MOVWF 0xE6, BANKED
419:           					}
420:           					break;
25D0  D043     BRA 0x2658
421:           				}
422:           
423:           		
424:           		// Received interrupt after calling for stop
425:           		case (BUS_STOP):
426:           				{
427:           					PIR2bits.BCLIF = 0;
25D2  96A1     BCF PIR2, 3, ACCESS
428:           					I2C_bus_state = BUS_IDLE;
25D4  0107     MOVLB 0x7
25D6  6BE6     CLRF 0xE6, BANKED
429:           					SetEvent(I2C_DRV_ID,IDLE_EVENT);
25D8  0E10     MOVLW 0x10
25DA  6EE6     MOVWF POSTINC1, ACCESS
25DC  0E03     MOVLW 0x3
25DE  6EE6     MOVWF POSTINC1, ACCESS
25E0  EC17     CALL 0x162E, 0
25E2  F00B     NOP
25E4  52E5     MOVF POSTDEC1, F, ACCESS
25E6  52E5     MOVF POSTDEC1, F, ACCESS
430:           					break;
25E8  D037     BRA 0x2658
431:           				}				
432:           						
433:           		case (BUS_WRITE_DATA):
434:           				{
435:           					//	Check ACKSTAT to determine if slave answered
436:           					if (SSPCON2bits.ACKSTAT)
25EA  ACC5     BTFSS SSP1CON2, 6, ACCESS
25EC  D010     BRA 0x260E
437:           					{
438:           						I2C_current_message->error = ERR_I2C_NACK_DATA;
25EE  C7E3     MOVFF I2C_current_message, FSR0
25F0  FFE9     NOP
25F2  C7E4     MOVFF 0x7E4, FSR0H
25F4  FFEA     NOP
25F6  0E06     MOVLW 0x6
25F8  26E9     ADDWF FSR0, F, ACCESS
25FA  0E00     MOVLW 0x0
25FC  22EA     ADDWFC FSR0H, F, ACCESS
25FE  0EE0     MOVLW 0xE0
2600  14EF     ANDWF INDF0, W, ACCESS
2602  0908     IORLW 0x8
2604  6EEF     MOVWF INDF0, ACCESS
439:           						I2C_bus_state = BUS_STOP;
2606  0107     MOVLB 0x7
2608  0E03     MOVLW 0x3
260A  6FE6     MOVWF 0xE6, BANKED
440:           						break;
260C  D025     BRA 0x2658
441:           					}
442:           			
443:           					//	Write a byte of data to the slave
444:           					//	Decide which state is next
445:           					if (I2C_byte_count > 0)
260E  0107     MOVLB 0x7
2610  51E9     MOVF 0xE9, W, BANKED
2612  0800     SUBLW 0x0
2614  E210     BC 0x2636
446:           					{
447:           						SSPBUF = *p_data;
2616  C7E7     MOVFF p_data, FSR0
2618  FFE9     NOP
261A  C7E8     MOVFF 0x7E8, FSR0H
261C  FFEA     NOP
261E  50EF     MOVF INDF0, W, ACCESS
2620  6EC9     MOVWF SSP1BUF, ACCESS
448:           						p_data++;
2622  0107     MOVLB 0x7
2624  2BE7     INCF 0xE7, F, BANKED
2626  0E00     MOVLW 0x0
2628  23E8     ADDWFC 0xE8, F, BANKED
449:           						I2C_byte_count--;
262A  0107     MOVLB 0x7
262C  07E9     DECF 0xE9, F, BANKED
450:           						I2C_bus_state = BUS_WRITE_DATA;
262E  0107     MOVLB 0x7
2630  0E0B     MOVLW 0xB
2632  6FE6     MOVWF 0xE6, BANKED
451:           					}
452:           					else
2634  D010     BRA 0x2656
453:           					{
454:           						SSPCON2bits.PEN = 1;
2636  84C5     BSF SSP1CON2, 2, ACCESS
455:           						I2C_bus_state = BUS_STOP;
2638  0107     MOVLB 0x7
263A  0E03     MOVLW 0x3
263C  6FE6     MOVWF 0xE6, BANKED
456:           						I2C_current_message->error = ERR_I2C_SUCCESS;
263E  C7E3     MOVFF I2C_current_message, FSR0
2640  FFE9     NOP
2642  C7E4     MOVFF 0x7E4, FSR0H
2644  FFEA     NOP
2646  0E06     MOVLW 0x6
2648  26E9     ADDWF FSR0, F, ACCESS
264A  0E00     MOVLW 0x0
264C  22EA     ADDWFC FSR0H, F, ACCESS
264E  0EE0     MOVLW 0xE0
2650  14EF     ANDWF INDF0, W, ACCESS
2652  0901     IORLW 0x1
2654  6EEF     MOVWF INDF0, ACCESS
457:           					}
458:           					break;
2656  D000     BRA 0x2658
459:           				}
460:           						
461:           			default:
462:           					break;
23F4  D131     BRA 0x2658
463:           	}	//	End switch
464:             return;
2658  D000     BRA 0x265A
465:           }
265A  0012     RETURN 0
466:           
467:           
468:           /* End of File : drv_i2c.c  */
---  F:/PICOS18/TiltDetector/button.c  ------------------------------------------------------------------
1:             //***************************************************************************
2:             //
3:             //  File........: button.c
4:             //
5:             //  Author(s)...: ATMEL Norway
6:             //
7:             //  Target(s)...: ATmega169
8:             //
9:             //  Compiler....: AVR-GCC 4.1.1; avr-libc 1.4.5
10:            //
11:            //  Description.: AVR Butterfly button handling routines
12:            //
13:            //  Revisions...: 1.0
14:            //
15:            //  YYYYMMDD - VER. - COMMENT                                       - SIGN.
16:            //
17:            //  20030116 - 1.0  - Created                                       - KS
18:            //  20031009          port to avr-gcc/avr-libc                      - M.Thomas
19:            //  20070129          SIGNAL->ISR                                   - mt
20:            //
21:            //***************************************************************************
22:            
23:            #include "main.h"
24:            #include "button.h"
25:            #include "user.h"
26:            
27:            extern volatile BOOL gKeyClickStatus;
28:            volatile unsigned char gButtonTimeout = FALSE;
29:            
30:             //#pragma udata bank1=0x700
31:             volatile char KEY = NULL;
32:             volatile char KEY_VALID = FALSE;
33:            
34:            
35:            char CountdownTimerHandle;
36:            
37:            /*****************************************************************************
38:            *
39:            *   Function name : Button_Init
40:            *
41:            *   Returns :       None
42:            *
43:            *   Parameters :    None
44:            *
45:            *   Purpose :       Initializes the five button pin
46:            *
47:            *****************************************************************************/
48:            void Button_Init(void)
49:            {
50:                // Init port pins
51:            }
33CC  0012     RETURN 0
52:            
53:            
54:            /*****************************************************************************
55:            *
56:            *   Function name : PinChangeInterrupt
57:            *
58:            *   Returns :       None
59:            *
60:            *   Parameters :    None
61:            *
62:            *   Purpose :       Check status on the joystick
63:            *
64:            *****************************************************************************/
65:            void PinChangeInterrupt(void)
33CE  CFD9     MOVFF FSR2, POSTINC1
33D0  FFE6     NOP
33D2  CFE1     MOVFF FSR1, FSR2
33D4  FFD9     NOP
33D6  0E02     MOVLW 0x2
33D8  26E1     ADDWF FSR1, F, ACCESS
66:            {
67:                char buttons;
68:            
69:                char key;
70:            
71:            /*
72:                Read the buttons:
73:            
74:                Bit             7   6   5   4   3   2   1   0
75:                ---------------------------------------------
76:                PORTB           B   A       O
77:                PORTE                           D   C
78:                ---------------------------------------------
79:                PORTB | PORTE   B   A       O   D   C
80:                =============================================
81:            */
82:            
83:            
84:               // buttons = (~PINB) & PINB_MASK;
85:               // buttons |= (~PINE) & PINE_MASK;
86:            
87:                // Output virtual keys
88:                if (buttons & (1<<BUTTON_A))
33DA  ACDF     BTFSS INDF2, 6, ACCESS
33DC  D004     BRA 0x33E6
89:                    key = KEY_PLUS;
33DE  52DE     MOVF POSTINC2, F, ACCESS
33E0  0E04     MOVLW 0x4
33E2  6EDD     MOVWF POSTDEC2, ACCESS
90:                else if (buttons & (1<<BUTTON_B))
33E4  D01A     BRA 0x341A
33E6  AEDF     BTFSS INDF2, 7, ACCESS
33E8  D004     BRA 0x33F2
91:                    key = KEY_MINUS;
33EA  52DE     MOVF POSTINC2, F, ACCESS
33EC  0E05     MOVLW 0x5
33EE  6EDD     MOVWF POSTDEC2, ACCESS
92:                else if (buttons & (1<<BUTTON_C))
33F0  D014     BRA 0x341A
33F2  A4DF     BTFSS INDF2, 2, ACCESS
33F4  D004     BRA 0x33FE
93:                    key = KEY_PREV;
33F6  52DE     MOVF POSTINC2, F, ACCESS
33F8  0E03     MOVLW 0x3
33FA  6EDD     MOVWF POSTDEC2, ACCESS
94:                else if (buttons & (1<<BUTTON_D))
33FC  D00E     BRA 0x341A
33FE  A6DF     BTFSS INDF2, 3, ACCESS
3400  D004     BRA 0x340A
95:                    key = KEY_NEXT;
3402  52DE     MOVF POSTINC2, F, ACCESS
3404  0E02     MOVLW 0x2
3406  6EDD     MOVWF POSTDEC2, ACCESS
96:                else if (buttons & (1<<BUTTON_O))
3408  D008     BRA 0x341A
340A  A8DF     BTFSS INDF2, 4, ACCESS
340C  D004     BRA 0x3416
97:                    key = KEY_ENTER;
340E  52DE     MOVF POSTINC2, F, ACCESS
3410  0E01     MOVLW 0x1
3412  6EDD     MOVWF POSTDEC2, ACCESS
98:                else
3414  D002     BRA 0x341A
99:                    key = KEY_NULL;
3416  0E01     MOVLW 0x1
3418  6ADB     CLRF PLUSW2, ACCESS
100:           
101:               
102:               if(key != KEY_NULL)
341A  0E01     MOVLW 0x1
341C  50DB     MOVF PLUSW2, W, ACCESS
341E  E013     BZ 0x3446
103:               {
104:                   if(gButtonTimeout)  // gButtonTimeout is set in the LCD_SOF_interrupt in LCD_driver.c
3420  010E     MOVLB 0xE
3422  513E     MOVF 0x3E, W, BANKED
3424  E010     BZ 0x3446
105:                   {
106:                       if (!KEY_VALID)//si KEY_VALID=FALSE
3426  010E     MOVLB 0xE
3428  5140     MOVF 0x40, W, BANKED
342A  E10B     BNZ 0x3442
107:                       {
108:                           KEY = key;          // Store key in global key buffer
342C  0E01     MOVLW 0x1
342E  CFDB     MOVFF PLUSW2, KEY
3430  FE3F     NOP
109:                           KEY_VALID = TRUE;
3432  010E     MOVLB 0xE
3434  6F40     MOVWF 0x40, BANKED
110:                           if (gKeyClickStatus)
3436  010E     MOVLB 0xE
3438  5145     MOVF 0x45, W, BANKED
343A  E003     BZ 0x3442
111:                           KEY_VALID = TRUE;//ajout pour résoudre problème de compile
343C  010E     MOVLB 0xE
343E  0E01     MOVLW 0x1
3440  6F40     MOVWF 0x40, BANKED
112:                            // PlayClick();
113:                       }
114:           
115:                    gButtonTimeout = FALSE;
3442  010E     MOVLB 0xE
3444  6B3E     CLRF 0x3E, BANKED
116:               
117:                   }
118:               }
119:               
120:               //EIFR = (1<<PCIF1) | (1<<PCIF0);     // Delete pin change interrupt flags
121:           
122:           //    gPowerSaveTimer = 0;                // Reset the Auto Power Down timer
123:               
124:           }
3446  0E02     MOVLW 0x2
3448  5CE1     SUBWF FSR1, W, ACCESS
344A  E202     BC 0x3450
344C  6AE1     CLRF FSR1, ACCESS
344E  52E5     MOVF POSTDEC1, F, ACCESS
3450  6EE1     MOVWF FSR1, ACCESS
3452  52E5     MOVF POSTDEC1, F, ACCESS
3454  CFE7     MOVFF INDF1, FSR2
3456  FFD9     NOP
3458  0012     RETURN 0
125:           
126:           
127:           /*****************************************************************************
128:           *
129:           *   Function name : getkey
130:           *
131:           *   Returns :       The valid key
132:           *
133:           *   Parameters :    None
134:           *
135:           *   Purpose :       Get the valid key 
136:           *
137:           *****************************************************************************/
138:           char getkey(void)
345A  CFD9     MOVFF FSR2, POSTINC1
345C  FFE6     NOP
345E  CFE1     MOVFF FSR1, FSR2
3460  FFD9     NOP
3462  52E6     MOVF POSTINC1, F, ACCESS
139:           {
140:               char k;
141:              // cli(); // mt: __disable_interrupt();
142:               if (KEY_VALID)              // Check for unread key in buffer
3464  010E     MOVLB 0xE
3466  5140     MOVF 0x40, W, BANKED
3468  E005     BZ 0x3474
143:               {   k = KEY;
346A  CE3F     MOVFF KEY, INDF2
346C  FFDF     NOP
144:                   KEY_VALID = FALSE;
346E  010E     MOVLB 0xE
3470  6B40     CLRF 0x40, BANKED
145:               }
146:               else
3472  D001     BRA 0x3476
147:                   k = KEY_NULL;           // No key stroke available
3474  6ADF     CLRF INDF2, ACCESS
148:               //sei(); // mt: __enable_interrupt();
149:               return k;
3476  50DF     MOVF INDF2, W, ACCESS
3478  D000     BRA 0x347A
150:           }
347A  52E5     MOVF POSTDEC1, F, ACCESS
347C  52E5     MOVF POSTDEC1, F, ACCESS
347E  CFE7     MOVFF INDF1, FSR2
3480  FFD9     NOP
3482  0012     RETURN 0
---  F:/PICOS18/TiltDetector/STTS751.c  -----------------------------------------------------------------
1:             #include "STTS751.h"
2:             
3:             #include "drv_i2c.h"
4:             #include "tsk_task_main.h"
5:             
6:             void InitSTTS751()
7:             {
8:                 STTS751WriteByte(&My_I2C_Message, STTS751_ADDRESS, Configuration, 0x00);
3606  6AE6     CLRF POSTINC1, ACCESS
3608  0E03     MOVLW 0x3
360A  6EE6     MOVWF POSTINC1, ACCESS
360C  0E93     MOVLW 0x93
360E  6EE6     MOVWF POSTINC1, ACCESS
3610  0E93     MOVLW 0x93
3612  6EE6     MOVWF POSTINC1, ACCESS
3614  0E07     MOVLW 0x7
3616  6EE6     MOVWF POSTINC1, ACCESS
3618  D8D9     RCALL STTS751WriteByte
361A  6E14     MOVWF __tmp_0, ACCESS
361C  0E05     MOVLW 0x5
361E  5EE1     SUBWF FSR1, F, ACCESS
3620  5014     MOVF __tmp_0, W, ACCESS
9:             }
3622  0012     RETURN 0
10:            
11:            float ReatTemperatureSTTS751(void)
3624  CFD9     MOVFF FSR2, POSTINC1
3626  FFE6     NOP
3628  CFE1     MOVFF FSR1, FSR2
362A  FFD9     NOP
362C  0E02     MOVLW 0x2
362E  26E1     ADDWF FSR1, F, ACCESS
12:            {
13:                uint8_t ValLow = 192;
3630  0EC0     MOVLW 0xC0
3632  6EDF     MOVWF INDF2, ACCESS
14:                int8_t ValHigh = -12;
3634  52DE     MOVF POSTINC2, F, ACCESS
3636  0EF4     MOVLW 0xF4
3638  6EDD     MOVWF POSTDEC2, ACCESS
15:                
16:               // ValHigh = STTS751ReadByte(&My_I2C_Message, STTS751_ADDRESS, Temperature_value_high);
17:                //ValLow = STTS751ReadByte(&My_I2C_Message, STTS751_ADDRESS, Temperature_value_low);
18:                
19:                if( ValHigh > 0){
363A  0E01     MOVLW 0x1
363C  CFDB     MOVFF PLUSW2, __tmp_0
363E  F014     NOP
3640  0E00     MOVLW 0x0
3642  6EE7     MOVWF INDF1, ACCESS
3644  1814     XORWF __tmp_0, W, ACCESS
3646  AEE8     BTFSS WREG, 7, ACCESS
3648  D002     BRA 0x364E
364A  3414     RLCF __tmp_0, W, ACCESS
364C  D003     BRA 0x3654
364E  50E7     MOVF INDF1, W, ACCESS
3650  80D8     BSF STATUS, 0, ACCESS
3652  5414     SUBFWB __tmp_0, W, ACCESS
3654  E259     BC 0x3708
20:                  return  (float)ValHigh + (float)ValLow * 1.0/256.0;
3656  0E01     MOVLW 0x1
3658  CFDB     MOVFF PLUSW2, 0x1C
365A  F01C     NOP
365C  C01C     MOVFF 0x1C, 0x7
365E  F007     NOP
3660  EC4B     CALL 0x2C96, 0
3662  F016     NOP
3664  C005     MOVFF 0x5, 0x18
3666  F018     NOP
3668  C006     MOVFF 0x6, 0x19
366A  F019     NOP
366C  C007     MOVFF 0x7, 0x1A
366E  F01A     NOP
3670  C008     MOVFF 0x8, 0x1B
3672  F01B     NOP
3674  CFDF     MOVFF INDF2, 0x25
3676  F025     NOP
3678  C025     MOVFF 0x25, 0x7
367A  F007     NOP
367C  EC49     CALL 0x2C92, 0
367E  F016     NOP
3680  C005     MOVFF 0x5, 0x21
3682  F021     NOP
3684  C006     MOVFF 0x6, 0x22
3686  F022     NOP
3688  C007     MOVFF 0x7, 0x23
368A  F023     NOP
368C  C008     MOVFF 0x8, 0x24
368E  F024     NOP
3690  6A0A     CLRF 0xA, ACCESS
3692  6A0B     CLRF 0xB, ACCESS
3694  0E80     MOVLW 0x80
3696  6E0C     MOVWF 0xC, ACCESS
3698  0E43     MOVLW 0x43
369A  6E0D     MOVWF 0xD, ACCESS
369C  C021     MOVFF 0x21, 0x5
369E  F005     NOP
36A0  C022     MOVFF 0x22, 0x6
36A2  F006     NOP
36A4  C023     MOVFF 0x23, 0x7
36A6  F007     NOP
36A8  C024     MOVFF 0x24, 0x8
36AA  F008     NOP
36AC  ECF1     CALL 0x2DE2, 0
36AE  F016     NOP
36B0  C005     MOVFF 0x5, 0x1D
36B2  F01D     NOP
36B4  C006     MOVFF 0x6, 0x1E
36B6  F01E     NOP
36B8  C007     MOVFF 0x7, 0x1F
36BA  F01F     NOP
36BC  C008     MOVFF 0x8, 0x20
36BE  F020     NOP
36C0  C01D     MOVFF 0x1D, 0xA
36C2  F00A     NOP
36C4  C01E     MOVFF 0x1E, 0xB
36C6  F00B     NOP
36C8  C01F     MOVFF 0x1F, 0xC
36CA  F00C     NOP
36CC  C020     MOVFF 0x20, 0xD
36CE  F00D     NOP
36D0  C018     MOVFF 0x18, 0x5
36D2  F005     NOP
36D4  C019     MOVFF 0x19, 0x6
36D6  F006     NOP
36D8  C01A     MOVFF 0x1A, 0x7
36DA  F007     NOP
36DC  C01B     MOVFF 0x1B, 0x8
36DE  F008     NOP
36E0  EC5B     CALL 0x2CB6, 0
36E2  F016     NOP
36E4  C005     MOVFF 0x5, __tmp_0
36E6  F014     NOP
36E8  C006     MOVFF 0x6, 0x15
36EA  F015     NOP
36EC  C007     MOVFF 0x7, 0x16
36EE  F016     NOP
36F0  C008     MOVFF 0x8, 0x17
36F2  F017     NOP
36F4  C014     MOVFF __tmp_0, 0x4
36F6  F004     NOP
36F8  C015     MOVFF 0x15, 0x5
36FA  F005     NOP
36FC  C016     MOVFF 0x16, 0x6
36FE  F006     NOP
3700  C017     MOVFF 0x17, 0x7
3702  F007     NOP
3704  D059     BRA 0x37B8
21:                }else{
3706  D058     BRA 0x37B8
22:                  return  (float)ValHigh - (float)ValLow * 1.0/256.0;
3708  0E01     MOVLW 0x1
370A  CFDB     MOVFF PLUSW2, 0x1C
370C  F01C     NOP
370E  C01C     MOVFF 0x1C, 0x7
3710  F007     NOP
3712  EC4B     CALL 0x2C96, 0
3714  F016     NOP
3716  C005     MOVFF 0x5, 0x18
3718  F018     NOP
371A  C006     MOVFF 0x6, 0x19
371C  F019     NOP
371E  C007     MOVFF 0x7, 0x1A
3720  F01A     NOP
3722  C008     MOVFF 0x8, 0x1B
3724  F01B     NOP
3726  CFDF     MOVFF INDF2, 0x25
3728  F025     NOP
372A  C025     MOVFF 0x25, 0x7
372C  F007     NOP
372E  EC49     CALL 0x2C92, 0
3730  F016     NOP
3732  C005     MOVFF 0x5, 0x21
3734  F021     NOP
3736  C006     MOVFF 0x6, 0x22
3738  F022     NOP
373A  C007     MOVFF 0x7, 0x23
373C  F023     NOP
373E  C008     MOVFF 0x8, 0x24
3740  F024     NOP
3742  6A0A     CLRF 0xA, ACCESS
3744  6A0B     CLRF 0xB, ACCESS
3746  0E80     MOVLW 0x80
3748  6E0C     MOVWF 0xC, ACCESS
374A  0E43     MOVLW 0x43
374C  6E0D     MOVWF 0xD, ACCESS
374E  C021     MOVFF 0x21, 0x5
3750  F005     NOP
3752  C022     MOVFF 0x22, 0x6
3754  F006     NOP
3756  C023     MOVFF 0x23, 0x7
3758  F007     NOP
375A  C024     MOVFF 0x24, 0x8
375C  F008     NOP
375E  ECF1     CALL 0x2DE2, 0
3760  F016     NOP
3762  C005     MOVFF 0x5, 0x1D
3764  F01D     NOP
3766  C006     MOVFF 0x6, 0x1E
3768  F01E     NOP
376A  C007     MOVFF 0x7, 0x1F
376C  F01F     NOP
376E  C008     MOVFF 0x8, 0x20
3770  F020     NOP
3772  C01D     MOVFF 0x1D, 0xA
3774  F00A     NOP
3776  C01E     MOVFF 0x1E, 0xB
3778  F00B     NOP
377A  C01F     MOVFF 0x1F, 0xC
377C  F00C     NOP
377E  C020     MOVFF 0x20, 0xD
3780  F00D     NOP
3782  C018     MOVFF 0x18, 0x5
3784  F005     NOP
3786  C019     MOVFF 0x19, 0x6
3788  F006     NOP
378A  C01A     MOVFF 0x1A, 0x7
378C  F007     NOP
378E  C01B     MOVFF 0x1B, 0x8
3790  F008     NOP
3792  EC5A     CALL 0x2CB4, 0
3794  F016     NOP
3796  C005     MOVFF 0x5, __tmp_0
3798  F014     NOP
379A  C006     MOVFF 0x6, 0x15
379C  F015     NOP
379E  C007     MOVFF 0x7, 0x16
37A0  F016     NOP
37A2  C008     MOVFF 0x8, 0x17
37A4  F017     NOP
37A6  C014     MOVFF __tmp_0, 0x4
37A8  F004     NOP
37AA  C015     MOVFF 0x15, 0x5
37AC  F005     NOP
37AE  C016     MOVFF 0x16, 0x6
37B0  F006     NOP
37B2  C017     MOVFF 0x17, 0x7
37B4  F007     NOP
37B6  D000     BRA 0x37B8
23:                }
24:            }
37B8  0E02     MOVLW 0x2
37BA  5CE1     SUBWF FSR1, W, ACCESS
37BC  E202     BC 0x37C2
37BE  6AE1     CLRF FSR1, ACCESS
37C0  52E5     MOVF POSTDEC1, F, ACCESS
37C2  6EE1     MOVWF FSR1, ACCESS
37C4  52E5     MOVF POSTDEC1, F, ACCESS
37C6  CFE7     MOVFF INDF1, FSR2
37C8  FFD9     NOP
37CA  0012     RETURN 0
25:            
26:            /**********************************************************************
27:             *
28:             *
29:             * @param  MemMsg    	 IN  Mandatory I2C structure
30:             * @param
31:             * @return Status         E_OK if the STTS751 has been updated
32:             *                        E_OS_STATE if the I2C access failed
33:             **********************************************************************/
34:            StatusType STTS751WriteByte(I2C_message_t *MemMsg, uint8_t address, uint8_t subAddress, uint8_t data)
37CC  CFD9     MOVFF FSR2, POSTINC1
37CE  FFE6     NOP
37D0  CFE1     MOVFF FSR1, FSR2
37D2  FFD9     NOP
37D4  52E6     MOVF POSTINC1, F, ACCESS
35:            {
36:                unsigned char pData[1];
37:            
38:                MemMsg->control = address & 0xFE;
37D6  0EFC     MOVLW 0xFC
37D8  50DB     MOVF PLUSW2, W, ACCESS
37DA  0BFE     ANDLW 0xFE
37DC  6EE6     MOVWF POSTINC1, ACCESS
37DE  0EFD     MOVLW 0xFD
37E0  CFDB     MOVFF PLUSW2, FSR0
37E2  FFE9     NOP
37E4  0EFE     MOVLW 0xFE
37E6  CFDB     MOVFF PLUSW2, FSR0H
37E8  FFEA     NOP
37EA  52E5     MOVF POSTDEC1, F, ACCESS
37EC  50E7     MOVF INDF1, W, ACCESS
37EE  6EEF     MOVWF INDF0, ACCESS
39:                //  High byte of addr, only used if high bit set
40:                MemMsg->addr_high = 0;
37F0  0EFD     MOVLW 0xFD
37F2  CFDB     MOVFF PLUSW2, FSR0
37F4  FFE9     NOP
37F6  0EFE     MOVLW 0xFE
37F8  CFDB     MOVFF PLUSW2, FSR0H
37FA  FFEA     NOP
37FC  52EE     MOVF POSTINC0, F, ACCESS
37FE  6AEF     CLRF INDF0, ACCESS
41:                // First register Adress
42:                MemMsg->addr_low = subAddress;
3800  0EFD     MOVLW 0xFD
3802  CFDB     MOVFF PLUSW2, FSR0
3804  FFE9     NOP
3806  0EFE     MOVLW 0xFE
3808  CFDB     MOVFF PLUSW2, FSR0H
380A  FFEA     NOP
380C  0E02     MOVLW 0x2
380E  26E9     ADDWF FSR0, F, ACCESS
3810  0E00     MOVLW 0x0
3812  22EA     ADDWFC FSR0H, F, ACCESS
3814  0EFB     MOVLW 0xFB
3816  CFDB     MOVFF PLUSW2, INDF0
3818  FFEF     NOP
43:                // The bit setting of flags.ptr_type
44:                MemMsg->ram_data = pData;
381A  CFD9     MOVFF FSR2, __tmp_0
381C  F014     NOP
381E  CFDA     MOVFF FSR2H, 0x15
3820  F015     NOP
3822  0EFD     MOVLW 0xFD
3824  CFDB     MOVFF PLUSW2, FSR0
3826  FFE9     NOP
3828  0EFE     MOVLW 0xFE
382A  CFDB     MOVFF PLUSW2, FSR0H
382C  FFEA     NOP
382E  0E03     MOVLW 0x3
3830  26E9     ADDWF FSR0, F, ACCESS
3832  0E00     MOVLW 0x0
3834  22EA     ADDWFC FSR0H, F, ACCESS
3836  C014     MOVFF __tmp_0, POSTINC0
3838  FFEE     NOP
383A  C015     MOVFF 0x15, POSTDEC0
383C  FFED     NOP
45:                // Must be less than 255
46:                MemMsg->num_bytes = sizeof (pData);
383E  0EFD     MOVLW 0xFD
3840  CFDB     MOVFF PLUSW2, FSR0
3842  FFE9     NOP
3844  0EFE     MOVLW 0xFE
3846  CFDB     MOVFF PLUSW2, FSR0H
3848  FFEA     NOP
384A  0E05     MOVLW 0x5
384C  26E9     ADDWF FSR0, F, ACCESS
384E  0E00     MOVLW 0x0
3850  22EA     ADDWFC FSR0H, F, ACCESS
3852  0E01     MOVLW 0x1
3854  6EEF     MOVWF INDF0, ACCESS
47:                // 0 = single byte address, 1= two byte address
48:                MemMsg->flags.long_addr = 1;
3856  0EFD     MOVLW 0xFD
3858  CFDB     MOVFF PLUSW2, FSR0
385A  FFE9     NOP
385C  0EFE     MOVLW 0xFE
385E  CFDB     MOVFF PLUSW2, FSR0H
3860  FFEA     NOP
3862  0E0A     MOVLW 0xA
3864  26E9     ADDWF FSR0, F, ACCESS
3866  0E00     MOVLW 0x0
3868  22EA     ADDWFC FSR0H, F, ACCESS
386A  80EF     BSF INDF0, 0, ACCESS
49:                // 1 = read from external, 0 = write to external
50:                MemMsg->flags.i2c_read = 0;
386C  0EFD     MOVLW 0xFD
386E  CFDB     MOVFF PLUSW2, FSR0
3870  FFE9     NOP
3872  0EFE     MOVLW 0xFE
3874  CFDB     MOVFF PLUSW2, FSR0H
3876  FFEA     NOP
3878  0E0A     MOVLW 0xA
387A  26E9     ADDWF FSR0, F, ACCESS
387C  0E00     MOVLW 0x0
387E  22EA     ADDWFC FSR0H, F, ACCESS
3880  92EF     BCF INDF0, 1, ACCESS
51:                // 1 = SMBbus Enabled, 0 = Disabled
52:                MemMsg->flags.SMBus = 0;
3882  0EFD     MOVLW 0xFD
3884  CFDB     MOVFF PLUSW2, FSR0
3886  FFE9     NOP
3888  0EFE     MOVLW 0xFE
388A  CFDB     MOVFF PLUSW2, FSR0H
388C  FFEA     NOP
388E  0E0A     MOVLW 0xA
3890  26E9     ADDWF FSR0, F, ACCESS
3892  0E00     MOVLW 0x0
3894  22EA     ADDWFC FSR0H, F, ACCESS
3896  94EF     BCF INDF0, 2, ACCESS
53:            
54:                pData[0] = data;
3898  0EFA     MOVLW 0xFA
389A  50DB     MOVF PLUSW2, W, ACCESS
389C  6EDF     MOVWF INDF2, ACCESS
55:            
56:                I2C_enqMsg(MemMsg);
389E  0EFD     MOVLW 0xFD
38A0  CFDB     MOVFF PLUSW2, POSTINC1
38A2  FFE6     NOP
38A4  0EFE     MOVLW 0xFE
38A6  CFDB     MOVFF PLUSW2, POSTINC1
38A8  FFE6     NOP
38AA  EC2E     CALL 0x225C, 0
38AC  F011     NOP
38AE  52E5     MOVF POSTDEC1, F, ACCESS
38B0  52E5     MOVF POSTDEC1, F, ACCESS
57:                SetEvent(I2C_DRV_ID, I2C_NEW_MSG);
38B2  0E02     MOVLW 0x2
38B4  6EE6     MOVWF POSTINC1, ACCESS
38B6  0E03     MOVLW 0x3
38B8  6EE6     MOVWF POSTINC1, ACCESS
38BA  EC17     CALL 0x162E, 0
38BC  F00B     NOP
38BE  52E5     MOVF POSTDEC1, F, ACCESS
38C0  52E5     MOVF POSTDEC1, F, ACCESS
58:                WaitEvent(I2C_QUEUE_EMPTY);
38C2  0E20     MOVLW 0x20
38C4  6EE6     MOVWF POSTINC1, ACCESS
38C6  EC74     CALL 0x18E8, 0
38C8  F00C     NOP
38CA  52E5     MOVF POSTDEC1, F, ACCESS
59:                ClearEvent(I2C_QUEUE_EMPTY);
38CC  0E20     MOVLW 0x20
38CE  6EE6     MOVWF POSTINC1, ACCESS
38D0  ECAA     CALL 0x1754, 0
38D2  F00B     NOP
38D4  52E5     MOVF POSTDEC1, F, ACCESS
60:            
61:                if (MemMsg->flags.error != 0)
38D6  0EFD     MOVLW 0xFD
38D8  CFDB     MOVFF PLUSW2, FSR0
38DA  FFE9     NOP
38DC  0EFE     MOVLW 0xFE
38DE  CFDB     MOVFF PLUSW2, FSR0H
38E0  FFEA     NOP
38E2  0E0A     MOVLW 0xA
38E4  26E9     ADDWF FSR0, F, ACCESS
38E6  0E00     MOVLW 0x0
38E8  22EA     ADDWFC FSR0H, F, ACCESS
38EA  50EF     MOVF INDF0, W, ACCESS
38EC  0B10     ANDLW 0x10
38EE  E002     BZ 0x38F4
62:                    return E_OS_STATE;
38F0  0E07     MOVLW 0x7
38F2  D002     BRA 0x38F8
63:                return E_OK;
38F4  0E00     MOVLW 0x0
38F6  D000     BRA 0x38F8
64:            }
38F8  52E5     MOVF POSTDEC1, F, ACCESS
38FA  52E5     MOVF POSTDEC1, F, ACCESS
38FC  CFE7     MOVFF INDF1, FSR2
38FE  FFD9     NOP
3900  0012     RETURN 0
65:            
66:            /**********************************************************************
67:             * Read a single byte from subaddress
68:             *
69:             * @param  MemMsg    	IN  Mandatory I2C structure
70:             * @param
71:             * @return Status         E_OK if the STTS751 has been read
72:             *                        E_OS_STATE if the I2C access failed
73:             **********************************************************************/
74:            uint8_t STTS751ReadByte(I2C_message_t *MemMsg, uint8_t address, uint8_t subAddress)
3902  CFD9     MOVFF FSR2, POSTINC1
3904  FFE6     NOP
3906  CFE1     MOVFF FSR1, FSR2
3908  FFD9     NOP
390A  52E6     MOVF POSTINC1, F, ACCESS
75:            {
76:                unsigned char pData[1];
77:            
78:                MemMsg->control = address | 0x01;
390C  0EFC     MOVLW 0xFC
390E  50DB     MOVF PLUSW2, W, ACCESS
3910  0901     IORLW 0x1
3912  6EE6     MOVWF POSTINC1, ACCESS
3914  0EFD     MOVLW 0xFD
3916  CFDB     MOVFF PLUSW2, FSR0
3918  FFE9     NOP
391A  0EFE     MOVLW 0xFE
391C  CFDB     MOVFF PLUSW2, FSR0H
391E  FFEA     NOP
3920  52E5     MOVF POSTDEC1, F, ACCESS
3922  50E7     MOVF INDF1, W, ACCESS
3924  6EEF     MOVWF INDF0, ACCESS
79:                //  High byte of addr, only used if high bit set
80:                MemMsg->addr_high = 0;
3926  0EFD     MOVLW 0xFD
3928  CFDB     MOVFF PLUSW2, FSR0
392A  FFE9     NOP
392C  0EFE     MOVLW 0xFE
392E  CFDB     MOVFF PLUSW2, FSR0H
3930  FFEA     NOP
3932  52EE     MOVF POSTINC0, F, ACCESS
3934  6AEF     CLRF INDF0, ACCESS
81:                // First register Adress
82:                MemMsg->addr_low = subAddress;
3936  0EFD     MOVLW 0xFD
3938  CFDB     MOVFF PLUSW2, FSR0
393A  FFE9     NOP
393C  0EFE     MOVLW 0xFE
393E  CFDB     MOVFF PLUSW2, FSR0H
3940  FFEA     NOP
3942  0E02     MOVLW 0x2
3944  26E9     ADDWF FSR0, F, ACCESS
3946  0E00     MOVLW 0x0
3948  22EA     ADDWFC FSR0H, F, ACCESS
394A  0EFB     MOVLW 0xFB
394C  CFDB     MOVFF PLUSW2, INDF0
394E  FFEF     NOP
83:                // The bit setting of flags.ptr_type
84:                MemMsg->ram_data = pData;
3950  CFD9     MOVFF FSR2, __tmp_0
3952  F014     NOP
3954  CFDA     MOVFF FSR2H, 0x15
3956  F015     NOP
3958  0EFD     MOVLW 0xFD
395A  CFDB     MOVFF PLUSW2, FSR0
395C  FFE9     NOP
395E  0EFE     MOVLW 0xFE
3960  CFDB     MOVFF PLUSW2, FSR0H
3962  FFEA     NOP
3964  0E03     MOVLW 0x3
3966  26E9     ADDWF FSR0, F, ACCESS
3968  0E00     MOVLW 0x0
396A  22EA     ADDWFC FSR0H, F, ACCESS
396C  C014     MOVFF __tmp_0, POSTINC0
396E  FFEE     NOP
3970  C015     MOVFF 0x15, POSTDEC0
3972  FFED     NOP
85:                // Must be less than 255
86:                MemMsg->num_bytes = sizeof (pData);
3974  0EFD     MOVLW 0xFD
3976  CFDB     MOVFF PLUSW2, FSR0
3978  FFE9     NOP
397A  0EFE     MOVLW 0xFE
397C  CFDB     MOVFF PLUSW2, FSR0H
397E  FFEA     NOP
3980  0E05     MOVLW 0x5
3982  26E9     ADDWF FSR0, F, ACCESS
3984  0E00     MOVLW 0x0
3986  22EA     ADDWFC FSR0H, F, ACCESS
3988  0E01     MOVLW 0x1
398A  6EEF     MOVWF INDF0, ACCESS
87:                // 0 = single byte address, 1= two byte address
88:                MemMsg->flags.long_addr = 1;
398C  0EFD     MOVLW 0xFD
398E  CFDB     MOVFF PLUSW2, FSR0
3990  FFE9     NOP
3992  0EFE     MOVLW 0xFE
3994  CFDB     MOVFF PLUSW2, FSR0H
3996  FFEA     NOP
3998  0E0A     MOVLW 0xA
399A  26E9     ADDWF FSR0, F, ACCESS
399C  0E00     MOVLW 0x0
399E  22EA     ADDWFC FSR0H, F, ACCESS
39A0  80EF     BSF INDF0, 0, ACCESS
89:                // 1 = read from external, 0 = write to external
90:                MemMsg->flags.i2c_read = 1;
39A2  0EFD     MOVLW 0xFD
39A4  CFDB     MOVFF PLUSW2, FSR0
39A6  FFE9     NOP
39A8  0EFE     MOVLW 0xFE
39AA  CFDB     MOVFF PLUSW2, FSR0H
39AC  FFEA     NOP
39AE  0E0A     MOVLW 0xA
39B0  26E9     ADDWF FSR0, F, ACCESS
39B2  0E00     MOVLW 0x0
39B4  22EA     ADDWFC FSR0H, F, ACCESS
39B6  82EF     BSF INDF0, 1, ACCESS
91:                // 1 = SMBbus Enabled, 0 = Disabled
92:                MemMsg->flags.SMBus = 0;
39B8  0EFD     MOVLW 0xFD
39BA  CFDB     MOVFF PLUSW2, FSR0
39BC  FFE9     NOP
39BE  0EFE     MOVLW 0xFE
39C0  CFDB     MOVFF PLUSW2, FSR0H
39C2  FFEA     NOP
39C4  0E0A     MOVLW 0xA
39C6  26E9     ADDWF FSR0, F, ACCESS
39C8  0E00     MOVLW 0x0
39CA  22EA     ADDWFC FSR0H, F, ACCESS
39CC  94EF     BCF INDF0, 2, ACCESS
93:                MemMsg->next = 0;
39CE  0EFD     MOVLW 0xFD
39D0  CFDB     MOVFF PLUSW2, FSR0
39D2  FFE9     NOP
39D4  0EFE     MOVLW 0xFE
39D6  CFDB     MOVFF PLUSW2, FSR0H
39D8  FFEA     NOP
39DA  0E08     MOVLW 0x8
39DC  6AEB     CLRF PLUSW0, ACCESS
39DE  0E09     MOVLW 0x9
39E0  6AEB     CLRF PLUSW0, ACCESS
94:            
95:                I2C_enqMsg(MemMsg);
39E2  0EFD     MOVLW 0xFD
39E4  CFDB     MOVFF PLUSW2, POSTINC1
39E6  FFE6     NOP
39E8  0EFE     MOVLW 0xFE
39EA  CFDB     MOVFF PLUSW2, POSTINC1
39EC  FFE6     NOP
39EE  EC2E     CALL 0x225C, 0
39F0  F011     NOP
39F2  52E5     MOVF POSTDEC1, F, ACCESS
39F4  52E5     MOVF POSTDEC1, F, ACCESS
96:                SetEvent(I2C_DRV_ID, I2C_NEW_MSG);
39F6  0E02     MOVLW 0x2
39F8  6EE6     MOVWF POSTINC1, ACCESS
39FA  0E03     MOVLW 0x3
39FC  6EE6     MOVWF POSTINC1, ACCESS
39FE  EC17     CALL 0x162E, 0
3A00  F00B     NOP
3A02  52E5     MOVF POSTDEC1, F, ACCESS
3A04  52E5     MOVF POSTDEC1, F, ACCESS
97:                WaitEvent(I2C_QUEUE_EMPTY);
3A06  0E20     MOVLW 0x20
3A08  6EE6     MOVWF POSTINC1, ACCESS
3A0A  EC74     CALL 0x18E8, 0
3A0C  F00C     NOP
3A0E  52E5     MOVF POSTDEC1, F, ACCESS
98:                ClearEvent(I2C_QUEUE_EMPTY);
3A10  0E20     MOVLW 0x20
3A12  6EE6     MOVWF POSTINC1, ACCESS
3A14  ECAA     CALL 0x1754, 0
3A16  F00B     NOP
3A18  52E5     MOVF POSTDEC1, F, ACCESS
99:            
100:               if (MemMsg->flags.error != 0)
3A1A  0EFD     MOVLW 0xFD
3A1C  CFDB     MOVFF PLUSW2, FSR0
3A1E  FFE9     NOP
3A20  0EFE     MOVLW 0xFE
3A22  CFDB     MOVFF PLUSW2, FSR0H
3A24  FFEA     NOP
3A26  0E0A     MOVLW 0xA
3A28  26E9     ADDWF FSR0, F, ACCESS
3A2A  0E00     MOVLW 0x0
3A2C  22EA     ADDWFC FSR0H, F, ACCESS
3A2E  50EF     MOVF INDF0, W, ACCESS
3A30  0B10     ANDLW 0x10
3A32  E002     BZ 0x3A38
101:                   return E_OS_STATE;
3A34  0E07     MOVLW 0x7
3A36  D002     BRA 0x3A3C
102:           
103:               return pData[0];
3A38  50DF     MOVF INDF2, W, ACCESS
3A3A  D000     BRA 0x3A3C
104:           }
3A3C  52E5     MOVF POSTDEC1, F, ACCESS
3A3E  52E5     MOVF POSTDEC1, F, ACCESS
3A40  CFE7     MOVFF INDF1, FSR2
3A42  FFD9     NOP
3A44  0012     RETURN 0
---  F:/PICOS18/TiltDetector/Kernel/int_man.c  ----------------------------------------------------------
1:             /**********************************************************************/
2:             /*                                                                    */
3:             /* File name: int_man.c                                               */
4:             /*                                                                    */
5:             /* Since:     2004-Sept-20                                            */
6:             /*                                                                    */
7:             /* Version:   PICos18 v3.00                                           */
8:             /*            Copyright (C) 2003, 2004, 2005 Pragmatec.               */
9:             /*                                                                    */
10:            /* Author:    Designed by Pragmatec S.A.R.L.        www.pragmatec.net */
11:            /*            MONTAGNE Xavier [XM]      xavier.montagne@pragmatec.net */
12:            /*                                                                    */
13:            /* Purpose:   Interrupt manager (set and clear interrupts)            */
14:            /*                                                                    */
15:            /* Distribution: This file is part of PICos18.                        */
16:            /*            PICos18 is free software; you can redistribute it       */
17:            /*            and/or modify it under the terms of the GNU General     */
18:            /*            Public License as published by the Free Software        */
19:            /*            Foundation; either version 2, or (at your option)       */
20:            /*            any later version.                                      */
21:            /*                                                                    */
22:            /*            PICos18 is distributed in the hope that it will be      */
23:            /*            useful, but WITHOUT ANY WARRANTY; without even the      */
24:            /*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
25:            /*            PARTICULAR PURPOSE.  See the GNU General Public         */
26:            /*            License for more details.                               */
27:            /*                                                                    */
28:            /*            You should have received a copy of the GNU General      */
29:            /*            Public License along with gpsim; see the file           */
30:            /*            COPYING.txt. If not, write to the Free Software         */
31:            /*            Foundation, 59 Temple Place - Suite 330,                */
32:            /*            Boston, MA 02111-1307, USA.                             */
33:            /*                                                                    */
34:            /*          > A special exception to the GPL can be applied should    */
35:            /*            you wish to distribute a combined work that includes    */
36:            /*            PICos18, without being obliged to provide the source    */
37:            /*            code for any proprietary components.                    */
38:            /*                                                                    */
39:            /* History:                                                           */
40:            /* 2004/09/20 [XM]  Create this file.                                 */
41:            /*                                                                    */
42:            /**********************************************************************/
43:            
44:            #include "device.h"
45:            
46:            extern unsigned char kernelState;
47:            #pragma udata KERNEL_RAM            /* ==> Changed allocate */
48:            unsigned char kernel_copy;
49:            
50:            /**********************************************************************
51:             * ROM area of the interrupt manager.
52:             *********************************************************************/
53:            #pragma		code	KERNEL_ROM
54:            
55:            /**********************************************************************
56:             * Set Global Interrupt Enable.
57:             *
58:             * @param void
59:             * @return void
60:             **********************************************************************/
61:            void EnableAllInterrupts(void)
62:            {
63:              INTCONbits.GIEH = 1;
0100  8EF2     BSF INTCON, 7, ACCESS
64:              INTCONbits.GIEL = 1;
0102  8CF2     BSF INTCON, 6, ACCESS
65:            }
0104  0012     RETURN 0
66:            
67:            /**********************************************************************
68:             * Clear Global Interrupt Enable.
69:             *
70:             * @param void
71:             * @return void
72:             **********************************************************************/
73:            void DisableAllInterrupts(void)
74:            {
75:              INTCONbits.GIEH = 0;
0106  9EF2     BCF INTCON, 7, ACCESS
76:              INTCONbits.GIEL = 0;
0108  9CF2     BCF INTCON, 6, ACCESS
77:            }
010A  0012     RETURN 0
78:            
79:            /**********************************************************************
80:             * Set Global Interrupt Enable.
81:             *
82:             * @param void
83:             * @return void
84:             **********************************************************************/
85:            void ResumeAllInterrupts(void)
86:            {
87:              INTCONbits.GIEH = 1;
010C  8EF2     BSF INTCON, 7, ACCESS
88:              INTCONbits.GIEL = 1;
010E  8CF2     BSF INTCON, 6, ACCESS
89:            }
0110  0012     RETURN 0
90:            
91:            /**********************************************************************
92:             * Clear Global Interrupt Enable.
93:             *
94:             * @param void
95:             * @return void
96:             **********************************************************************/
97:            void SuspendAllInterrupts(void)
98:            {
99:              INTCONbits.GIEH = 0;
0112  9EF2     BCF INTCON, 7, ACCESS
100:             INTCONbits.GIEL = 0;
0114  9CF2     BCF INTCON, 6, ACCESS
101:           }
0116  0012     RETURN 0
102:           
103:           /**********************************************************************
104:            * Set Global Interrupt Enable.
105:            *
106:            * @param void
107:            * @return void
108:            **********************************************************************/
109:           void ResumeOSInterrupts(void)
110:           {
111:             INTCONbits.GIEL = 1;
0118  8CF2     BSF INTCON, 6, ACCESS
112:           }
011A  0012     RETURN 0
113:           
114:           /**********************************************************************
115:            * Clear Global Interrupt Enable.
116:            *
117:            * @param void
118:            * @return void
119:            **********************************************************************/
120:           void SuspendOSInterrupts(void)
121:           {
122:             INTCONbits.GIEL = 0;
011C  9CF2     BCF INTCON, 6, ACCESS
123:           }
011E  0012     RETURN 0
124:           
125:           /**********************************************************************
126:            * Set the ISR settings to disble the Schedule function if called
127:            * during the ISR.
128:            *
129:            * @param void
130:            * @return void
131:            **********************************************************************/
132:           void EnterISR(void)
133:           {
134:             kernel_copy  = kernelState;
0120  C072     MOVFF kernelState, kernel_copy
0122  F06A     NOP
135:             kernelState |= ISR + CTX_SAVED;   /* ==> Added */
0124  0E0A     MOVLW 0xA
0126  0100     MOVLB 0x0
0128  1372     IORWF kernelState, F, BANKED
136:           }
012A  0012     RETURN 0
137:           
138:           /**********************************************************************
139:            * Restore the kernel state and enable the Schedule function:
140:            * if a service like SetEvent has been called by an ISR then the service
141:            * didn't schedule when it's called but at the end of the ISR, thanks to
142:            * the LeaveISR function.
143:            *
144:            * @param void
145:            * @return void
146:            **********************************************************************/
147:           void LeaveISR(void)
148:           {    
149:             if (kernelState & SERVICES)
012C  0100     MOVLB 0x0
012E  A572     BTFSS kernelState, 2, BANKED
0130  D007     BRA 0x140
150:             {
151:               kernelState = kernel_copy | CTX_SAVED;   /* ==> Added */
0132  0E08     MOVLW 0x8
0134  0100     MOVLB 0x0
0136  116A     IORWF kernel_copy, W, BANKED
0138  0100     MOVLB 0x0
013A  6F72     MOVWF kernelState, BANKED
152:               Schedule();
013C  EC07     CALL 0x120E, 0
013E  F009     NOP
153:             }
154:             kernelState = kernel_copy;
0140  C06A     MOVFF kernel_copy, kernelState
0142  F072     NOP
155:           }
0144  0012     RETURN 0
156:           
157:           
158:           /* End of File : int_man.c */
---  F:/PICOS18/TiltDetector/Kernel/PICos18iz.c  --------------------------------------------------------
1:             /* $Id: c018iz.c,v 1.3 2004/07/30 17:28:43 ConnerJ Exp $ */
2:             
3:             /* Copyright (c)1999 Microchip Technology */
4:             
5:             /* MPLAB-C18 startup code, including initialized data */
6:             
7:             /* external reference to the user's main routine */
8:             extern void main (void);
9:             /* prototype for the startup function */
10:            void _entry (void);
11:            void _startup (void);
12:            /* prototype for the initialized data setup */
13:            void _do_cinit (void);
14:            
15:            extern volatile near unsigned long short TBLPTR;
16:            extern near unsigned FSR0;
17:            extern near char FPFLAGS;
18:            #define RND 6
19:            
20:            #pragma code _entry_scn=0x000000
21:            void
22:            _entry (void)
23:            {
24:            
25:            
26:             		   _asm goto _startup _endasm}
0000  EFE1     GOTO 0x2FC2
0002  F017     NOP
0004  0012     RETURN 0
27:            #pragma code _startup_scn
28:            void
29:            _startup (void)
30:            {
31:              _asm
32:                // Initialize the stack pointer
33:                lfsr 1, _stack
2FC2  EE17     LFSR 1, 0x700
2FC4  F000     NOP
34:                lfsr 2, _stack
2FC6  EE27     LFSR 2, 0x700
2FC8  F000     NOP
35:            
36:                clrf TBLPTRU, 0 // 1st silicon doesn't do this on POR
2FCA  6AF8     CLRF TBLPTRU, ACCESS
37:            
38:                bcf __FPFLAGS,RND,0
2FCC  9C0F     BCF 0xF, 6, ACCESS
39:                
40:                /*** Set all of memory to zeroes ***/
41:                // Use FSR0 to decrement through memory from the top of bank 14 down to address 0x0
42:                movlw 0xff
2FCE  0EFF     MOVLW 0xFF
43:                movwf FSR0L, 0
2FD0  6EE9     MOVWF FSR0, ACCESS
44:                movlw 0x0e
2FD2  0E0E     MOVLW 0xE
45:                movwf FSR0H, 0
2FD4  6EEA     MOVWF FSR0H, ACCESS
46:            
47:                // Use memory location 0x0 as a indicator when we have reached the end
48:                movlw 1
2FD6  0E01     MOVLW 0x1
49:                movwf 0x0, 0
2FD8  6E00     MOVWF index, ACCESS
50:            
51:                // Load WREG with the value to be stored throughout memory (0)
52:                movlw 0
2FDA  0E00     MOVLW 0x0
53:            
54:              clear_loop:
55:                movwf POSTDEC0, 0
2FDC  6EED     MOVWF POSTDEC0, ACCESS
56:                movf  0x0,1,0
2FDE  5200     MOVF index, F, ACCESS
57:                bnz   clear_loop
2FE0  E1FD     BNZ 0x2FDC
58:            
59:                _endasm _do_cinit ();
2FE2  EC23     CALL 0x3A46, 0
2FE4  F01D     NOP
60:            
61:            loop:
62:            
63:              // Call the user's main routine
64:              main ();
2FE6  ECB6     CALL 0x356C, 0
2FE8  F01A     NOP
65:            
66:              goto loop;
2FEA  D7FD     BRA 0x2FE6
67:            }                               /* end _startup() */
2FEC  0012     RETURN 0
68:            
69:            /* MPLAB-C18 initialized data memory support */
70:            /* The linker will populate the _cinit table */
71:            extern far rom struct
72:            {
73:              unsigned short num_init;
74:              struct _init_entry
75:              {
76:                unsigned long from;
77:                unsigned long to;
78:                unsigned long size;
79:              }
80:              entries[];
81:            }
82:            _cinit;
83:            
84:            #pragma  udata   KERNEL_RAM 
85:              static short long prom; 
86:              static unsigned short curr_byte; 
87:              static unsigned short curr_entry; 
88:              static short long data_ptr;
89:            #pragma  udata
90:            
91:            #pragma code _cinit_scn
92:            void
93:            _do_cinit (void)
94:            {
95:              /* we'll make the assumption in the following code that these statics
96:               * will be allocated into the same bank.
97:               */
98:            
99:              // Initialized data...
100:             TBLPTR = (short long)&_cinit;
3A46  0E16     MOVLW 0x16
3A48  6EF6     MOVWF TBLPTR, ACCESS
3A4A  0E35     MOVLW 0x35
3A4C  6EF7     MOVWF TBLPTRH, ACCESS
3A4E  0E00     MOVLW 0x0
3A50  6EF8     MOVWF TBLPTRU, ACCESS
101:             _asm
102:               movlb data_ptr
3A52  0100     MOVLB 0x0
103:               tblrdpostinc
3A54  0009     TBLRD*+
104:               movf TABLAT, 0, 0
3A56  50F5     MOVF TABLAT, W, ACCESS
105:               movwf curr_entry, 1
3A58  6F65     MOVWF curr_entry, BANKED
106:               tblrdpostinc
3A5A  0009     TBLRD*+
107:               movf TABLAT, 0, 0
3A5C  50F5     MOVF TABLAT, W, ACCESS
108:               movwf curr_entry+1, 1
3A5E  6F66     MOVWF 0x66, BANKED
109:             _endasm
110:               //while (curr_entry)
111:               //{
112:               test:
113:               _asm
114:                bnz 3
3A60  E103     BNZ 0x3A68
115:               tstfsz curr_entry, 1
3A62  6765     TSTFSZ curr_entry, BANKED
116:               bra 1
3A64  D001     BRA 0x3A68
117:               _endasm
118:               goto done;
3A66  D03D     BRA 0x3AE2
119:                 /* Count down so we only have to look up the data in _cinit
120:                  * once.
121:                  *
122:                  * At this point we know that TBLPTR points to the top of the current
123:                  * entry in _cinit, so we can just start reading the from, to, and
124:                  * size values.
125:                  */
126:                 _asm
127:           	/* read the source address */
128:           	tblrdpostinc
3A68  0009     TBLRD*+
129:           	movf TABLAT, 0, 0
3A6A  50F5     MOVF TABLAT, W, ACCESS
130:           	movwf prom, 1
3A6C  6F60     MOVWF prom, BANKED
131:           	tblrdpostinc
3A6E  0009     TBLRD*+
132:           	movf TABLAT, 0, 0
3A70  50F5     MOVF TABLAT, W, ACCESS
133:           	movwf prom+1, 1
3A72  6F61     MOVWF 0x61, BANKED
134:           	tblrdpostinc
3A74  0009     TBLRD*+
135:           	movf TABLAT, 0, 0
3A76  50F5     MOVF TABLAT, W, ACCESS
136:           	movwf prom+2, 1
3A78  6F62     MOVWF 0x62, BANKED
137:           	/* skip a byte since it's stored as a 32bit int */
138:           	tblrdpostinc
3A7A  0009     TBLRD*+
139:           	/* read the destination address directly into FSR0 */
140:           	tblrdpostinc
3A7C  0009     TBLRD*+
141:           	movf TABLAT, 0, 0
3A7E  50F5     MOVF TABLAT, W, ACCESS
142:           	movwf FSR0L, 0
3A80  6EE9     MOVWF FSR0, ACCESS
143:           	tblrdpostinc
3A82  0009     TBLRD*+
144:           	movf TABLAT, 0, 0
3A84  50F5     MOVF TABLAT, W, ACCESS
145:           	movwf FSR0H, 0
3A86  6EEA     MOVWF FSR0H, ACCESS
146:           	/* skip two bytes since it's stored as a 32bit int */
147:           	tblrdpostinc
3A88  0009     TBLRD*+
148:           	tblrdpostinc
3A8A  0009     TBLRD*+
149:           	/* read the destination address directly into FSR0 */
150:           	tblrdpostinc
3A8C  0009     TBLRD*+
151:           	movf TABLAT, 0, 0
3A8E  50F5     MOVF TABLAT, W, ACCESS
152:           	movwf curr_byte, 1
3A90  6F63     MOVWF curr_byte, BANKED
153:           	tblrdpostinc
3A92  0009     TBLRD*+
154:           	movf TABLAT, 0, 0
3A94  50F5     MOVF TABLAT, W, ACCESS
155:           	movwf curr_byte+1, 1
3A96  6F64     MOVWF 0x64, BANKED
156:           	/* skip two bytes since it's stored as a 32bit int */
157:           	tblrdpostinc
3A98  0009     TBLRD*+
158:           	tblrdpostinc
3A9A  0009     TBLRD*+
159:                 _endasm  
160:                 //prom = data_ptr->from;
161:                 //FSR0 = data_ptr->to;
162:                 //curr_byte = (unsigned short) data_ptr->size;
163:                 /* the table pointer now points to the next entry. Save it
164:                  * off since we'll be using the table pointer to do the copying
165:                  * for the entry.
166:                  */
167:                 data_ptr = TBLPTR;
3A9C  CFF6     MOVFF TBLPTR, data_ptr
3A9E  F067     NOP
3AA0  CFF7     MOVFF TBLPTRH, 0x68
3AA2  F068     NOP
3AA4  CFF8     MOVFF TBLPTRU, 0x69
3AA6  F069     NOP
168:                 
169:                 /* now assign the source address to the table pointer */
170:                 TBLPTR = prom;
3AA8  C060     MOVFF prom, TBLPTR
3AAA  FFF6     NOP
3AAC  C061     MOVFF 0x61, TBLPTRH
3AAE  FFF7     NOP
3AB0  C062     MOVFF 0x62, TBLPTRU
3AB2  FFF8     NOP
171:           
172:                 /* do the copy loop */
173:                 _asm
174:                   // determine if we have any more bytes to copy
175:           	movlb curr_byte
3AB4  0100     MOVLB 0x0
176:           	movf curr_byte, 1, 1
3AB6  5363     MOVF curr_byte, F, BANKED
177:           copy_loop:
178:           	bnz 2 // copy_one_byte
3AB8  E102     BNZ 0x3ABE
179:           	movf curr_byte + 1, 1, 1
3ABA  5364     MOVF 0x64, F, BANKED
180:           	bz 7 // done_copying
3ABC  E007     BZ 0x3ACC
181:           
182:           copy_one_byte:
183:           	tblrdpostinc
3ABE  0009     TBLRD*+
184:           	movf TABLAT, 0, 0
3AC0  50F5     MOVF TABLAT, W, ACCESS
185:           	movwf POSTINC0, 0
3AC2  6EEE     MOVWF POSTINC0, ACCESS
186:           
187:           	// decrement byte counter
188:           	decf curr_byte, 1, 1
3AC4  0763     DECF curr_byte, F, BANKED
189:           	bc -8 // copy_loop
3AC6  E2F8     BC 0x3AB8
190:                   decf curr_byte + 1, 1, 1
3AC8  0764     DECF 0x64, F, BANKED
191:           	bra -7 // copy_one_byte
3ACA  D7F9     BRA 0x3ABE
192:           
193:           done_copying:
194:           
195:                 _endasm
196:                 /* restore the table pointer for the next entry */
197:                 TBLPTR = data_ptr;
3ACC  C067     MOVFF data_ptr, TBLPTR
3ACE  FFF6     NOP
3AD0  C068     MOVFF 0x68, TBLPTRH
3AD2  FFF7     NOP
3AD4  C069     MOVFF 0x69, TBLPTRU
3AD6  FFF8     NOP
198:                 /* next entry... */
199:                 curr_entry--;
3AD8  0100     MOVLB 0x0
3ADA  0765     DECF curr_entry, F, BANKED
3ADC  0E00     MOVLW 0x0
3ADE  5B66     SUBWFB 0x66, F, BANKED
200:                 goto test;
3AE0  D7BF     BRA 0x3A60
201:           done:
202:           ;
203:           }
3AE2  0012     RETURN 0
---  F:/PICOS18/Kernel/pro_man.c  -----------------------------------------------------------------------
1:             /**********************************************************************/
2:             /*                                                                    */
3:             /* File name: pro_man.c                                               */
4:             /*                                                                    */
5:             /* Since:     2004-Sept-20                                            */
6:             /*                                                                    */
7:             /* Version:   PICos18 v3.00                                           */
8:             /*            Copyright (C) 2003, 2004, 2005 Pragmatec.               */
9:             /*                                                                    */
10:            /* Author:    Designed by Pragmatec S.A.R.L.        www.pragmatec.net */
11:            /*            MONTAGNE Xavier [XM]      xavier.montagne@pragmatec.net */
12:            /*                                                                    */
13:            /* Purpose:   The process manager is in charge of changing or giving  */
14:            /*            the state of the different tasks, and also of starting  */
15:            /*            or stopping the kernel.                                 */
16:            /*                                                                    */
17:            /* Distribution: This file is part of PICos18.                        */
18:            /*            PICos18 is free software; you can redistribute it       */
19:            /*            and/or modify it under the terms of the GNU General     */
20:            /*            Public License as published by the Free Software        */
21:            /*            Foundation; either version 2, or (at your option)       */
22:            /*            any later version.                                      */
23:            /*                                                                    */
24:            /*            PICos18 is distributed in the hope that it will be      */
25:            /*            useful, but WITHOUT ANY WARRANTY; without even the      */
26:            /*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
27:            /*            PARTICULAR PURPOSE.  See the GNU General Public         */
28:            /*            License for more details.                               */
29:            /*                                                                    */
30:            /*            You should have received a copy of the GNU General      */
31:            /*            Public License along with gpsim; see the file           */
32:            /*            COPYING.txt. If not, write to the Free Software         */
33:            /*            Foundation, 59 Temple Place - Suite 330,                */
34:            /*            Boston, MA 02111-1307, USA.                             */
35:            /*                                                                    */
36:            /*          > A special exception to the GPL can be applied should    */
37:            /*            you wish to distribute a combined work that includes    */
38:            /*            PICos18, without being obliged to provide the source    */
39:            /*            code for any proprietary components.                    */
40:            /*                                                                    */
41:            /* History:                                                           */
42:            /* 2004/09/20 [XM]  Create this file.                                 */
43:            /* 2006/01/18 [XM]  Removed the temp variables (JohnG improvment).    */
44:            /* 2006/07/31 [XM]  Fixed bug in TerminateTask (MASK_ID<->MASK_STATE).*/
45:            /*                                                                    */
46:            /**********************************************************************/
47:            
48:            #include "device.h"
49:            
50:            /**********************************************************************
51:             * Shared variables defined in other section.
52:             **********************************************************************/
53:            extern char id_tsk_run;
54:            extern char kernelState;
55:            extern void _kernel(void);
56:            extern void _restore_start_adr(void);
57:            extern void _restore_now(void);
58:            
59:            /**********************************************************************
60:             * Functions declared in other sections.
61:             **********************************************************************/
62:            #ifdef	SHUTDOWNHOOK
63:            	extern void ShutdownHook(StatusType Error);
64:            #endif
65:            
66:            #ifdef	ERRORHOOK
67:            	extern void ErrorHook(StatusType Error);
68:            #endif
69:            
70:            extern Resource Resource_list[];
71:            extern unsigned char RESOURCENUMBER;
72:            
73:            unsigned char FSR1H_MAIN;
74:            unsigned char FSR1L_MAIN;
75:            unsigned char appmode;
76:            #pragma udata KERNEL_RAM
77:            unsigned char stack_low, stack_high;   /* ==> Change allocated */
78:            
79:            
80:            /**********************************************************************
81:             * RAM area of the stack field of a task.
82:             **********************************************************************/
83:            #pragma		udata	STACK_RAM=0x00A0
84:            TaskType tsk_1_state_ID;
85:            TaskType tsk_2_state_ID;
86:            TaskType tsk_3_state_ID;
87:            TaskType tsk_4_state_ID;
88:            TaskType tsk_5_state_ID;
89:            TaskType tsk_6_state_ID;
90:            TaskType tsk_7_state_ID;
91:            TaskType tsk_8_state_ID;
92:            TaskType tsk_9_state_ID;
93:            TaskType tsk_10_state_ID;
94:            TaskType tsk_11_state_ID;
95:            TaskType tsk_12_state_ID;
96:            TaskType tsk_13_state_ID;
97:            TaskType tsk_14_state_ID;
98:            TaskType tsk_15_state_ID;
99:            TaskType tsk_16_state_ID;
100:           
101:           /**********************************************************************
102:            * RAM area of the state field of the task.
103:            **********************************************************************/
104:           #pragma		udata	STATE_RAM=0x00B0
105:           TaskType tsk_1_activ_prio;
106:           TaskType tsk_2_activ_prio;
107:           TaskType tsk_3_activ_prio;
108:           TaskType tsk_4_activ_prio;
109:           TaskType tsk_5_activ_prio;
110:           TaskType tsk_6_activ_prio;
111:           TaskType tsk_7_activ_prio;
112:           TaskType tsk_8_activ_prio;
113:           TaskType tsk_9_activ_prio;
114:           TaskType tsk_10_activ_prio;
115:           TaskType tsk_11_activ_prio;
116:           TaskType tsk_12_activ_prio;
117:           TaskType tsk_13_activ_prio;
118:           TaskType tsk_14_activ_prio;
119:           TaskType tsk_15_activ_prio;
120:           TaskType tsk_16_activ_prio;
121:           
122:           /**********************************************************************
123:            * ROM area of the process manager.
124:            **********************************************************************/
125:           #pragma		code	KERNEL_ROM
126:           
127:           /**********************************************************************
128:            * Modify the priority of a task.
129:            * Not mandatory by OSEK standart.
130:            *
131:            * @param new_prio   IN  New value of the task priority
132:            * @param TaskID     IN  ID of the task
133:            * @return Status    E_OK if the task ID is correct
134:            *                   E_OS_ID otherwise
135:            **********************************************************************/
136:           StatusType SetPriority (unsigned char new_prio, TaskType TaskID)
0CE0  CFD9     MOVFF FSR2, POSTINC1
0CE2  FFE6     NOP
0CE4  CFDA     MOVFF FSR2H, POSTINC1
0CE6  FFE6     NOP
0CE8  CFE1     MOVFF FSR1, FSR2
0CEA  FFD9     NOP
0CEC  CFE2     MOVFF FSR1H, FSR2H
0CEE  FFDA     NOP
0CF0  52E6     MOVF POSTINC1, F, ACCESS
0CF2  52E6     MOVF POSTINC1, F, ACCESS
0CF4  52E6     MOVF POSTINC1, F, ACCESS
137:           {
138:             unsigned char i;
139:             TaskRefType ptr_task;
140:           
141:             ptr_task = (TaskRefType)&tsk_1_state_ID; 
0CF6  50D9     MOVF FSR2, W, ACCESS
0CF8  0F01     ADDLW 0x1
0CFA  6EE9     MOVWF FSR0, ACCESS
0CFC  CFDA     MOVFF FSR2H, FSR0H
0CFE  FFEA     NOP
0D00  0E00     MOVLW 0x0
0D02  22EA     ADDWFC FSR0H, F, ACCESS
0D04  0EA0     MOVLW 0xA0
0D06  6EEE     MOVWF POSTINC0, ACCESS
0D08  0E00     MOVLW 0x0
0D0A  6EED     MOVWF POSTDEC0, ACCESS
142:           
143:             for (i = 0; i < MAX_TASK_NB; i++)
0D0C  6ADF     CLRF INDF2, ACCESS
0D0E  0E10     MOVLW 0x10
0D10  5CDF     SUBWF INDF2, W, ACCESS
0D12  E23D     BC 0xD8E
0D8A  2ADF     INCF INDF2, F, ACCESS
0D8C  D7C0     BRA 0xD0E
144:             {
145:               if ( (*ptr_task & MASK_PRIO) == TaskID )
0D14  0E01     MOVLW 0x1
0D16  CFDB     MOVFF PLUSW2, FSR0
0D18  FFE9     NOP
0D1A  0E02     MOVLW 0x2
0D1C  CFDB     MOVFF PLUSW2, FSR0H
0D1E  FFEA     NOP
0D20  50EF     MOVF INDF0, W, ACCESS
0D22  0B0F     ANDLW 0xF
0D24  6E14     MOVWF __tmp_0, ACCESS
0D26  0EFC     MOVLW 0xFC
0D28  50DB     MOVF PLUSW2, W, ACCESS
0D2A  5C14     SUBWF __tmp_0, W, ACCESS
0D2C  E129     BNZ 0xD80
146:               {
147:           	  ptr_task   = &tsk_1_activ_prio + i;
0D2E  50DF     MOVF INDF2, W, ACCESS
0D30  6A15     CLRF 0x15, ACCESS
0D32  0FB0     ADDLW 0xB0
0D34  6E14     MOVWF __tmp_0, ACCESS
0D36  0E00     MOVLW 0x0
0D38  2215     ADDWFC 0x15, F, ACCESS
0D3A  0E01     MOVLW 0x1
0D3C  C014     MOVFF __tmp_0, PLUSW2
0D3E  FFDB     NOP
0D40  0E02     MOVLW 0x2
0D42  C015     MOVFF 0x15, PLUSW2
0D44  FFDB     NOP
148:           	  *ptr_task  = *ptr_task & MASK_ACTIV;
0D46  0E01     MOVLW 0x1
0D48  CFDB     MOVFF PLUSW2, FSR0
0D4A  FFE9     NOP
0D4C  0E02     MOVLW 0x2
0D4E  CFDB     MOVFF PLUSW2, FSR0H
0D50  FFEA     NOP
0D52  50EF     MOVF INDF0, W, ACCESS
0D54  0BF0     ANDLW 0xF0
0D56  6EE6     MOVWF POSTINC1, ACCESS
0D58  0E01     MOVLW 0x1
0D5A  CFDB     MOVFF PLUSW2, FSR0
0D5C  FFE9     NOP
0D5E  0E02     MOVLW 0x2
0D60  CFDB     MOVFF PLUSW2, FSR0H
0D62  FFEA     NOP
0D64  52E5     MOVF POSTDEC1, F, ACCESS
0D66  50E7     MOVF INDF1, W, ACCESS
0D68  6EEF     MOVWF INDF0, ACCESS
149:                 *ptr_task += new_prio;
0D6A  0E01     MOVLW 0x1
0D6C  CFDB     MOVFF PLUSW2, FSR0
0D6E  FFE9     NOP
0D70  0E02     MOVLW 0x2
0D72  CFDB     MOVFF PLUSW2, FSR0H
0D74  FFEA     NOP
0D76  0EFD     MOVLW 0xFD
0D78  50DB     MOVF PLUSW2, W, ACCESS
0D7A  26EF     ADDWF INDF0, F, ACCESS
150:                 return (E_OK);
0D7C  0E00     MOVLW 0x0
0D7E  D009     BRA 0xD92
151:               }
152:               ptr_task++;
0D80  0E01     MOVLW 0x1
0D82  2ADB     INCF PLUSW2, F, ACCESS
0D84  0E02     MOVLW 0x2
0D86  E301     BNC 0xD8A
0D88  2ADB     INCF PLUSW2, F, ACCESS
153:             }
154:           
155:             return (E_OS_ID);
0D8E  0E03     MOVLW 0x3
0D90  D000     BRA 0xD92
156:           }
0D92  52E5     MOVF POSTDEC1, F, ACCESS
0D94  52E5     MOVF POSTDEC1, F, ACCESS
0D96  52E5     MOVF POSTDEC1, F, ACCESS
0D98  52E5     MOVF POSTDEC1, F, ACCESS
0D9A  CFE5     MOVFF POSTDEC1, FSR2H
0D9C  FFDA     NOP
0D9E  CFE7     MOVFF INDF1, FSR2
0DA0  FFD9     NOP
0DA2  0012     RETURN 0
157:           
158:           /**********************************************************************
159:            * Modify the priority of a task.
160:            * Not mandatory by OSEK standart.
161:            *
162:            * @param new_prio   IN  New value of the task priority
163:            * @param TaskID     IN  ID of the task
164:            * @return Status    E_OK if the task ID is correct
165:            *                   E_OS_ID otherwise
166:            **********************************************************************/
167:           StatusType GetPriority (unsigned char *the_prio, TaskType TaskID)
0DA4  CFD9     MOVFF FSR2, POSTINC1
0DA6  FFE6     NOP
0DA8  CFDA     MOVFF FSR2H, POSTINC1
0DAA  FFE6     NOP
0DAC  CFE1     MOVFF FSR1, FSR2
0DAE  FFD9     NOP
0DB0  CFE2     MOVFF FSR1H, FSR2H
0DB2  FFDA     NOP
0DB4  52E6     MOVF POSTINC1, F, ACCESS
0DB6  52E6     MOVF POSTINC1, F, ACCESS
0DB8  52E6     MOVF POSTINC1, F, ACCESS
168:           {
169:             unsigned char i;
170:             TaskRefType ptr_task;
171:           
172:             ptr_task = (TaskRefType)&tsk_1_state_ID; 
0DBA  50D9     MOVF FSR2, W, ACCESS
0DBC  0F01     ADDLW 0x1
0DBE  6EE9     MOVWF FSR0, ACCESS
0DC0  CFDA     MOVFF FSR2H, FSR0H
0DC2  FFEA     NOP
0DC4  0E00     MOVLW 0x0
0DC6  22EA     ADDWFC FSR0H, F, ACCESS
0DC8  0EA0     MOVLW 0xA0
0DCA  6EEE     MOVWF POSTINC0, ACCESS
0DCC  0E00     MOVLW 0x0
0DCE  6EED     MOVWF POSTDEC0, ACCESS
173:           
174:             for (i = 0; i < MAX_TASK_NB; i++)
0DD0  6ADF     CLRF INDF2, ACCESS
0DD2  0E10     MOVLW 0x10
0DD4  5CDF     SUBWF INDF2, W, ACCESS
0DD6  E234     BC 0xE40
0E3C  2ADF     INCF INDF2, F, ACCESS
0E3E  D7C9     BRA 0xDD2
175:             {
176:               if ( (*ptr_task & MASK_ID) == TaskID )
0DD8  0E01     MOVLW 0x1
0DDA  CFDB     MOVFF PLUSW2, FSR0
0DDC  FFE9     NOP
0DDE  0E02     MOVLW 0x2
0DE0  CFDB     MOVFF PLUSW2, FSR0H
0DE2  FFEA     NOP
0DE4  50EF     MOVF INDF0, W, ACCESS
0DE6  0B0F     ANDLW 0xF
0DE8  6E14     MOVWF __tmp_0, ACCESS
0DEA  0EFB     MOVLW 0xFB
0DEC  50DB     MOVF PLUSW2, W, ACCESS
0DEE  5C14     SUBWF __tmp_0, W, ACCESS
0DF0  E120     BNZ 0xE32
177:               {
178:           	  ptr_task   = &tsk_1_activ_prio + i;
0DF2  50DF     MOVF INDF2, W, ACCESS
0DF4  6A15     CLRF 0x15, ACCESS
0DF6  0FB0     ADDLW 0xB0
0DF8  6E14     MOVWF __tmp_0, ACCESS
0DFA  0E00     MOVLW 0x0
0DFC  2215     ADDWFC 0x15, F, ACCESS
0DFE  0E01     MOVLW 0x1
0E00  C014     MOVFF __tmp_0, PLUSW2
0E02  FFDB     NOP
0E04  0E02     MOVLW 0x2
0E06  C015     MOVFF 0x15, PLUSW2
0E08  FFDB     NOP
179:                 *the_prio  = *ptr_task & MASK_PRIO;
0E0A  0E01     MOVLW 0x1
0E0C  CFDB     MOVFF PLUSW2, FSR0
0E0E  FFE9     NOP
0E10  0E02     MOVLW 0x2
0E12  CFDB     MOVFF PLUSW2, FSR0H
0E14  FFEA     NOP
0E16  50EF     MOVF INDF0, W, ACCESS
0E18  0B0F     ANDLW 0xF
0E1A  6EE6     MOVWF POSTINC1, ACCESS
0E1C  0EFC     MOVLW 0xFC
0E1E  CFDB     MOVFF PLUSW2, FSR0
0E20  FFE9     NOP
0E22  0EFD     MOVLW 0xFD
0E24  CFDB     MOVFF PLUSW2, FSR0H
0E26  FFEA     NOP
0E28  52E5     MOVF POSTDEC1, F, ACCESS
0E2A  50E7     MOVF INDF1, W, ACCESS
0E2C  6EEF     MOVWF INDF0, ACCESS
180:                 return (E_OK);
0E2E  0E00     MOVLW 0x0
0E30  D009     BRA 0xE44
181:               }
182:               ptr_task++;
0E32  0E01     MOVLW 0x1
0E34  2ADB     INCF PLUSW2, F, ACCESS
0E36  0E02     MOVLW 0x2
0E38  E301     BNC 0xE3C
0E3A  2ADB     INCF PLUSW2, F, ACCESS
183:             }
184:           
185:             return (E_OS_ID);
0E40  0E03     MOVLW 0x3
0E42  D000     BRA 0xE44
186:           }
0E44  52E5     MOVF POSTDEC1, F, ACCESS
0E46  52E5     MOVF POSTDEC1, F, ACCESS
0E48  52E5     MOVF POSTDEC1, F, ACCESS
0E4A  52E5     MOVF POSTDEC1, F, ACCESS
0E4C  CFE5     MOVFF POSTDEC1, FSR2H
0E4E  FFDA     NOP
0E50  CFE7     MOVFF INDF1, FSR2
0E52  FFD9     NOP
0E54  0012     RETURN 0
187:           
188:           /**********************************************************************
189:            * Set id_tsk_run into TaskID or INVALID_TASK (0x10) if the ID is out 
190:            * of range.
191:            *
192:            * @param TaskID     IN  Reference of the task
193:            * @return status    Always E_OK 
194:            **********************************************************************/
195:           StatusType GetTaskID (TaskRefType TaskID)
0E56  CFD9     MOVFF FSR2, POSTINC1
0E58  FFE6     NOP
0E5A  CFDA     MOVFF FSR2H, POSTINC1
0E5C  FFE6     NOP
0E5E  CFE1     MOVFF FSR1, FSR2
0E60  FFD9     NOP
0E62  CFE2     MOVFF FSR1H, FSR2H
0E64  FFDA     NOP
196:           {
197:             if ( (id_tsk_run >= 0) && (id_tsk_run < MAX_TASK_NB) )
0E66  0100     MOVLB 0x0
0E68  356D     RLCF id_tsk_run, W, BANKED
0E6A  E214     BC 0xE94
0E6C  0E10     MOVLW 0x10
0E6E  0100     MOVLB 0x0
0E70  6EE7     MOVWF INDF1, ACCESS
0E72  196D     XORWF id_tsk_run, W, BANKED
0E74  AEE8     BTFSS WREG, 7, ACCESS
0E76  D002     BRA 0xE7C
0E78  34E7     RLCF INDF1, W, ACCESS
0E7A  D002     BRA 0xE80
0E7C  50E7     MOVF INDF1, W, ACCESS
0E7E  5D6D     SUBWF id_tsk_run, W, BANKED
0E80  E209     BC 0xE94
198:               *TaskID = (TaskType)id_tsk_run;
0E82  0EFC     MOVLW 0xFC
0E84  CFDB     MOVFF PLUSW2, FSR0
0E86  FFE9     NOP
0E88  0EFD     MOVLW 0xFD
0E8A  CFDB     MOVFF PLUSW2, FSR0H
0E8C  FFEA     NOP
0E8E  C06D     MOVFF id_tsk_run, INDF0
0E90  FFEF     NOP
199:             else
0E92  D008     BRA 0xEA4
200:               *TaskID = (TaskType)INVALID_TASK;
0E94  0EFC     MOVLW 0xFC
0E96  CFDB     MOVFF PLUSW2, FSR0
0E98  FFE9     NOP
0E9A  0EFD     MOVLW 0xFD
0E9C  CFDB     MOVFF PLUSW2, FSR0H
0E9E  FFEA     NOP
0EA0  0E10     MOVLW 0x10
0EA2  6EEF     MOVWF INDF0, ACCESS
201:           
202:             return (E_OK);
0EA4  0E00     MOVLW 0x0
0EA6  D000     BRA 0xEA8
203:           }
0EA8  52E5     MOVF POSTDEC1, F, ACCESS
0EAA  CFE5     MOVFF POSTDEC1, FSR2H
0EAC  FFDA     NOP
0EAE  CFE7     MOVFF INDF1, FSR2
0EB0  FFD9     NOP
0EB2  0012     RETURN 0
204:           
205:           /**********************************************************************
206:            * Copy a byte into a buffer.
207:            *
208:            * @param TaksID     IN  ID of the task 
209:            * @param State      OUT Reference of the task state
210:            * @return Status    E_OK if the task ID is correct
211:            *                   E_OS_ID otherwise
212:            **********************************************************************/
213:           StatusType GetTaskState (TaskType TaskID, TaskStateRefType State)
0EB4  CFD9     MOVFF FSR2, POSTINC1
0EB6  FFE6     NOP
0EB8  CFDA     MOVFF FSR2H, POSTINC1
0EBA  FFE6     NOP
0EBC  CFE1     MOVFF FSR1, FSR2
0EBE  FFD9     NOP
0EC0  CFE2     MOVFF FSR1H, FSR2H
0EC2  FFDA     NOP
0EC4  52E6     MOVF POSTINC1, F, ACCESS
0EC6  52E6     MOVF POSTINC1, F, ACCESS
0EC8  52E6     MOVF POSTINC1, F, ACCESS
214:           {
215:             unsigned char i;
216:             TaskRefType ptr_task;
217:           
218:             ptr_task = (TaskRefType)&tsk_1_state_ID; 
0ECA  50D9     MOVF FSR2, W, ACCESS
0ECC  0F01     ADDLW 0x1
0ECE  6EE9     MOVWF FSR0, ACCESS
0ED0  CFDA     MOVFF FSR2H, FSR0H
0ED2  FFEA     NOP
0ED4  0E00     MOVLW 0x0
0ED6  22EA     ADDWFC FSR0H, F, ACCESS
0ED8  0EA0     MOVLW 0xA0
0EDA  6EEE     MOVWF POSTINC0, ACCESS
0EDC  0E00     MOVLW 0x0
0EDE  6EED     MOVWF POSTDEC0, ACCESS
219:           
220:             for (i = 0; i < MAX_TASK_NB; i++)
0EE0  6ADF     CLRF INDF2, ACCESS
0EE2  0E10     MOVLW 0x10
0EE4  5CDF     SUBWF INDF2, W, ACCESS
0EE6  E228     BC 0xF38
0F34  2ADF     INCF INDF2, F, ACCESS
0F36  D7D5     BRA 0xEE2
221:             {
222:               if ( (*ptr_task & MASK_ID) == TaskID )
0EE8  0E01     MOVLW 0x1
0EEA  CFDB     MOVFF PLUSW2, FSR0
0EEC  FFE9     NOP
0EEE  0E02     MOVLW 0x2
0EF0  CFDB     MOVFF PLUSW2, FSR0H
0EF2  FFEA     NOP
0EF4  50EF     MOVF INDF0, W, ACCESS
0EF6  0B0F     ANDLW 0xF
0EF8  6E14     MOVWF __tmp_0, ACCESS
0EFA  0EFD     MOVLW 0xFD
0EFC  50DB     MOVF PLUSW2, W, ACCESS
0EFE  5C14     SUBWF __tmp_0, W, ACCESS
0F00  E114     BNZ 0xF2A
223:               {
224:                 *State = (TaskStateType)(*ptr_task & MASK_STATE);
0F02  0E01     MOVLW 0x1
0F04  CFDB     MOVFF PLUSW2, FSR0
0F06  FFE9     NOP
0F08  0E02     MOVLW 0x2
0F0A  CFDB     MOVFF PLUSW2, FSR0H
0F0C  FFEA     NOP
0F0E  50EF     MOVF INDF0, W, ACCESS
0F10  0BE0     ANDLW 0xE0
0F12  6EE6     MOVWF POSTINC1, ACCESS
0F14  0EFB     MOVLW 0xFB
0F16  CFDB     MOVFF PLUSW2, FSR0
0F18  FFE9     NOP
0F1A  0EFC     MOVLW 0xFC
0F1C  CFDB     MOVFF PLUSW2, FSR0H
0F1E  FFEA     NOP
0F20  52E5     MOVF POSTDEC1, F, ACCESS
0F22  50E7     MOVF INDF1, W, ACCESS
0F24  6EEF     MOVWF INDF0, ACCESS
225:                 return (E_OK);
0F26  0E00     MOVLW 0x0
0F28  D009     BRA 0xF3C
226:               }
227:               ptr_task++;
0F2A  0E01     MOVLW 0x1
0F2C  2ADB     INCF PLUSW2, F, ACCESS
0F2E  0E02     MOVLW 0x2
0F30  E301     BNC 0xF34
0F32  2ADB     INCF PLUSW2, F, ACCESS
228:             }
229:           
230:             return (E_OS_ID);
0F38  0E03     MOVLW 0x3
0F3A  D000     BRA 0xF3C
231:           }
0F3C  52E5     MOVF POSTDEC1, F, ACCESS
0F3E  52E5     MOVF POSTDEC1, F, ACCESS
0F40  52E5     MOVF POSTDEC1, F, ACCESS
0F42  52E5     MOVF POSTDEC1, F, ACCESS
0F44  CFE5     MOVFF POSTDEC1, FSR2H
0F46  FFDA     NOP
0F48  CFE7     MOVFF INDF1, FSR2
0F4A  FFD9     NOP
0F4C  0012     RETURN 0
232:           
233:           /**********************************************************************
234:            * Set the task to the READY state and call the scheduler to jump to 
235:            * another task if necessary.
236:            *
237:            * @param TaskID     IN  ID of the task
238:            * @return Status    E_OS_ID if ID is not correct
239:            *                   never return otherwise
240:            **********************************************************************/
241:           StatusType ActivateTask (TaskType TaskID)
0F4E  CFD9     MOVFF FSR2, POSTINC1
0F50  FFE6     NOP
0F52  CFDA     MOVFF FSR2H, POSTINC1
0F54  FFE6     NOP
0F56  CFE1     MOVFF FSR1, FSR2
0F58  FFD9     NOP
0F5A  CFE2     MOVFF FSR1H, FSR2H
0F5C  FFDA     NOP
0F5E  52E6     MOVF POSTINC1, F, ACCESS
0F60  52E6     MOVF POSTINC1, F, ACCESS
0F62  52E6     MOVF POSTINC1, F, ACCESS
242:           {
243:             unsigned char i;
244:             TaskRefType ptr_task;
245:           
246:             ptr_task = (TaskRefType)&tsk_1_state_ID; 
0F64  50D9     MOVF FSR2, W, ACCESS
0F66  0F01     ADDLW 0x1
0F68  6EE9     MOVWF FSR0, ACCESS
0F6A  CFDA     MOVFF FSR2H, FSR0H
0F6C  FFEA     NOP
0F6E  0E00     MOVLW 0x0
0F70  22EA     ADDWFC FSR0H, F, ACCESS
0F72  0EA0     MOVLW 0xA0
0F74  6EEE     MOVWF POSTINC0, ACCESS
0F76  0E00     MOVLW 0x0
0F78  6EED     MOVWF POSTDEC0, ACCESS
247:           
248:             for (i = 0; i < MAX_TASK_NB; i++)
0F7A  6ADF     CLRF INDF2, ACCESS
0F7C  0E10     MOVLW 0x10
0F7E  5CDF     SUBWF INDF2, W, ACCESS
0F80  E257     BC 0x1030
102C  2ADF     INCF INDF2, F, ACCESS
102E  D7A6     BRA 0xF7C
249:             {
250:               if ( (*ptr_task & MASK_ID) == TaskID )
0F82  0E01     MOVLW 0x1
0F84  CFDB     MOVFF PLUSW2, FSR0
0F86  FFE9     NOP
0F88  0E02     MOVLW 0x2
0F8A  CFDB     MOVFF PLUSW2, FSR0H
0F8C  FFEA     NOP
0F8E  50EF     MOVF INDF0, W, ACCESS
0F90  0B0F     ANDLW 0xF
0F92  6E14     MOVWF __tmp_0, ACCESS
0F94  0EFD     MOVLW 0xFD
0F96  50DB     MOVF PLUSW2, W, ACCESS
0F98  5C14     SUBWF __tmp_0, W, ACCESS
0F9A  E143     BNZ 0x1022
251:               {
252:                 if ((*ptr_task & MASK_STATE) == SUSPENDED)
0F9C  0E01     MOVLW 0x1
0F9E  CFDB     MOVFF PLUSW2, FSR0
0FA0  FFE9     NOP
0FA2  0E02     MOVLW 0x2
0FA4  CFDB     MOVFF PLUSW2, FSR0H
0FA6  FFEA     NOP
0FA8  50EF     MOVF INDF0, W, ACCESS
0FAA  0BE0     ANDLW 0xE0
0FAC  E116     BNZ 0xFDA
253:                 {
254:                   *ptr_task &= MASK_ID;
0FAE  0E0F     MOVLW 0xF
0FB0  6E14     MOVWF __tmp_0, ACCESS
0FB2  0E01     MOVLW 0x1
0FB4  CFDB     MOVFF PLUSW2, FSR0
0FB6  FFE9     NOP
0FB8  0E02     MOVLW 0x2
0FBA  CFDB     MOVFF PLUSW2, FSR0H
0FBC  FFEA     NOP
0FBE  5014     MOVF __tmp_0, W, ACCESS
0FC0  16EF     ANDWF INDF0, F, ACCESS
255:                   *ptr_task += READY;
0FC2  0E20     MOVLW 0x20
0FC4  6E14     MOVWF __tmp_0, ACCESS
0FC6  0E01     MOVLW 0x1
0FC8  CFDB     MOVFF PLUSW2, FSR0
0FCA  FFE9     NOP
0FCC  0E02     MOVLW 0x2
0FCE  CFDB     MOVFF PLUSW2, FSR0H
0FD0  FFEA     NOP
0FD2  5014     MOVF __tmp_0, W, ACCESS
0FD4  26EF     ADDWF INDF0, F, ACCESS
256:                   Schedule();
0FD6  D91B     RCALL Schedule
257:                 }
258:                 else
0FD8  D022     BRA 0x101E
259:                 {
260:                   ptr_task   = (TaskRefType)&tsk_1_activ_prio + i;
0FDA  50DF     MOVF INDF2, W, ACCESS
0FDC  6A15     CLRF 0x15, ACCESS
0FDE  0FB0     ADDLW 0xB0
0FE0  6E14     MOVWF __tmp_0, ACCESS
0FE2  0E00     MOVLW 0x0
0FE4  2215     ADDWFC 0x15, F, ACCESS
0FE6  0E01     MOVLW 0x1
0FE8  C014     MOVFF __tmp_0, PLUSW2
0FEA  FFDB     NOP
0FEC  0E02     MOVLW 0x2
0FEE  C015     MOVFF 0x15, PLUSW2
0FF0  FFDB     NOP
261:                   if ((*ptr_task & MASK_ACTIV) < MASK_ACTIV)
0FF2  0E01     MOVLW 0x1
0FF4  CFDB     MOVFF PLUSW2, FSR0
0FF6  FFE9     NOP
0FF8  0E02     MOVLW 0x2
0FFA  CFDB     MOVFF PLUSW2, FSR0H
0FFC  FFEA     NOP
0FFE  50EF     MOVF INDF0, W, ACCESS
1000  0BF0     ANDLW 0xF0
1002  6E14     MOVWF __tmp_0, ACCESS
1004  0EF0     MOVLW 0xF0
1006  5C14     SUBWF __tmp_0, W, ACCESS
1008  E20A     BC 0x101E
262:                     *ptr_task += 0x10;
100A  0E10     MOVLW 0x10
100C  6E14     MOVWF __tmp_0, ACCESS
100E  0E01     MOVLW 0x1
1010  CFDB     MOVFF PLUSW2, FSR0
1012  FFE9     NOP
1014  0E02     MOVLW 0x2
1016  CFDB     MOVFF PLUSW2, FSR0H
1018  FFEA     NOP
101A  5014     MOVF __tmp_0, W, ACCESS
101C  26EF     ADDWF INDF0, F, ACCESS
263:                 }
264:                 return (E_OK);
101E  0E00     MOVLW 0x0
1020  D009     BRA 0x1034
265:               }
266:               ptr_task++;
1022  0E01     MOVLW 0x1
1024  2ADB     INCF PLUSW2, F, ACCESS
1026  0E02     MOVLW 0x2
1028  E301     BNC 0x102C
102A  2ADB     INCF PLUSW2, F, ACCESS
267:             }
268:           
269:             return (E_OS_ID);
1030  0E03     MOVLW 0x3
1032  D000     BRA 0x1034
270:           }
1034  52E5     MOVF POSTDEC1, F, ACCESS
1036  52E5     MOVF POSTDEC1, F, ACCESS
1038  52E5     MOVF POSTDEC1, F, ACCESS
103A  52E5     MOVF POSTDEC1, F, ACCESS
103C  CFE5     MOVFF POSTDEC1, FSR2H
103E  FFDA     NOP
1040  CFE7     MOVFF INDF1, FSR2
1042  FFD9     NOP
1044  0012     RETURN 0
271:           
272:           /**********************************************************************
273:            * Allow a task to terminate itself. Cannot terminate another task.
274:            * To prepare a new activation of the task, we need first to store in
275:            * stack the start adress of the task
276:            *
277:            * @param dest       OUT Destination buffer 
278:            * @param src        IN  The byte to copy
279:            * @return Status    E_OK if ID is not correct
280:            *                   In fact the function never return 
281:            **********************************************************************/
282:           StatusType TerminateTask (void)
1046  CFD9     MOVFF FSR2, POSTINC1
1048  FFE6     NOP
104A  CFDA     MOVFF FSR2H, POSTINC1
104C  FFE6     NOP
104E  CFE1     MOVFF FSR1, FSR2
1050  FFD9     NOP
1052  CFE2     MOVFF FSR1H, FSR2H
1054  FFDA     NOP
1056  52E6     MOVF POSTINC1, F, ACCESS
1058  52E6     MOVF POSTINC1, F, ACCESS
105A  52E6     MOVF POSTINC1, F, ACCESS
283:           {
284:             unsigned char i;
285:             TaskRefType ptr_task;
286:              
287:             ptr_task = (TaskRefType)&tsk_1_state_ID;
105C  50D9     MOVF FSR2, W, ACCESS
105E  0F01     ADDLW 0x1
1060  6EE9     MOVWF FSR0, ACCESS
1062  CFDA     MOVFF FSR2H, FSR0H
1064  FFEA     NOP
1066  0E00     MOVLW 0x0
1068  22EA     ADDWFC FSR0H, F, ACCESS
106A  0EA0     MOVLW 0xA0
106C  6EEE     MOVWF POSTINC0, ACCESS
106E  0E00     MOVLW 0x0
1070  6EED     MOVWF POSTDEC0, ACCESS
288:              
289:             for (i = 0; i < MAX_TASK_NB; i++)
1072  6ADF     CLRF INDF2, ACCESS
1074  0E10     MOVLW 0x10
1076  5CDF     SUBWF INDF2, W, ACCESS
1078  E254     BC 0x1122
111E  2ADF     INCF INDF2, F, ACCESS
1120  D7A9     BRA 0x1074
290:             { 
291:               if ( (*ptr_task & MASK_ID) == id_tsk_run )
107A  0E01     MOVLW 0x1
107C  CFDB     MOVFF PLUSW2, FSR0
107E  FFE9     NOP
1080  0E02     MOVLW 0x2
1082  CFDB     MOVFF PLUSW2, FSR0H
1084  FFEA     NOP
1086  50EF     MOVF INDF0, W, ACCESS
1088  0B0F     ANDLW 0xF
108A  0100     MOVLB 0x0
108C  5D6D     SUBWF id_tsk_run, W, BANKED
108E  E142     BNZ 0x1114
292:               {
293:           	  ptr_task     = (TaskRefType)&tsk_1_activ_prio + i;
1090  50DF     MOVF INDF2, W, ACCESS
1092  6A15     CLRF 0x15, ACCESS
1094  0FB0     ADDLW 0xB0
1096  6E14     MOVWF __tmp_0, ACCESS
1098  0E00     MOVLW 0x0
109A  2215     ADDWFC 0x15, F, ACCESS
109C  0E01     MOVLW 0x1
109E  C014     MOVFF __tmp_0, PLUSW2
10A0  FFDB     NOP
10A2  0E02     MOVLW 0x2
10A4  C015     MOVFF 0x15, PLUSW2
10A6  FFDB     NOP
294:           	  if ((*ptr_task & MASK_STATE) == 0)
10A8  0E01     MOVLW 0x1
10AA  CFDB     MOVFF PLUSW2, FSR0
10AC  FFE9     NOP
10AE  0E02     MOVLW 0x2
10B0  CFDB     MOVFF PLUSW2, FSR0H
10B2  FFEA     NOP
10B4  50EF     MOVF INDF0, W, ACCESS
10B6  0BE0     ANDLW 0xE0
10B8  E120     BNZ 0x10FA
295:           	  {
296:                   ptr_task   = (TaskRefType)&tsk_1_state_ID + i;
10BA  50DF     MOVF INDF2, W, ACCESS
10BC  6A15     CLRF 0x15, ACCESS
10BE  0FA0     ADDLW 0xA0
10C0  6E14     MOVWF __tmp_0, ACCESS
10C2  0E00     MOVLW 0x0
10C4  2215     ADDWFC 0x15, F, ACCESS
10C6  0E01     MOVLW 0x1
10C8  C014     MOVFF __tmp_0, PLUSW2
10CA  FFDB     NOP
10CC  0E02     MOVLW 0x2
10CE  C015     MOVFF 0x15, PLUSW2
10D0  FFDB     NOP
297:                   *ptr_task &= MASK_ID;
10D2  0E0F     MOVLW 0xF
10D4  6E14     MOVWF __tmp_0, ACCESS
10D6  0E01     MOVLW 0x1
10D8  CFDB     MOVFF PLUSW2, FSR0
10DA  FFE9     NOP
10DC  0E02     MOVLW 0x2
10DE  CFDB     MOVFF PLUSW2, FSR0H
10E0  FFEA     NOP
10E2  5014     MOVF __tmp_0, W, ACCESS
10E4  16EF     ANDWF INDF0, F, ACCESS
298:                   *ptr_task += SUSPENDED;
10E6  0E01     MOVLW 0x1
10E8  CFDB     MOVFF PLUSW2, FSR0
10EA  FFE9     NOP
10EC  0E02     MOVLW 0x2
10EE  CFDB     MOVFF PLUSW2, FSR0H
10F0  FFEA     NOP
299:                   RESTART;
10F2  9CF2     BCF INTCON, 6, ACCESS
10F4  EFCE     GOTO 0x1D9C
10F6  F00E     NOP
300:                 }
301:                 else
10F8  D00D     BRA 0x1114
302:                 {
303:           	    *ptr_task -= 0x10;
10FA  0E10     MOVLW 0x10
10FC  6E14     MOVWF __tmp_0, ACCESS
10FE  0E01     MOVLW 0x1
1100  CFDB     MOVFF PLUSW2, FSR0
1102  FFE9     NOP
1104  0E02     MOVLW 0x2
1106  CFDB     MOVFF PLUSW2, FSR0H
1108  FFEA     NOP
110A  5014     MOVF __tmp_0, W, ACCESS
110C  5EEF     SUBWF INDF0, F, ACCESS
304:                   RESTART;
110E  9CF2     BCF INTCON, 6, ACCESS
1110  EFCE     GOTO 0x1D9C
1112  F00E     NOP
305:           	  }
306:               }
307:               ptr_task++;
1114  0E01     MOVLW 0x1
1116  2ADB     INCF PLUSW2, F, ACCESS
1118  0E02     MOVLW 0x2
111A  E301     BNC 0x111E
111C  2ADB     INCF PLUSW2, F, ACCESS
308:             }
309:            
310:             return (E_OK);
1122  0E00     MOVLW 0x0
1124  D000     BRA 0x1126
311:           }
1126  52E5     MOVF POSTDEC1, F, ACCESS
1128  52E5     MOVF POSTDEC1, F, ACCESS
112A  52E5     MOVF POSTDEC1, F, ACCESS
112C  52E5     MOVF POSTDEC1, F, ACCESS
112E  CFE5     MOVFF POSTDEC1, FSR2H
1130  FFDA     NOP
1132  CFE7     MOVFF INDF1, FSR2
1134  FFD9     NOP
1136  0012     RETURN 0
312:           
313:           /**********************************************************************
314:            * Chain a task by setting the calling task in a SUSPENDED state and 
315:            * the called taks in the READY state.
316:            * Call the scheduler to jump the chained task.
317:            * This doesn't take into account the multiple activation feature, then
318:            * if a calling task has been activated twice a chaintask will erased 
319:            * its activation counter (the calling task will be SUSPENDED).
320:            *
321:            * @param TaskID     IN  ID of the next task to chain
322:            * @return Status    E_OK if ID is not correct
323:            *                   In fact the function never return 
324:            **********************************************************************/
325:           StatusType ChainTask (TaskType TaskID)
1138  CFD9     MOVFF FSR2, POSTINC1
113A  FFE6     NOP
113C  CFDA     MOVFF FSR2H, POSTINC1
113E  FFE6     NOP
1140  CFE1     MOVFF FSR1, FSR2
1142  FFD9     NOP
1144  CFE2     MOVFF FSR1H, FSR2H
1146  FFDA     NOP
1148  52E6     MOVF POSTINC1, F, ACCESS
114A  52E6     MOVF POSTINC1, F, ACCESS
114C  52E6     MOVF POSTINC1, F, ACCESS
326:           {
327:             unsigned char i;
328:             TaskRefType ptr_task;
329:           
330:             ptr_task = (TaskRefType)&tsk_1_state_ID;
114E  50D9     MOVF FSR2, W, ACCESS
1150  0F01     ADDLW 0x1
1152  6EE9     MOVWF FSR0, ACCESS
1154  CFDA     MOVFF FSR2H, FSR0H
1156  FFEA     NOP
1158  0E00     MOVLW 0x0
115A  22EA     ADDWFC FSR0H, F, ACCESS
115C  0EA0     MOVLW 0xA0
115E  6EEE     MOVWF POSTINC0, ACCESS
1160  0E00     MOVLW 0x0
1162  6EED     MOVWF POSTDEC0, ACCESS
331:           
332:             for (i = 0; i < MAX_TASK_NB; i++)
1164  6ADF     CLRF INDF2, ACCESS
1166  0E10     MOVLW 0x10
1168  5CDF     SUBWF INDF2, W, ACCESS
116A  E243     BC 0x11F2
11EE  2ADF     INCF INDF2, F, ACCESS
11F0  D7BA     BRA 0x1166
333:             {
334:               if ( (*ptr_task & MASK_ID) == id_tsk_run )
116C  0E01     MOVLW 0x1
116E  CFDB     MOVFF PLUSW2, FSR0
1170  FFE9     NOP
1172  0E02     MOVLW 0x2
1174  CFDB     MOVFF PLUSW2, FSR0H
1176  FFEA     NOP
1178  50EF     MOVF INDF0, W, ACCESS
117A  0B0F     ANDLW 0xF
117C  0100     MOVLB 0x0
117E  5D6D     SUBWF id_tsk_run, W, BANKED
1180  E110     BNZ 0x11A2
335:               {
336:                 *ptr_task &= MASK_ID;
1182  0E0F     MOVLW 0xF
1184  6E14     MOVWF __tmp_0, ACCESS
1186  0E01     MOVLW 0x1
1188  CFDB     MOVFF PLUSW2, FSR0
118A  FFE9     NOP
118C  0E02     MOVLW 0x2
118E  CFDB     MOVFF PLUSW2, FSR0H
1190  FFEA     NOP
1192  5014     MOVF __tmp_0, W, ACCESS
1194  16EF     ANDWF INDF0, F, ACCESS
337:                 *ptr_task += SUSPENDED;
1196  0E01     MOVLW 0x1
1198  CFDB     MOVFF PLUSW2, FSR0
119A  FFE9     NOP
119C  0E02     MOVLW 0x2
119E  CFDB     MOVFF PLUSW2, FSR0H
11A0  FFEA     NOP
338:               }
339:               if ( (*ptr_task & MASK_ID) == TaskID )
11A2  0E01     MOVLW 0x1
11A4  CFDB     MOVFF PLUSW2, FSR0
11A6  FFE9     NOP
11A8  0E02     MOVLW 0x2
11AA  CFDB     MOVFF PLUSW2, FSR0H
11AC  FFEA     NOP
11AE  50EF     MOVF INDF0, W, ACCESS
11B0  0B0F     ANDLW 0xF
11B2  6E14     MOVWF __tmp_0, ACCESS
11B4  0EFD     MOVLW 0xFD
11B6  50DB     MOVF PLUSW2, W, ACCESS
11B8  5C14     SUBWF __tmp_0, W, ACCESS
11BA  E114     BNZ 0x11E4
340:               {
341:                 *ptr_task &= MASK_ID;
11BC  0E0F     MOVLW 0xF
11BE  6E14     MOVWF __tmp_0, ACCESS
11C0  0E01     MOVLW 0x1
11C2  CFDB     MOVFF PLUSW2, FSR0
11C4  FFE9     NOP
11C6  0E02     MOVLW 0x2
11C8  CFDB     MOVFF PLUSW2, FSR0H
11CA  FFEA     NOP
11CC  5014     MOVF __tmp_0, W, ACCESS
11CE  16EF     ANDWF INDF0, F, ACCESS
342:                 *ptr_task += READY;
11D0  0E20     MOVLW 0x20
11D2  6E14     MOVWF __tmp_0, ACCESS
11D4  0E01     MOVLW 0x1
11D6  CFDB     MOVFF PLUSW2, FSR0
11D8  FFE9     NOP
11DA  0E02     MOVLW 0x2
11DC  CFDB     MOVFF PLUSW2, FSR0H
11DE  FFEA     NOP
11E0  5014     MOVF __tmp_0, W, ACCESS
11E2  26EF     ADDWF INDF0, F, ACCESS
343:               }
344:               ptr_task++;
11E4  0E01     MOVLW 0x1
11E6  2ADB     INCF PLUSW2, F, ACCESS
11E8  0E02     MOVLW 0x2
11EA  E301     BNC 0x11EE
11EC  2ADB     INCF PLUSW2, F, ACCESS
345:             }
346:             
347:             RESTART;
11F2  9CF2     BCF INTCON, 6, ACCESS
11F4  EFCE     GOTO 0x1D9C
11F6  F00E     NOP
348:             return (E_OK);
11F8  0E00     MOVLW 0x0
11FA  D000     BRA 0x11FC
349:           }
11FC  52E5     MOVF POSTDEC1, F, ACCESS
11FE  52E5     MOVF POSTDEC1, F, ACCESS
1200  52E5     MOVF POSTDEC1, F, ACCESS
1202  52E5     MOVF POSTDEC1, F, ACCESS
1204  CFE5     MOVFF POSTDEC1, FSR2H
1206  FFDA     NOP
1208  CFE7     MOVFF INDF1, FSR2
120A  FFD9     NOP
120C  0012     RETURN 0
350:           
351:           /**********************************************************************
352:            * Force a scheduler action
353:            *
354:            * @return Status    E_OK if a service is called inside an ISR
355:            *                   or never returns
356:            **********************************************************************/
357:           StatusType Schedule(void)
358:           {
359:             INTCONbits.GIEL = 0;
120E  9CF2     BCF INTCON, 6, ACCESS
360:             kernelState |= SERVICES;
1210  0100     MOVLB 0x0
1212  8572     BSF kernelState, 2, BANKED
361:             if (kernelState & ISR)
1214  0100     MOVLB 0x0
1216  A372     BTFSS kernelState, 1, BANKED
1218  D002     BRA 0x121E
362:               return (E_OK);
121A  0E00     MOVLW 0x0
121C  D04E     BRA 0x12BA
363:             kernelState &= ~SERVICES;
121E  0100     MOVLB 0x0
1220  9572     BCF kernelState, 2, BANKED
364:             if((kernelState & (USER | CTX_SAVED)) == USER)   /* ==> Added */
1222  0E09     MOVLW 0x9
1224  0100     MOVLB 0x0
1226  1572     ANDWF kernelState, W, BANKED
1228  0801     SUBLW 0x1
122A  E141     BNZ 0x12AE
365:               SAVE_TASK_CTX(stack_low, stack_high);
122C  9CF2     BCF INTCON, 6, ACCESS
122E  CFD8     MOVFF STATUS, PREINC1
1230  FFE4     NOP
1232  CFE8     MOVFF WREG, PREINC1
1234  FFE4     NOP
1236  CFE0     MOVFF BSR, PREINC1
1238  FFE4     NOP
123A  CFD9     MOVFF FSR2, PREINC1
123C  FFE4     NOP
123E  CFDA     MOVFF FSR2H, PREINC1
1240  FFE4     NOP
1242  CFE9     MOVFF FSR0, PREINC1
1244  FFE4     NOP
1246  CFEA     MOVFF FSR0H, PREINC1
1248  FFE4     NOP
124A  CFF8     MOVFF TBLPTRU, PREINC1
124C  FFE4     NOP
124E  CFF7     MOVFF TBLPTRH, PREINC1
1250  FFE4     NOP
1252  CFF6     MOVFF TBLPTR, PREINC1
1254  FFE4     NOP
1256  CFF5     MOVFF TABLAT, PREINC1
1258  FFE4     NOP
125A  CFF4     MOVFF PRODH, PREINC1
125C  FFE4     NOP
125E  CFF3     MOVFF PROD, PREINC1
1260  FFE4     NOP
1262  CFFB     MOVFF PCLATU, PREINC1
1264  FFE4     NOP
1266  CFFA     MOVFF PCLATH, PREINC1
1268  FFE4     NOP
126A  0E1F     MOVLW 0x1F
126C  6AE9     CLRF FSR0, ACCESS
126E  6AEA     CLRF FSR0H, ACCESS
1270  50E8     MOVF WREG, W, ACCESS
1272  06E8     DECF WREG, F, ACCESS
1274  0900     IORLW 0x0
1276  E003     BZ 0x127E
1278  CFEE     MOVFF POSTINC0, PREINC1
127A  FFE4     NOP
127C  D7F9     BRA 0x1270
127E  CFFC     MOVFF STKPTR, FSR0
1280  FFE9     NOP
1282  50FC     MOVF STKPTR, W, ACCESS
1284  0800     SUBLW 0x0
1286  E208     BC 0x1298
1288  CFFD     MOVFF TOS, PREINC1
128A  FFE4     NOP
128C  CFFE     MOVFF TOSH, PREINC1
128E  FFE4     NOP
1290  CFFF     MOVFF TOSU, PREINC1
1292  FFE4     NOP
1294  0006     POP
1296  D7F5     BRA 0x1282
1298  CFE9     MOVFF FSR0, PREINC1
129A  FFE4     NOP
129C  52E4     MOVF PREINC1, F, ACCESS
129E  C06B     MOVFF stack_low, FSR0
12A0  FFE9     NOP
12A2  C06C     MOVFF stack_high, FSR0H
12A4  FFEA     NOP
12A6  CFE1     MOVFF FSR1, POSTINC0
12A8  FFEE     NOP
12AA  CFE2     MOVFF FSR1H, POSTINC0
12AC  FFEE     NOP
366:             kernelState &= ~CTX_SAVED;                      /* ==> Added */
12AE  0100     MOVLB 0x0
12B0  9772     BCF kernelState, 3, BANKED
367:             SCHEDULE;
12B2  EF9B     GOTO 0x1B36
12B4  F00D     NOP
368:             return (E_OK);
12B6  0E00     MOVLW 0x0
12B8  D000     BRA 0x12BA
369:           }
12BA  0012     RETURN 0
370:           
371:           /**********************************************************************
372:            * Return the appmode global variable.
373:            *
374:            * @return AppMode   The mode set by application 
375:            **********************************************************************/
376:           AppModeType GetActiveApplicationMode(void)
377:           {
378:             return(appmode);
12BC  010E     MOVLB 0xE
12BE  513D     MOVF 0x3D, W, BANKED
12C0  D000     BRA 0x12C2
379:           }
12C2  0012     RETURN 0
380:           
381:           /**********************************************************************
382:            * Jump to the KERNEL code area by setting the appmode global variable. 
383:            * This service is for call from main routine only.
384:            * Store at first the return adress in main routine.
385:            *
386:            * @param Mode       IN  Mode to set into appmode
387:            * @return void
388:            **********************************************************************/
389:           void StartOS(AppModeType Mode)
12C4  CFD9     MOVFF FSR2, POSTINC1
12C6  FFE6     NOP
12C8  CFDA     MOVFF FSR2H, POSTINC1
12CA  FFE6     NOP
12CC  CFE1     MOVFF FSR1, FSR2
12CE  FFD9     NOP
12D0  CFE2     MOVFF FSR1H, FSR2H
12D2  FFDA     NOP
390:           {
391:             SAVE_TASK_CTX(FSR1L, FSR1H);
12D4  9CF2     BCF INTCON, 6, ACCESS
12D6  CFD8     MOVFF STATUS, PREINC1
12D8  FFE4     NOP
12DA  CFE8     MOVFF WREG, PREINC1
12DC  FFE4     NOP
12DE  CFE0     MOVFF BSR, PREINC1
12E0  FFE4     NOP
12E2  CFD9     MOVFF FSR2, PREINC1
12E4  FFE4     NOP
12E6  CFDA     MOVFF FSR2H, PREINC1
12E8  FFE4     NOP
12EA  CFE9     MOVFF FSR0, PREINC1
12EC  FFE4     NOP
12EE  CFEA     MOVFF FSR0H, PREINC1
12F0  FFE4     NOP
12F2  CFF8     MOVFF TBLPTRU, PREINC1
12F4  FFE4     NOP
12F6  CFF7     MOVFF TBLPTRH, PREINC1
12F8  FFE4     NOP
12FA  CFF6     MOVFF TBLPTR, PREINC1
12FC  FFE4     NOP
12FE  CFF5     MOVFF TABLAT, PREINC1
1300  FFE4     NOP
1302  CFF4     MOVFF PRODH, PREINC1
1304  FFE4     NOP
1306  CFF3     MOVFF PROD, PREINC1
1308  FFE4     NOP
130A  CFFB     MOVFF PCLATU, PREINC1
130C  FFE4     NOP
130E  CFFA     MOVFF PCLATH, PREINC1
1310  FFE4     NOP
1312  0E1F     MOVLW 0x1F
1314  6AE9     CLRF FSR0, ACCESS
1316  6AEA     CLRF FSR0H, ACCESS
1318  50E8     MOVF WREG, W, ACCESS
131A  06E8     DECF WREG, F, ACCESS
131C  0900     IORLW 0x0
131E  E003     BZ 0x1326
1320  CFEE     MOVFF POSTINC0, PREINC1
1322  FFE4     NOP
1324  D7F9     BRA 0x1318
1326  CFFC     MOVFF STKPTR, FSR0
1328  FFE9     NOP
132A  50FC     MOVF STKPTR, W, ACCESS
132C  0800     SUBLW 0x0
132E  E208     BC 0x1340
1330  CFFD     MOVFF TOS, PREINC1
1332  FFE4     NOP
1334  CFFE     MOVFF TOSH, PREINC1
1336  FFE4     NOP
1338  CFFF     MOVFF TOSU, PREINC1
133A  FFE4     NOP
133C  0006     POP
133E  D7F5     BRA 0x132A
1340  CFE9     MOVFF FSR0, PREINC1
1342  FFE4     NOP
1344  52E4     MOVF PREINC1, F, ACCESS
1346  CFE1     MOVFF FSR1, FSR0
1348  FFE9     NOP
134A  CFE2     MOVFF FSR1H, FSR0H
134C  FFEA     NOP
134E  CFE1     MOVFF FSR1, POSTINC0
1350  FFEE     NOP
1352  CFE2     MOVFF FSR1H, POSTINC0
1354  FFEE     NOP
392:             FSR1L_MAIN = FSR1L;
1356  CFE1     MOVFF FSR1, FSR1L_MAIN
1358  FE3C     NOP
393:             FSR1H_MAIN = FSR1H;
135A  CFE2     MOVFF FSR1H, FSR1H_MAIN
135C  FE3B     NOP
394:             appmode = Mode;
135E  0EFD     MOVLW 0xFD
1360  CFDB     MOVFF PLUSW2, appmode
1362  FE3D     NOP
395:             STKPTR = 0;
1364  6AFC     CLRF STKPTR, ACCESS
396:             _asm	goto _kernel  _endasm;
1366  EFF5     GOTO 0x19EA
1368  F00C     NOP
397:           }
136A  52E5     MOVF POSTDEC1, F, ACCESS
136C  CFE5     MOVFF POSTDEC1, FSR2H
136E  FFDA     NOP
1370  CFE7     MOVFF INDF1, FSR2
1372  FFD9     NOP
1374  0012     RETURN 0
398:           
399:           /**********************************************************************
400:            * Stop the kernel and task activation after an error occurs. 
401:            * The function returns to the adress of the main function stored by 
402:            * the StartOS service.
403:            *
404:            * @param error      IN  Last error number detected
405:            * @return void
406:            **********************************************************************/
407:           void ShutdownOS(StatusType Error)
1376  CFD9     MOVFF FSR2, POSTINC1
1378  FFE6     NOP
137A  CFDA     MOVFF FSR2H, POSTINC1
137C  FFE6     NOP
137E  CFE1     MOVFF FSR1, FSR2
1380  FFD9     NOP
1382  CFE2     MOVFF FSR1H, FSR2H
1384  FFDA     NOP
408:           {	
409:           #ifdef	SHUTDOWNHOOK
410:             ShutdownHook(Error);
411:           #endif
412:             FSR1L = FSR1L_MAIN;
1386  CE3C     MOVFF FSR1L_MAIN, FSR1
1388  FFE1     NOP
413:             FSR1H = FSR1H_MAIN;  
138A  CE3B     MOVFF FSR1H_MAIN, FSR1H
138C  FFE2     NOP
414:             _restore_now();
138E  EC13     CALL 0x1C26, 0
1390  F00E     NOP
415:           }
1392  52E5     MOVF POSTDEC1, F, ACCESS
1394  CFE5     MOVFF POSTDEC1, FSR2H
1396  FFDA     NOP
1398  CFE7     MOVFF INDF1, FSR2
139A  FFD9     NOP
139C  0012     RETURN 0
416:           
417:           /**********************************************************************
418:            * Force the kernel to bring into order the list of tasks function to  
419:            * priority.
420:            *
421:            * @param  void
422:            * @return void
423:            **********************************************************************/
424:           void Organize(void)
425:           {
426:             SAVE_TASK_CTX(stack_low, stack_high);
139E  9CF2     BCF INTCON, 6, ACCESS
13A0  CFD8     MOVFF STATUS, PREINC1
13A2  FFE4     NOP
13A4  CFE8     MOVFF WREG, PREINC1
13A6  FFE4     NOP
13A8  CFE0     MOVFF BSR, PREINC1
13AA  FFE4     NOP
13AC  CFD9     MOVFF FSR2, PREINC1
13AE  FFE4     NOP
13B0  CFDA     MOVFF FSR2H, PREINC1
13B2  FFE4     NOP
13B4  CFE9     MOVFF FSR0, PREINC1
13B6  FFE4     NOP
13B8  CFEA     MOVFF FSR0H, PREINC1
13BA  FFE4     NOP
13BC  CFF8     MOVFF TBLPTRU, PREINC1
13BE  FFE4     NOP
13C0  CFF7     MOVFF TBLPTRH, PREINC1
13C2  FFE4     NOP
13C4  CFF6     MOVFF TBLPTR, PREINC1
13C6  FFE4     NOP
13C8  CFF5     MOVFF TABLAT, PREINC1
13CA  FFE4     NOP
13CC  CFF4     MOVFF PRODH, PREINC1
13CE  FFE4     NOP
13D0  CFF3     MOVFF PROD, PREINC1
13D2  FFE4     NOP
13D4  CFFB     MOVFF PCLATU, PREINC1
13D6  FFE4     NOP
13D8  CFFA     MOVFF PCLATH, PREINC1
13DA  FFE4     NOP
13DC  0E1F     MOVLW 0x1F
13DE  6AE9     CLRF FSR0, ACCESS
13E0  6AEA     CLRF FSR0H, ACCESS
13E2  50E8     MOVF WREG, W, ACCESS
13E4  06E8     DECF WREG, F, ACCESS
13E6  0900     IORLW 0x0
13E8  E003     BZ 0x13F0
13EA  CFEE     MOVFF POSTINC0, PREINC1
13EC  FFE4     NOP
13EE  D7F9     BRA 0x13E2
13F0  CFFC     MOVFF STKPTR, FSR0
13F2  FFE9     NOP
13F4  50FC     MOVF STKPTR, W, ACCESS
13F6  0800     SUBLW 0x0
13F8  E208     BC 0x140A
13FA  CFFD     MOVFF TOS, PREINC1
13FC  FFE4     NOP
13FE  CFFE     MOVFF TOSH, PREINC1
1400  FFE4     NOP
1402  CFFF     MOVFF TOSU, PREINC1
1404  FFE4     NOP
1406  0006     POP
1408  D7F5     BRA 0x13F4
140A  CFE9     MOVFF FSR0, PREINC1
140C  FFE4     NOP
140E  52E4     MOVF PREINC1, F, ACCESS
1410  C06B     MOVFF stack_low, FSR0
1412  FFE9     NOP
1414  C06C     MOVFF stack_high, FSR0H
1416  FFEA     NOP
1418  CFE1     MOVFF FSR1, POSTINC0
141A  FFEE     NOP
141C  CFE2     MOVFF FSR1H, POSTINC0
141E  FFEE     NOP
427:             ORGANIZE;
1420  EF66     GOTO 0x1ACC
1422  F00D     NOP
428:           }
1424  0012     RETURN 0
429:           
430:           /**********************************************************************
431:            * Set the task priority to the resource priority. 
432:            * See the ceiling protocol of the OSEK/VDX standart.
433:            *
434:            * @param ID         IN  ID of the resource to be accessed
435:            * @return Status    E_OS_ACCESS if the resource does not exist
436:            *                   Elsewise the function never returns 
437:            **********************************************************************/
438:           StatusType GetResource(ResourceType ID)
1426  CFD9     MOVFF FSR2, POSTINC1
1428  FFE6     NOP
142A  CFDA     MOVFF FSR2H, POSTINC1
142C  FFE6     NOP
142E  CFE1     MOVFF FSR1, FSR2
1430  FFD9     NOP
1432  CFE2     MOVFF FSR1H, FSR2H
1434  FFDA     NOP
439:           {
440:             if (ID >= RESOURCENUMBER)
1436  0EFC     MOVLW 0xFC
1438  CFDB     MOVFF PLUSW2, __tmp_0
143A  F014     NOP
143C  0EFD     MOVLW 0xFD
143E  CFDB     MOVFF PLUSW2, 0x15
1440  F015     NOP
1442  010E     MOVLB 0xE
1444  5137     MOVF 0x37, W, BANKED
1446  6E16     MOVWF 0x16, ACCESS
1448  6A17     CLRF 0x17, ACCESS
144A  5016     MOVF 0x16, W, ACCESS
144C  5C14     SUBWF __tmp_0, W, ACCESS
144E  5017     MOVF 0x17, W, ACCESS
1450  5815     SUBWFB 0x15, W, ACCESS
1452  E302     BNC 0x1458
441:               return (E_OS_ID);
1454  0E03     MOVLW 0x3
1456  D074     BRA 0x1540
442:             if (Resource_list[ID].lock == 1)
1458  0EFC     MOVLW 0xFC
145A  CFDB     MOVFF PLUSW2, FSR0
145C  FFE9     NOP
145E  0EFD     MOVLW 0xFD
1460  CFDB     MOVFF PLUSW2, FSR0H
1462  FFEA     NOP
1464  0E03     MOVLW 0x3
1466  02EA     MULWF FSR0H, ACCESS
1468  CFF3     MOVFF PROD, FSR0H
146A  FFEA     NOP
146C  02E9     MULWF FSR0, ACCESS
146E  CFF3     MOVFF PROD, FSR0
1470  FFE9     NOP
1472  50F4     MOVF PRODH, W, ACCESS
1474  26EA     ADDWF FSR0H, F, ACCESS
1476  0E34     MOVLW 0x34
1478  26E9     ADDWF FSR0, F, ACCESS
147A  0E0E     MOVLW 0xE
147C  22EA     ADDWFC FSR0H, F, ACCESS
147E  0E02     MOVLW 0x2
1480  26E9     ADDWF FSR0, F, ACCESS
1482  0E00     MOVLW 0x0
1484  22EA     ADDWFC FSR0H, F, ACCESS
1486  04EF     DECF INDF0, W, ACCESS
1488  E102     BNZ 0x148E
443:               return E_OS_ACCESS;
148A  0E01     MOVLW 0x1
148C  D059     BRA 0x1540
444:             GetPriority(&Resource_list[ID].Taskprio, id_tsk_run);
148E  C06D     MOVFF id_tsk_run, POSTINC1
1490  FFE6     NOP
1492  0EFC     MOVLW 0xFC
1494  CFDB     MOVFF PLUSW2, FSR0
1496  FFE9     NOP
1498  0EFD     MOVLW 0xFD
149A  CFDB     MOVFF PLUSW2, FSR0H
149C  FFEA     NOP
149E  0E03     MOVLW 0x3
14A0  02EA     MULWF FSR0H, ACCESS
14A2  CFF3     MOVFF PROD, FSR0H
14A4  FFEA     NOP
14A6  02E9     MULWF FSR0, ACCESS
14A8  CFF3     MOVFF PROD, FSR0
14AA  FFE9     NOP
14AC  50F4     MOVF PRODH, W, ACCESS
14AE  26EA     ADDWF FSR0H, F, ACCESS
14B0  0E34     MOVLW 0x34
14B2  26E9     ADDWF FSR0, F, ACCESS
14B4  0E0E     MOVLW 0xE
14B6  22EA     ADDWFC FSR0H, F, ACCESS
14B8  52EE     MOVF POSTINC0, F, ACCESS
14BA  CFE9     MOVFF FSR0, __tmp_0
14BC  F014     NOP
14BE  CFEA     MOVFF FSR0H, 0x15
14C0  F015     NOP
14C2  C014     MOVFF __tmp_0, POSTINC1
14C4  FFE6     NOP
14C6  C015     MOVFF 0x15, POSTINC1
14C8  FFE6     NOP
14CA  DC6C     RCALL GetPriority
14CC  52E5     MOVF POSTDEC1, F, ACCESS
14CE  52E5     MOVF POSTDEC1, F, ACCESS
14D0  52E5     MOVF POSTDEC1, F, ACCESS
445:             SetPriority(Resource_list[ID].priority, id_tsk_run);
14D2  C06D     MOVFF id_tsk_run, POSTINC1
14D4  FFE6     NOP
14D6  0EFC     MOVLW 0xFC
14D8  CFDB     MOVFF PLUSW2, FSR0
14DA  FFE9     NOP
14DC  0EFD     MOVLW 0xFD
14DE  CFDB     MOVFF PLUSW2, FSR0H
14E0  FFEA     NOP
14E2  0E03     MOVLW 0x3
14E4  02EA     MULWF FSR0H, ACCESS
14E6  CFF3     MOVFF PROD, FSR0H
14E8  FFEA     NOP
14EA  02E9     MULWF FSR0, ACCESS
14EC  CFF3     MOVFF PROD, FSR0
14EE  FFE9     NOP
14F0  50F4     MOVF PRODH, W, ACCESS
14F2  26EA     ADDWF FSR0H, F, ACCESS
14F4  0E34     MOVLW 0x34
14F6  26E9     ADDWF FSR0, F, ACCESS
14F8  0E0E     MOVLW 0xE
14FA  22EA     ADDWFC FSR0H, F, ACCESS
14FC  50EF     MOVF INDF0, W, ACCESS
14FE  6EE6     MOVWF POSTINC1, ACCESS
1500  EC70     CALL 0xCE0, 0
1502  F006     NOP
1504  52E5     MOVF POSTDEC1, F, ACCESS
1506  52E5     MOVF POSTDEC1, F, ACCESS
446:             Resource_list[ID].lock = 1;
1508  0EFC     MOVLW 0xFC
150A  CFDB     MOVFF PLUSW2, FSR0
150C  FFE9     NOP
150E  0EFD     MOVLW 0xFD
1510  CFDB     MOVFF PLUSW2, FSR0H
1512  FFEA     NOP
1514  0E03     MOVLW 0x3
1516  02EA     MULWF FSR0H, ACCESS
1518  CFF3     MOVFF PROD, FSR0H
151A  FFEA     NOP
151C  02E9     MULWF FSR0, ACCESS
151E  CFF3     MOVFF PROD, FSR0
1520  FFE9     NOP
1522  50F4     MOVF PRODH, W, ACCESS
1524  26EA     ADDWF FSR0H, F, ACCESS
1526  0E34     MOVLW 0x34
1528  26E9     ADDWF FSR0, F, ACCESS
152A  0E0E     MOVLW 0xE
152C  22EA     ADDWFC FSR0H, F, ACCESS
152E  0E02     MOVLW 0x2
1530  26E9     ADDWF FSR0, F, ACCESS
1532  0E00     MOVLW 0x0
1534  22EA     ADDWFC FSR0H, F, ACCESS
1536  0E01     MOVLW 0x1
1538  6EEF     MOVWF INDF0, ACCESS
447:             Organize();
153A  DF31     RCALL Organize
448:             return(E_OK);
153C  0E00     MOVLW 0x0
153E  D000     BRA 0x1540
449:           }
1540  52E5     MOVF POSTDEC1, F, ACCESS
1542  CFE5     MOVFF POSTDEC1, FSR2H
1544  FFDA     NOP
1546  CFE7     MOVFF INDF1, FSR2
1548  FFD9     NOP
154A  0012     RETURN 0
450:           
451:           /**********************************************************************
452:            * Restore the task priority to original value. 
453:            * See the ceiling protocol of the OSEK/VDX standart.
454:            *
455:            * @param ID         IN  ID of the resource to be accessed
456:            * @return Status    E_OS_ACCESS if the resource does not exist
457:            *                   Elsewise the function never returns 
458:            **********************************************************************/
459:           StatusType ReleaseResource(ResourceType ID)
154C  CFD9     MOVFF FSR2, POSTINC1
154E  FFE6     NOP
1550  CFDA     MOVFF FSR2H, POSTINC1
1552  FFE6     NOP
1554  CFE1     MOVFF FSR1, FSR2
1556  FFD9     NOP
1558  CFE2     MOVFF FSR1H, FSR2H
155A  FFDA     NOP
460:           {
461:             if (ID >= RESOURCENUMBER)
155C  0EFC     MOVLW 0xFC
155E  CFDB     MOVFF PLUSW2, __tmp_0
1560  F014     NOP
1562  0EFD     MOVLW 0xFD
1564  CFDB     MOVFF PLUSW2, 0x15
1566  F015     NOP
1568  010E     MOVLB 0xE
156A  5137     MOVF 0x37, W, BANKED
156C  6E16     MOVWF 0x16, ACCESS
156E  6A17     CLRF 0x17, ACCESS
1570  5016     MOVF 0x16, W, ACCESS
1572  5C14     SUBWF __tmp_0, W, ACCESS
1574  5017     MOVF 0x17, W, ACCESS
1576  5815     SUBWFB 0x15, W, ACCESS
1578  E302     BNC 0x157E
462:               return (E_OS_ID);
157A  0E03     MOVLW 0x3
157C  D052     BRA 0x1622
463:             if (Resource_list[ID].lock == 0)
157E  0EFC     MOVLW 0xFC
1580  CFDB     MOVFF PLUSW2, FSR0
1582  FFE9     NOP
1584  0EFD     MOVLW 0xFD
1586  CFDB     MOVFF PLUSW2, FSR0H
1588  FFEA     NOP
158A  0E03     MOVLW 0x3
158C  02EA     MULWF FSR0H, ACCESS
158E  CFF3     MOVFF PROD, FSR0H
1590  FFEA     NOP
1592  02E9     MULWF FSR0, ACCESS
1594  CFF3     MOVFF PROD, FSR0
1596  FFE9     NOP
1598  50F4     MOVF PRODH, W, ACCESS
159A  26EA     ADDWF FSR0H, F, ACCESS
159C  0E34     MOVLW 0x34
159E  26E9     ADDWF FSR0, F, ACCESS
15A0  0E0E     MOVLW 0xE
15A2  22EA     ADDWFC FSR0H, F, ACCESS
15A4  0E02     MOVLW 0x2
15A6  26E9     ADDWF FSR0, F, ACCESS
15A8  0E00     MOVLW 0x0
15AA  22EA     ADDWFC FSR0H, F, ACCESS
15AC  50EF     MOVF INDF0, W, ACCESS
15AE  E102     BNZ 0x15B4
464:               return E_OS_ACCESS;
15B0  0E01     MOVLW 0x1
15B2  D037     BRA 0x1622
465:             SetPriority(Resource_list[ID].Taskprio, id_tsk_run);
15B4  C06D     MOVFF id_tsk_run, POSTINC1
15B6  FFE6     NOP
15B8  0EFC     MOVLW 0xFC
15BA  CFDB     MOVFF PLUSW2, FSR0
15BC  FFE9     NOP
15BE  0EFD     MOVLW 0xFD
15C0  CFDB     MOVFF PLUSW2, FSR0H
15C2  FFEA     NOP
15C4  0E03     MOVLW 0x3
15C6  02EA     MULWF FSR0H, ACCESS
15C8  CFF3     MOVFF PROD, FSR0H
15CA  FFEA     NOP
15CC  02E9     MULWF FSR0, ACCESS
15CE  CFF3     MOVFF PROD, FSR0
15D0  FFE9     NOP
15D2  50F4     MOVF PRODH, W, ACCESS
15D4  26EA     ADDWF FSR0H, F, ACCESS
15D6  0E34     MOVLW 0x34
15D8  26E9     ADDWF FSR0, F, ACCESS
15DA  0E0E     MOVLW 0xE
15DC  22EA     ADDWFC FSR0H, F, ACCESS
15DE  52EE     MOVF POSTINC0, F, ACCESS
15E0  50EF     MOVF INDF0, W, ACCESS
15E2  6EE6     MOVWF POSTINC1, ACCESS
15E4  EC70     CALL 0xCE0, 0
15E6  F006     NOP
15E8  52E5     MOVF POSTDEC1, F, ACCESS
15EA  52E5     MOVF POSTDEC1, F, ACCESS
466:             Resource_list[ID].lock = 0;
15EC  0EFC     MOVLW 0xFC
15EE  CFDB     MOVFF PLUSW2, FSR0
15F0  FFE9     NOP
15F2  0EFD     MOVLW 0xFD
15F4  CFDB     MOVFF PLUSW2, FSR0H
15F6  FFEA     NOP
15F8  0E03     MOVLW 0x3
15FA  02EA     MULWF FSR0H, ACCESS
15FC  CFF3     MOVFF PROD, FSR0H
15FE  FFEA     NOP
1600  02E9     MULWF FSR0, ACCESS
1602  CFF3     MOVFF PROD, FSR0
1604  FFE9     NOP
1606  50F4     MOVF PRODH, W, ACCESS
1608  26EA     ADDWF FSR0H, F, ACCESS
160A  0E34     MOVLW 0x34
160C  26E9     ADDWF FSR0, F, ACCESS
160E  0E0E     MOVLW 0xE
1610  22EA     ADDWFC FSR0H, F, ACCESS
1612  0E02     MOVLW 0x2
1614  26E9     ADDWF FSR0, F, ACCESS
1616  0E00     MOVLW 0x0
1618  22EA     ADDWFC FSR0H, F, ACCESS
161A  6AEF     CLRF INDF0, ACCESS
467:             Organize();
161C  DEC0     RCALL Organize
468:             return(E_OK);
161E  0E00     MOVLW 0x0
1620  D000     BRA 0x1622
469:           }
1622  52E5     MOVF POSTDEC1, F, ACCESS
1624  CFE5     MOVFF POSTDEC1, FSR2H
1626  FFDA     NOP
1628  CFE7     MOVFF INDF1, FSR2
162A  FFD9     NOP
162C  0012     RETURN 0
470:           
471:           
472:           /* End of File : pro_man.c */
---  F:/PICOS18/Kernel/kernel.asm  ----------------------------------------------------------------------
                                                  1:     ;/**********************************************************************/
                                                  2:     ;/*                                                                    */
                                                  3:     ;/* File name: kernel.asm                                              */
                                                  4:     ;/*                                                                    */
                                                  5:     ;/* Since:     2004-Sept-20                                            */
                                                  6:     ;/*                                                                    */
                                                  7:     ;/* Version:   PICos18 v3.00                                           */
                                                  8:     ;/*            Copyright (C) 2003, 2004, 2005 Pragmatec.               */
                                                  9:     ;/*                                                                    */
                                                  10:    ;/* Author:    Designed by Pragmatec S.A.R.L.        www.pragmatec.net */
                                                  11:    ;/*            MONTAGNE Xavier [XM]      xavier.montagne@pragmatec.net */
                                                  12:    ;/*            NIELSEN  Peter  [PN]                   pnielsen@tuug.fi */
                                                  13:    ;/*                                                                    */
                                                  14:    ;/* Purpose:   Kernel core.                                            */
                                                  15:    ;/*                                                                    */
                                                  16:    ;/* Distribution: This file is part of PICos18.                        */
                                                  17:    ;/*            PICos18 is free software; you can redistribute it       */
                                                  18:    ;/*            and/or modify it under the terms of the GNU General     */
                                                  19:    ;/*            Public License as published by the Free Software        */
                                                  20:    ;/*            Foundation; either version 2, or (at your option)       */
                                                  21:    ;/*            any later version.                                      */
                                                  22:    ;/*                                                                    */
                                                  23:    ;/*            PICos18 is distributed in the hope that it will be      */
                                                  24:    ;/*            useful, but WITHOUT ANY WARRANTY; without even the      */
                                                  25:    ;/*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
                                                  26:    ;/*            PARTICULAR PURPOSE.  See the GNU General Public         */
                                                  27:    ;/*            License for more details.                               */
                                                  28:    ;/*                                                                    */
                                                  29:    ;/*            You should have received a copy of the GNU General      */
                                                  30:    ;/*            Public License along with gpsim; see the file           */
                                                  31:    ;/*            COPYING.txt. If not, write to the Free Software         */
                                                  32:    ;/*            Foundation, 59 Temple Place - Suite 330,                */
                                                  33:    ;/*            Boston, MA 02111-1307, USA.                             */
                                                  34:    ;/*                                                                    */
                                                  35:    ;/*          > A special exception to the GPL can be applied should    */
                                                  36:    ;/*            you wish to distribute a combined work that includes    */
                                                  37:    ;/*            PICos18, without being obliged to provide the source    */
                                                  38:    ;/*            code for any proprietary components.                    */
                                                  39:    ;/*                                                                    */
                                                  40:    ;/* History:                                                           */
                                                  41:    ;/* 2004/09/20 [XM]  Create this file.                                 */
                                                  42:    ;/* 2005/03/27 [XM]  Added "movlb 0" after every GLOBAL symbol.        */
                                                  43:    ;/* 2005/10/29 [XM]  Added the RESET_ON_KERNEL compiler option         */
                                                  44:    ;/*                  (used in case of kernel panic - stack overflow).  */
                                                  45:    ;/* 2005/11/12 [XM]  Added "clrf    POSTINC0" during Init_RAM process. */
                                                  46:    ;/* 2006/05/21 [GW]  Refactor the code, and enrich the comments.       */
                                                  47:    ;/* 2007/01/01 [PN]  Set INTCON2=0x80 as by default.                   */
                                                  48:    ;/*                                                                    */
                                                  49:    ;/**********************************************************************/
                                                  50:    
                                                  51:    
                                                  52:    ;   #include "device.inc"
                                                  53:    #include <p18cxxx.inc>
                                                  54:    
                                                  55:    ;/*  Should be equal to .tmpdata + MATH_DATA size (from map file)      */
                                                  56:    #define TEMP_SIZE   0x1E    ;/* ==> Changed */
                                                  57:    #define  PRETASKHOOK
                                                  58:    
                                                  59:    ;/**********************************************************************
                                                  60:    ; * Kernel RAM area.
                                                  61:    ; **********************************************************************/
                                                  62:    KERNEL_RAM      UDATA
                                                  63:    id_tsk_run      RES 1                   ; ID of the running task
                                                  64:    id_tsk_pre      RES 1                   ; ==> Monitor for two last tasks
                                                  65:    temp            RES 1
                                                  66:    temp2           RES 1
                                                  67:    permut          RES 1                   ; flag on continue permut or not
                                                  68:    kernelState     RES 1
                                                  69:    kernelPanic     RES 1                   ; Left nibble holds the taskID in
                                                  70:                                            ; which stack overflow occurred
                                                  71:                                            ; Right nibble: neighbor task got
                                                  72:                                            ; impacted by the stack overflow
                                                  73:    startAddressL   RES 1                   ; Holds the task's code address
                                                  74:    startAddressH   RES 1
                                                  75:    startAddressU   RES 1
                                                  76:    
                                                  77:    
                                                  78:    ;/**********************************************************************
                                                  79:    ; * Share global variables with other sections.
                                                  80:    ; **********************************************************************/
                                                  81:        GLOBAL  id_tsk_run  
                                                  82:        GLOBAL  id_tsk_pre                  ;/* ==> Added */
                                                  83:        GLOBAL  kernelState
                                                  84:        GLOBAL  kernelPanic
                                                  85:    
                                                  86:    ;/**********************************************************************
                                                  87:    ; * Shared variables defined in other section.
                                                  88:    ; **********************************************************************/
                                                  89:        extern  tsk_1_state_ID              ; @ pro_man.c
                                                  90:        extern  tsk_16_state_ID
                                                  91:    
                                                  92:        extern  tsk_1_activ_prio            ; @ pro_man.c
                                                  93:        extern  tsk_16_activ_prio
                                                  94:    
                                                  95:        extern  FSR1H_MAIN                  ; @ pro_man.c
                                                  96:        extern  FSR1L_MAIN
                                                  97:    
                                                  98:        extern  taskdesc_addr               ; @ taskdesc.c (User Defined)
                                                  99:    
                                                  100:       extern  stack_low                   ; @ pro_man.c
                                                  101:       extern  stack_high
                                                  102:   
                                                  103:   ;/**********************************************************************
                                                  104:   ; * Hook routines activated by the -D compiler option.
                                                  105:   ; **********************************************************************/
                                                  106:   #IFDEF STARTUPHOOK
                                                  107:       extern StartupHook
                                                  108:   #ENDIF
                                                  109:   
                                                  110:   #IFDEF PRETASKHOOK
                                                  111:       extern PreTaskHook
                                                  112:   #ENDIF
                                                  113:   
                                                  114:   #IFDEF POSTTASKHOOK
                                                  115:       extern PostTaskHook
                                                  116:   #ENDIF
                                                  117:   
                                                  118:   ;/**********************************************************************
                                                  119:   ; * Macros used by KERNEL.
                                                  120:   ; **********************************************************************/
                                                  121:   setupTBLPTR  macro   pointer2rom
                                                  122:       movff   pointer2rom+2, TBLPTRU      ; Load TBLPTR with the address of
                                                  123:       movff   pointer2rom+1, TBLPTRH      ; taskdesc table located in ROM 
                                                  124:       movff   pointer2rom, TBLPTRL        ; 
                                                  125:       endm
                                                  126:   
                                                  127:   locateTaskIdField   macro
                                                  128:       movlw   7
                                                  129:       addwf   TBLPTRL, f                  ; Adjust TBLPTR to point to the
                                                  130:       clrf    WREG                        ; Task ID field of the current
                                                  131:       addwfc  TBLPTRH, f                  ; entry of the taskdesc table
                                                  132:       addwfc  TBLPTRU, f
                                                  133:       endm
                                                  134:   
                                                  135:   locateStackAddrField   macro
                                                  136:       movlw   7                           ; After extracting the task ID,
                                                  137:       subwf   TBLPTRL, f                  ; Rewind the pointer back, to  
                                                  138:       clrf    WREG                        ; point to stack address field
                                                  139:       subwfb  TBLPTRH, f                  ; of the current taskdesc entry
                                                  140:       subwfb  TBLPTRU, f
                                                  141:       endm
                                                  142:   
                                                  143:   swapTaskCtrlEntry  macro
                                                  144:       movff   POSTDEC0, temp2             ; SWAP 2 successive task entries
                                                  145:       movf    INDF0, w                    ; same macro can be used for
                                                  146:       movff   temp2, POSTINC0             ; various TCT(task control table)
                                                  147:       movwf   INDF0
                                                  148:       endm
                                                  149:   
                                                  150:   setupFSR0    macro   taskCtrlTable
                                                  151:       clrf    FSR0H                       ; Setup FSR0 to point to the
                                                  152:       movlw   taskCtrlTable               ; 1st entry of one of the four
                                                  153:       movwf   FSR0L                       ; TCTs (task control tables)
                                                  154:       endm
                                                  155:       
                                                  156:   loadNextStackAddrTo  macro   StackL, StackH
                                                  157:       TBLRD   *+                          ; Load Regsiter with the next 2
                                                  158:       movf    TABLAT, w                   ; bytes of the task descriptor,
                                                  159:       movwf   StackL                      ; taskdesc entry pointed to by
                                                  160:       TBLRD   *+                          ; TBLPTR 
                                                  161:       movf    TABLAT, w
                                                  162:       movwf   StackH
                                                  163:       endm
                                                  164:   
                                                  165:   loadNextCodeAddrTo  macro   CodeL, CodeH, CodeU
                                                  166:       TBLRD   *+                          ; Load Regsiter with the next 2
                                                  167:       movf    TABLAT, w                   ; bytes of the task descriptor,
                                                  168:       movwf   CodeL                       ; taskdesc entry pointed to by
                                                  169:       TBLRD   *+                          ; TBLPTR 
                                                  170:       movf    TABLAT, w
                                                  171:       movwf   CodeH
                                                  172:       TBLRD   *+                          ; TBLPTR 
                                                  173:       movf    TABLAT, w
                                                  174:       movwf   CodeU
                                                  175:       endm
                                                  176:   
                                                  177:   addStackSizeTo  macro   RegisterL, RegisterH
                                                  178:       TBLRD   *+                          ; By adding the stack size
                                                  179:       movf    TABLAT, w                   ; specified in the taskdesc,
                                                  180:       addwf   RegisterL, f                ; the designated Register will
                                                  181:       TBLRD   *+                          ; ==> Changed
                                                  182:       movf    TABLAT, w                   ; ==> Changed point to the end of stack
                                                  183:       addwfc  RegisterH, f                ; ==> Changed
                                                  184:       movlw   4
                                                  185:       subwf   RegisterL, f
                                                  186:       clrf    WREG
                                                  187:       subwfb  RegisterH, f
                                                  188:       endm
                                                  189:   
                                                  190:   setupStackSentinel    macro
                                                  191:       movlw   0xde                        ; Setup sentinel 0xadde, 2 bytes
                                                  192:       movwf   POSTINC1                    ; ahead of where FSR1 points to.
                                                  193:       movlw   0xad                        ; This is the sentinel to mark
                                                  194:       movwf   POSTINC1                    ; both start and end of stack,
                                                  195:       endm                                ; destroy of signature suggests
                                                  196:                                           ; stack overflow occurred, i.e.
                                                  197:                                           ; kernel panic
                                                  198:   locateTaskDescEntry   macro
                                                  199:       local   _matchTaskID, _nextTaskEntry, _found
                                                  200:       setupTBLPTR   taskdesc_addr         ; Locate the Task ID field of
                                                  201:       locateTaskIdField                   ; the 1st Task Descriptor entry
                                                  202:       movlb   0
                                                  203:   _matchTaskID  
                                                  204:       movf    id_tsk_run, w               ; Get current running Task ID
                                                  205:       TBLRD   *+                          ; Get the Task ID from taskdesc
                                                  206:       cpfseq  TABLAT                      ; entry, see if it's current Task
                                                  207:       bra     _nextTaskEntry              ; If not, proceed with next Task
                                                  208:       bra     _found                      ; else exit from the macro
                                                  209:   _nextTaskEntry
                                                  210:       movlw   9                           ; Move on to next Task entry by
                                                  211:       addwf   TBLPTRL, f                  ; offsetting TBLPTR with +9
                                                  212:       clrf    WREG
                                                  213:       addwfc  TBLPTRH, f
                                                  214:       addwfc  TBLPTRU, f
                                                  215:       bra     _matchTaskID                ; Go back to match task ID
                                                  216:   _found  
                                                  217:       endm
                                                  218:   
                                                  219:   ifSentinelDestroyGoto   macro place
                                                  220:       movff   POSTINC0, FSR1L             ; Check stack Sentinel, 0xadde
                                                  221:       movlw   0xde                        ; If the signature was not  
                                                  222:       cpfseq  FSR1L                       ; there any more then 
                                                  223:       goto    place                       ; go to the 'place' designated
                                                  224:       movlw   0xad
                                                  225:       movff   POSTINC0, FSR1L
                                                  226:       cpfseq  FSR1L
                                                  227:       goto    place
                                                  228:       endm
                                                  229:   
                                                  230:   markRunningTaskSuspended macro
                                                  231:       local   _nextTableEntry
                                                  232:       setupFSR0    tsk_1_state_ID-1
                                                  233:   _nextTableEntry
                                                  234:       incf    FSR0L                       ; Proceed all the way down to
                                                  235:       movlw   0x0F                        ; (taskID) changed from 0x1F
                                                  236:       andwf   INDF0, w                    ; tsk_xx_state_ID task control
                                                  237:       cpfseq  id_tsk_run                  ; table
                                                  238:       bra     _nextTableEntry
                                                  239:       bcf     INDF0, 5                    ; Mark the task as SUSPENDED
                                                  240:       bcf     INDF0, 6
                                                  241:       bcf     INDF0, 7
                                                  242:       endm    
                                                  243:   
                                                  244:   ;/**********************************************************************
                                                  245:   ; * ------------------------- KERNEL INIT ------------------------------
                                                  246:   ; *
                                                  247:   ; * Here is the init phase of the kernel, it means the main access to 
                                                  248:   ; * the kernel after StartOS call.
                                                  249:   ; *
                                                  250:   ; **********************************************************************/
                                                  251:   KERNEL_ROM  CODE
                                                  252:   _kernel
                                                  253:       GLOBAL  _kernel                     ; Beginning of kernel code
                                                  254:    
19EA  6AEA     CLRF FSR0H, ACCESS                 255:       clrf    FSR0H
19EC  6AE9     CLRF FSR0, ACCESS                  256:       clrf    FSR0L
19EE  6AE1     CLRF FSR1, ACCESS                  257:       clrf    FSR1L
19F0  6AE2     CLRF FSR1H, ACCESS                 258:       clrf    FSR1H
19F2  6AF8     CLRF TBLPTRU, ACCESS               259:       clrf    TBLPTRU
19F4  6AFA     CLRF PCLATH, ACCESS                260:       clrf    PCLATH
                                                  261:   
19F6  0EFF     MOVLW 0xFF                         262:       movlw   0xFF                        ; Clear the first RAM bank
                                                  263:   _kInitBank0
19F8  6AEE     CLRF POSTINC0, ACCESS              264:       clrf    POSTINC0
19FA  62E9     CPFSEQ FSR0, ACCESS                265:       cpfseq  FSR0L
19FC  D7FD     BRA 0x19F8                         266:       bra     _kInitBank0
19FE  6AEE     CLRF POSTINC0, ACCESS              267:       clrf    POSTINC0                    ; Clear last byte of the bank
                                                  268:       
1A00  6AEA     CLRF FSR0H, ACCESS                 269:       clrf    FSR0H                       ; Point FSR0 back to 0x0000
                                                  270:       
1A02  6AFC     CLRF STKPTR, ACCESS                271:       clrf    STKPTR                      ; Clear the hardware stack
1A04  0E1F     MOVLW 0x1F                         272:       movlw   0x1F                        ; Total 31 of H/W stack entries
                                                  273:   _kInitHardwareStack
1A06  2AFC     INCF STKPTR, F, ACCESS             274:       incf    STKPTR
1A08  6AFF     CLRF TOSU, ACCESS                  275:       clrf    TOSU
1A0A  6AFE     CLRF TOSH, ACCESS                  276:       clrf    TOSH
1A0C  6AFD     CLRF TOS, ACCESS                   277:       clrf    TOSL
1A0E  62FC     CPFSEQ STKPTR, ACCESS              278:       cpfseq  STKPTR
1A10  D7FA     BRA 0x1A06                         279:       bra     _kInitHardwareStack
                                                  280:       
1A12  6AFC     CLRF STKPTR, ACCESS                281:       clrf    STKPTR                      ; Is this redunant? later on
1A14  2AFC     INCF STKPTR, F, ACCESS             282:       incf    STKPTR                      ; inside _parser STKPTR will
                                                  283:                                           ; be set to 1 anyway
1A16  0E88     MOVLW 0x88                         284:       movlw   0x88                        ; No prescaler for Timer 0
1A18  6ED5     MOVWF T0CON, ACCESS                285:       movwf   T0CON
                                                  286:   
                                                  287:       ;clrf    PIE1
                                                  288:       ;clrf    PIE2
                                                  289:       ;clrf    RCON                       ; Removed from BETA3
                                                  290:       ;clrf    IPR1
                                                  291:       ;clrf    IPR2
1A1A  0E80     MOVLW 0x80                         292:       movlw   0x80
1A1C  6EF1     MOVWF INTCON2, ACCESS              293:       movwf   INTCON2                     
1A1E  8ED0     BSF RCON, 7, ACCESS                294:       bsf     RCON, 7                     ; IPEN enabled
                                                  295:   
1A20  0EA0     MOVLW 0xA0                         296:       movlw   0xA0                        ; GIEH enable
1A22  6EF2     MOVWF INTCON, ACCESS               297:       movwf   INTCON                      ; GIEL disabled (TMR0 enabled)
1A24  84F2     BSF INTCON, 2, ACCESS              298:       bsf     INTCON, 2                   ; Set TM0IF, force update on TMR0
                                                  299:   
1A26  8EF2     BSF INTCON, 7, ACCESS              300:       bsf     INTCON,7                    ; GIEH enabled, GIEL disabled
1A28  9CF2     BCF INTCON, 6, ACCESS              301:       bcf     INTCON,6                    ; 
                                                  302:       ;bcf     IPR1, 1                     ; Set Timer2 interrupt priority to low      * 
                                                  303:       ;bsf     PIE1, 1                     ; Enable Timer2 interrupt       
1A2A  8AF2     BSF INTCON, 5, ACCESS              304:       bsf     INTCON, 5                   ; TMR0 enabled        * 
1A2C  84F2     BSF INTCON, 2, ACCESS              305:       bsf     INTCON, 2                   ; Set TM0IF, force update on TMR0
                                                  306:   
                                                  307:   _parser
1A2E  0100     MOVLB 0x0                          308:       movlb   0                           ; Init
1A30  0E01     MOVLW 0x1                          309:       movlw   0x01
1A32  6EFC     MOVWF STKPTR, ACCESS               310:       movwf   STKPTR              
1A34  6B6F     CLRF 0x6F, BANKED                  311:       clrf    temp                
1A36  6F71     MOVWF 0x71, BANKED                 312:       movwf   permut                      ; Setup initial permutaion flag              
1A38  6B6D     CLRF 0x6D, BANKED                  313:       clrf    id_tsk_run                  ; No task running to begin with
1A3A  6AEA     CLRF FSR0H, ACCESS                 314:       setupFSR0    tsk_1_activ_prio       ; Locate tsk_xx_activ_prio table
1A3C  0EB0     MOVLW 0xB0
1A3E  6EE9     MOVWF FSR0, ACCESS
1A40  CE3A     MOVFF 0xE3A, TBLPTRU               315:       setupTBLPTR  taskdesc_addr          ; Locate 1st Task Desc. entry
1A42  FFF8     NOP
1A44  CE39     MOVFF 0xE39, TBLPTRH
1A46  FFF7     NOP
1A48  CE38     MOVFF taskdesc_addr, TBLPTR
1A4A  FFF6     NOP
                                                  316:   
                                                  317:   ;/* ------------ TASKDESC.C CONTENT PARSING -------------------------- */
                                                  318:   _parserInit
1A4C  0009     TBLRD*+                            319:       TBLRD   *+
1A4E  50F5     MOVF TABLAT, W, ACCESS             320:       movf    TABLAT, w
1A50  B4D8     BTFSC STATUS, 2, ACCESS            321:       btfsc   STATUS, Z                   ; Task Desc. ends with an entry
1A52  D03F     BRA 0x1AD2                         322:       bra     _parserUpdate               ; of all-Zero fileds
1A54  CFF5     MOVFF TABLAT, INDF0                323:       movff   TABLAT, INDF0               ; Extract & Setup task priority
1A56  FFEF     NOP
                                                  324:   
1A58  0009     TBLRD*+                            325:       loadNextStackAddrTo FSR1L, FSR1H    ; Extract & setup stack pointer
1A5A  50F5     MOVF TABLAT, W, ACCESS
1A5C  6EE1     MOVWF FSR1, ACCESS
1A5E  0009     TBLRD*+
1A60  50F5     MOVF TABLAT, W, ACCESS
1A62  6EE2     MOVWF FSR1H, ACCESS
                                                  326:   
1A64  0EDE     MOVLW 0xDE                         327:       setupStackSentinel                  ; Put a signature 0xadde in
1A66  6EE6     MOVWF POSTINC1, ACCESS
1A68  0EAD     MOVLW 0xAD
1A6A  6EE6     MOVWF POSTINC1, ACCESS
                                                  328:                                           ; front of the stack
                                                  329:       
1A6C  0009     TBLRD*+                            330:       TBLRD   *+                          ; Skip over the TASK addr field
1A6E  0009     TBLRD*+                            331:       TBLRD   *+                          ; 3 bytes : 24 bit address
1A70  0009     TBLRD*+                            332:       TBLRD   *+
                                                  333:   
1A72  98E9     BCF FSR0, 4, ACCESS                334:       bcf     FSR0L, 4                    ; Switch to tsk_xx_state_ID table
                                                  335:                                           ; by clearing bit 4, 0x0B0->0x0A0
1A74  0009     TBLRD*+                            336:       TBLRD   *+                          ; Extract & Setup task's state
1A76  50F5     MOVF TABLAT, W, ACCESS             337:       movf    TABLAT, w
1A78  26EF     ADDWF INDF0, F, ACCESS             338:       addwf   INDF0, f
                                                  339:   
1A7A  0009     TBLRD*+                            340:       TBLRD   *+                          ; Extract & Setup task ID
1A7C  50F5     MOVF TABLAT, W, ACCESS             341:       movf    TABLAT, w
1A7E  26EF     ADDWF INDF0, F, ACCESS             342:       addwf   INDF0, f
                                                  343:   
1A80  0009     TBLRD*+                            344:       TBLRD   *+                          ; ==> By adding the stack size
1A82  CFF5     MOVFF TABLAT, 0x74                 345:       movff   TABLAT, startAddressL       ; ==> specified in the taskdesc,
1A84  F074     NOP
1A86  000A     TBLRD*-                            346:       TBLRD   *-                          ; ==>
1A88  CFF5     MOVFF TABLAT, 0x75                 347:       movff   TABLAT, startAddressH       ; ==> point to the end of stack
1A8A  F075     NOP
                                                  348:   
1A8C  0009     TBLRD*+                            349:       addStackSizeTo  FSR1L, FSR1H
1A8E  50F5     MOVF TABLAT, W, ACCESS
1A90  26E1     ADDWF FSR1, F, ACCESS
1A92  0009     TBLRD*+
1A94  50F5     MOVF TABLAT, W, ACCESS
1A96  22E2     ADDWFC FSR1H, F, ACCESS
1A98  0E04     MOVLW 0x4
1A9A  5EE1     SUBWF FSR1, F, ACCESS
1A9C  6AE8     CLRF WREG, ACCESS
1A9E  5AE2     SUBWFB FSR1H, F, ACCESS
                                                  350:   
1AA0  0EDE     MOVLW 0xDE                         351:       setupStackSentinel                  ; Put a signature, 0xadde at
1AA2  6EE6     MOVWF POSTINC1, ACCESS
1AA4  0EAD     MOVLW 0xAD
1AA6  6EE6     MOVWF POSTINC1, ACCESS
                                                  352:                                           ; the end of the stack
                                                  353:       ; ==> ************ This code added for fill stack pattern 0xa5
1AA8  50E5     MOVF POSTDEC1, W, ACCESS           354:       movf    POSTDEC1, w                 ;
1AAA  50E5     MOVF POSTDEC1, W, ACCESS           355:       movf    POSTDEC1, w                 ;
1AAC  50E5     MOVF POSTDEC1, W, ACCESS           356:       movf    POSTDEC1, w                 ;
1AAE  0E07     MOVLW 0x7                          357:       movlw   7                           ; After extracting the task ID,
1AB0  5F74     SUBWF 0x74, F, BANKED              358:       subwf   startAddressL, f            ; Rewind the pointer back, to  
1AB2  6AE8     CLRF WREG, ACCESS                  359:       clrf    WREG                        ; point to stack address field
1AB4  5B75     SUBWFB 0x75, F, BANKED             360:       subwfb  startAddressH, f            ; of the current taskdesc entry
                                                  361:   
1AB6  0EA5     MOVLW 0xA5                         362:       movlw   0xa5
                                                  363:   _parser_mark_stack
1AB8  6EE5     MOVWF POSTDEC1, ACCESS             364:       movwf   POSTDEC1
1ABA  2F74     DECFSZ 0x74, F, BANKED             365:       decfsz  startAddressL, f
1ABC  D7FD     BRA 0x1AB8                         366:       bra     _parser_mark_stack
1ABE  5375     MOVF 0x75, F, BANKED               367:       movf    startAddressH, f
1AC0  E002     BZ 0x1AC6                          368:       bz      _parser_mark_stack_end
1AC2  0775     DECF 0x75, F, BANKED               369:       decf    startAddressH, f
1AC4  D7F9     BRA 0x1AB8                         370:       bra     _parser_mark_stack
                                                  371:   _parser_mark_stack_end
                                                  372:       ; ==> ***************
                                                  373:   
1AC6  2AE9     INCF FSR0, F, ACCESS               374:       incf    FSR0L                       ; Step to next task entry
1AC8  88E9     BSF FSR0, 4, ACCESS                375:       bsf     FSR0L, 4                    ; Point back to tsk_xx_activ_prio
1ACA  D7C0     BRA 0x1A4C                         376:       bra     _parserInit                 ; Loop back for next task
                                                  377:                                           ; in task descriptor
                                                  378:   _parser_organize
                                                  379:       GLOBAL  _parser_organize            ; If so requested externally
1ACC  0100     MOVLB 0x0                          380:       movlb   0                           ; Prioritize the TCTs
1ACE  6B71     CLRF 0x71, BANKED                  381:       clrf    permut
1AD0  2B71     INCF 0x71, F, BANKED               382:       incf    permut      
                                                  383:   
                                                  384:   ;/* - REARRANGE TASK ORDER IN EACH TCT, BASED ON DESCENDING PRIORITY - */
                                                  385:   _parserUpdate
1AD2  6AEA     CLRF FSR0H, ACCESS                 386:       setupFSR0    tsk_1_activ_prio
1AD4  0EB0     MOVLW 0xB0
1AD6  6EE9     MOVWF FSR0, ACCESS
1AD8  5171     MOVF 0x71, W, BANKED               387:       movf    permut, w                   ; Is there a bubble in the last
1ADA  B4D8     BTFSC STATUS, 2, ACCESS            388:       btfsc   STATUS, Z                   ; iteration?
1ADC  D02C     BRA 0x1B36                         389:       bra     _isHook                     ; If No, means TCTs prioritized
1ADE  6B71     CLRF 0x71, BANKED                  390:       clrf    permut                      ; If Yes, sort still in progress
                                                  391:                                           ; Clear permutation flag for this
                                                  392:                                           ; iteration (Bubble sort is used)
                                                  393:   _parserUpdateLoop 
1AE0  0E0F     MOVLW 0xF                          394:       movlw   0x0F
1AE2  14EF     ANDWF INDF0, W, ACCESS             395:       andwf   INDF0, w
1AE4  6F6F     MOVWF 0x6F, BANKED                 396:       movwf   temp                        ; Extract task's priority
1AE6  B4D8     BTFSC STATUS, 2, ACCESS            397:       btfsc   STATUS, Z                   ; 0 signifies the end of TCT
1AE8  D7F4     BRA 0x1AD2                         398:       bra     _parserUpdate               ; If end of task atble, loop back
                                                  399:                                           ; for next bubble sort iteration 
1AEA  CFEF     MOVFF INDF0, 0x70                  400:       movff   INDF0, temp2                ; Else backup (activ + prio) byte
1AEC  F070     NOP
1AEE  0E0F     MOVLW 0xF                          401:       movlw   0x0F
1AF0  14EC     ANDWF PREINC0, W, ACCESS           402:       andwf   PREINC0, w                  ; Extract next task's priority
                                                  403:   
1AF2  636F     CPFSEQ 0x6F, BANKED                404:       cpfseq  temp
1AF4  D001     BRA 0x1AF8                         405:       bra     _parserUpdateDiff
1AF6  D7F4     BRA 0x1AE0                         406:       bra     _parserUpdateLoop           ; Equal priority, Loopback for
                                                  407:                                           ; the next control table entry
                                                  408:   _parserUpdateDiff
1AF8  656F     CPFSGT 0x6F, BANKED                409:       cpfsgt  temp
1AFA  D001     BRA 0x1AFE                         410:       bra     _parserUpdateSwap           ; Go swap on low priority
1AFC  D7F1     BRA 0x1AE0                         411:       bra     _parserUpdateLoop           ; Loopback if priority in place
                                                  412:   
                                                  413:   _parserUpdateSwap
1AFE  50ED     MOVF POSTDEC0, W, ACCESS           414:       movf    POSTDEC0, w                 ; Swap entry in tsk_xx_activ_prio
1B00  6EEE     MOVWF POSTINC0, ACCESS             415:       movwf   POSTINC0                    ; located at 0x0B0
1B02  C070     MOVFF 0x70, INDF0                  416:       movff   temp2, INDF0
1B04  FFEF     NOP
                                                  417:   
1B06  98E9     BCF FSR0, 4, ACCESS                418:       bcf     FSR0L, 4                    ; Swap entry in tsk_xx_state_ID
1B08  CFED     MOVFF POSTDEC0, 0x70               419:       swapTaskCtrlEntry                   ; located at 0x0A0
1B0A  F070     NOP
1B0C  50EF     MOVF INDF0, W, ACCESS
1B0E  C070     MOVFF temp2, POSTINC0
1B10  FFEE     NOP
1B12  6EEF     MOVWF INDF0, ACCESS
                                                  420:   
1B14  9AE9     BCF FSR0, 5, ACCESS                421:       bcf     FSR0L, 5                    ; Swap the task entry in event_xx
1B16  CFED     MOVFF POSTDEC0, 0x70               422:       swapTaskCtrlEntry                   ; located at 0x080
1B18  F070     NOP
1B1A  50EF     MOVF INDF0, W, ACCESS
1B1C  C070     MOVFF temp2, POSTINC0
1B1E  FFEE     NOP
1B20  6EEF     MOVWF INDF0, ACCESS
                                                  423:   
1B22  88E9     BSF FSR0, 4, ACCESS                424:       bsf     FSR0L, 4                    ; Swap the task entry in wait_xx
1B24  CFED     MOVFF POSTDEC0, 0x70               425:       swapTaskCtrlEntry                   ; located at 0x090
1B26  F070     NOP
1B28  50EF     MOVF INDF0, W, ACCESS
1B2A  C070     MOVFF temp2, POSTINC0
1B2C  FFEE     NOP
1B2E  6EEF     MOVWF INDF0, ACCESS
                                                  426:   
1B30  8AE9     BSF FSR0, 5, ACCESS                427:       bsf     FSR0L, 5                    ; Point back to tsk_xx_activ_prio
1B32  2B71     INCF 0x71, F, BANKED               428:       incf    permut                      ; Raise the permutation flag to
                                                  429:                                           ; signify a swap has occurred
1B34  D7D5     BRA 0x1AE0                         430:       bra     _parserUpdateLoop 
                                                  431:   
                                                  432:   _isHook                                 ; Hook kernel service routine
                                                  433:       #IFDEF  STARTUPHOOK
                                                  434:           call    StartupHook
                                                  435:       #ENDIF
                                                  436:   
                                                  437:   ;/**********************************************************************
                                                  438:   ; * --------------------- KERNEL TASK SCHEDULER ------------------------
                                                  439:   ; *
                                                  440:   ; * The scheduler manage the task switching during application running.
                                                  441:   ; *
                                                  442:   ; **********************************************************************/
                                                  443:   _sched
                                                  444:       GLOBAL  _sched
                                                  445:       #IFDEF  POSTTASKHOOK
                                                  446:           call    PostTaskHook
                                                  447:       #ENDIF
                                                  448:   
1B36  0100     MOVLB 0x0                          449:       movlb   0
1B38  9172     BCF 0x72, 0, BANKED                450:       bcf     kernelState, 0              ; Switch to KERNEL mode
1B3A  3B6E     SWAPF 0x6E, F, BANKED              451:       swapf   id_tsk_pre, f               ; ==> Tasks History
1B3C  0EF0     MOVLW 0xF0                         452:       movlw   0xf0                        ; ==> Consist two last active
1B3E  176E     ANDWF 0x6E, F, BANKED              453:       andwf   id_tsk_pre, f               ; ==> tasks, include idle (=0)
1B40  516D     MOVF 0x6D, W, BANKED               454:       movf    id_tsk_run, w               ; ==> 
1B42  276E     ADDWF 0x6E, F, BANKED              455:       addwf   id_tsk_pre, f               ; ==> 
1B44  516D     MOVF 0x6D, W, BANKED               456:       movf    id_tsk_run, w
1B46  B4D8     BTFSC STATUS, 2, ACCESS            457:       btfsc   STATUS, Z                   ; Is running task 0 or not?
1B48  D030     BRA 0x1BAA                         458:       bra     _schedPickNext2Run          ; Branch if 0, no task RUNNING,
                                                  459:                                           ; Legal taskID: 1~15, 0 -> none
1B4A  6AEA     CLRF FSR0H, ACCESS                 460:       setupFSR0    tsk_1_state_ID-1       ; Locate tsk_1_state_ID table
1B4C  0E9F     MOVLW 0x9F
1B4E  6EE9     MOVWF FSR0, ACCESS
                                                  461:   
                                                  462:   _schedFindRunningTaskEntry
1B50  2AE9     INCF FSR0, F, ACCESS               463:       incf    FSR0L
1B52  0E0F     MOVLW 0xF                          464:       movlw   0x0F                        ; ==> Changed from 0x1F
1B54  14EF     ANDWF INDF0, W, ACCESS             465:       andwf   INDF0, w
1B56  636D     CPFSEQ 0x6D, BANKED                466:       cpfseq  id_tsk_run                  ; Locate RUNNING task's entry
1B58  D7FB     BRA 0x1B50                         467:       bra     _schedFindRunningTaskEntry  ; Proceed to next task entry
1B5A  9CEF     BCF INDF0, 6, ACCESS               468:       bcf     INDF0, 6                    ; Mark the task: no more RUNNING
1B5C  6B6D     CLRF 0x6D, BANKED                  469:       clrf    id_tsk_run                  ; Set running task ID to "none"
                                                  470:   
1B5E  88E9     BSF FSR0, 4, ACCESS                471:       bsf     FSR0L, 4                    ; Point to tsk_xx_activ_prio TCT
1B60  0E0F     MOVLW 0xF                          472:       movlw   0x0F                        ; Original code uses 0x0E, why?
1B62  14EF     ANDWF INDF0, W, ACCESS             473:       andwf   INDF0, w
1B64  6F6F     MOVWF 0x6F, BANKED                 474:       movwf   temp                        ; Extract & save task priority
                                                  475:                                           ; for later matching use
                                                  476:   _testIfSamePriority
1B66  0E0F     MOVLW 0xF                          477:       movlw   0x0F                        ; Original code uses 0x0E, why?
1B68  14EC     ANDWF PREINC0, W, ACCESS           478:       andwf   PREINC0, w
1B6A  636F     CPFSEQ 0x6F, BANKED                479:       cpfseq  temp                        ; Is it with the same priority?
1B6C  D01E     BRA 0x1BAA                         480:       bra     _schedPickNext2Run          ; Branch to schedule if not
1B6E  D000     BRA 0x1B70                         481:       bra     _RoundRobin4SamePriority    ; Else Proceed with Round Robin
                                                  482:                                           ; setup for the task
                                                  483:   _RoundRobin4SamePriority
1B70  CFED     MOVFF POSTDEC0, 0x70               484:       swapTaskCtrlEntry                   ; Tasks having the same priority,
1B72  F070     NOP
1B74  50EF     MOVF INDF0, W, ACCESS
1B76  C070     MOVFF temp2, POSTINC0
1B78  FFEE     NOP
1B7A  6EEF     MOVWF INDF0, ACCESS
                                                  485:                                           ; Round Robin method used, and
                                                  486:                                           ; current task will be swapped
                                                  487:                                           ; all the way to the bottom of
                                                  488:                                           ; the tasks with same priority
1B7C  98E9     BCF FSR0, 4, ACCESS                489:       bcf     FSR0L, 4                    ; Swap tsk_xx_state_ID task entry
1B7E  CFED     MOVFF POSTDEC0, 0x70               490:       swapTaskCtrlEntry
1B80  F070     NOP
1B82  50EF     MOVF INDF0, W, ACCESS
1B84  C070     MOVFF temp2, POSTINC0
1B86  FFEE     NOP
1B88  6EEF     MOVWF INDF0, ACCESS
1B8A  9AE9     BCF FSR0, 5, ACCESS                491:       bcf     FSR0L, 5                    ; Swap event_xx task entry
1B8C  CFED     MOVFF POSTDEC0, 0x70               492:       swapTaskCtrlEntry
1B8E  F070     NOP
1B90  50EF     MOVF INDF0, W, ACCESS
1B92  C070     MOVFF temp2, POSTINC0
1B94  FFEE     NOP
1B96  6EEF     MOVWF INDF0, ACCESS
1B98  88E9     BSF FSR0, 4, ACCESS                493:       bsf     FSR0L, 4                    ; Swap wait_xx task entry
1B9A  CFED     MOVFF POSTDEC0, 0x70               494:       swapTaskCtrlEntry
1B9C  F070     NOP
1B9E  50EF     MOVF INDF0, W, ACCESS
1BA0  C070     MOVFF temp2, POSTINC0
1BA2  FFEE     NOP
1BA4  6EEF     MOVWF INDF0, ACCESS
1BA6  8AE9     BSF FSR0, 5, ACCESS                495:       bsf     FSR0L, 5                    ; Point back to tsk_xx_activ_prio
1BA8  D7DE     BRA 0x1B66                         496:       bra     _testIfSamePriority
                                                  497:       
                                                  498:   _schedPickNext2Run
1BAA  6AEA     CLRF FSR0H, ACCESS                 499:       setupFSR0    tsk_1_state_ID-1       ; Top down and hence prioritized,
1BAC  0E9F     MOVLW 0x9F
1BAE  6EE9     MOVWF FSR0, ACCESS
                                                  500:                                           ; fetching next candiadte to run    
                                                  501:   _schedTaskReadyOrNot
1BB0  2AE9     INCF FSR0, F, ACCESS               502:       incf    FSR0L
1BB2  AAEF     BTFSS INDF0, 5, ACCESS             503:       btfss   INDF0, 5                    ; READY ?
1BB4  D06F     BRA 0x1C94                         504:       bra     _schedTestEndOfCtrlTable    ; Proceed to next if not READY
1BB6  BEEF     BTFSC INDF0, 7, ACCESS             505:       btfsc   INDF0, 7                    ; WAITING?
1BB8  D06D     BRA 0x1C94                         506:       bra     _schedTestEndOfCtrlTable    ; It's READY, however WAITING
                                                  507:                                           ; for certain event
1BBA  0100     MOVLB 0x0                          508:       movlb   0                           ; If READY and not WAITING then
1BBC  8CEF     BSF INDF0, 6, ACCESS               509:       bsf     INDF0, 6                    ; Mark the task in RUNNING state
1BBE  0E0F     MOVLW 0xF                          510:       movlw   0x0F                        ; ==> Changed from 0x1F
1BC0  14EF     ANDWF INDF0, W, ACCESS             511:       andwf   INDF0, w
1BC2  6F6D     MOVWF 0x6D, BANKED                 512:       movwf   id_tsk_run                  ; Designate the task in RUNNING
                                                  513:   
                                                  514:       #IFDEF  PRETASKHOOK                 ; Hook kernel service routine
1BC4  ECF5     CALL 0x35EA, 0                     515:           call    PreTaskHook
1BC6  F01A     NOP
                                                  516:       #ENDIF
                                                  517:       
                                                  518:   ;/**********************************************************************
                                                  519:   ; * ------------------------- RESTORE CONTEXT --------------------------
                                                  520:   ; *
                                                  521:   ; * Copy the content of the context (task ram area) into Special File 
                                                  522:   ; * Registers.
                                                  523:   ; *
                                                  524:   ; **********************************************************************/
                                                  525:   _restore_ctx
                                                  526:       GLOBAL  _restore_ctx
                                                  527:       
1BC8  0100     MOVLB 0x0                          528:       movlb   0
1BCA  8172     BSF 0x72, 0, BANKED                529:       bsf     kernelState, 0              ; Change the kernel to USER mode
1BCC  CE3A     MOVFF 0xE3A, TBLPTRU               530:       locateTaskDescEntry
1BCE  FFF8     NOP
1BD0  CE39     MOVFF 0xE39, TBLPTRH
1BD2  FFF7     NOP
1BD4  CE38     MOVFF taskdesc_addr, TBLPTR
1BD6  FFF6     NOP
1BD8  0E07     MOVLW 0x7
1BDA  26F6     ADDWF TBLPTR, F, ACCESS
1BDC  6AE8     CLRF WREG, ACCESS
1BDE  22F7     ADDWFC TBLPTRH, F, ACCESS
1BE0  22F8     ADDWFC TBLPTRU, F, ACCESS
1BE2  0100     MOVLB 0x0
1BE4  516D     MOVF id_tsk_run, W, BANKED
1BE6  0009     TBLRD*+
1BE8  62F5     CPFSEQ TABLAT, ACCESS
1BEA  D001     BRA _17_nextTaskEntry
1BEC  D006     BRA _17_found
1BEE  0E09     MOVLW 0x9
1BF0  26F6     ADDWF TBLPTR, F, ACCESS
1BF2  6AE8     CLRF WREG, ACCESS
1BF4  22F7     ADDWFC TBLPTRH, F, ACCESS
1BF6  22F8     ADDWFC TBLPTRU, F, ACCESS
1BF8  D7F5     BRA _17_matchTaskID
1BFA  0E07     MOVLW 0x7                          531:       locateStackAddrField   
1BFC  5EF6     SUBWF TBLPTR, F, ACCESS
1BFE  6AE8     CLRF WREG, ACCESS
1C00  5AF7     SUBWFB TBLPTRH, F, ACCESS
1C02  5AF8     SUBWFB TBLPTRU, F, ACCESS
1C04  0009     TBLRD*+                            532:       loadNextStackAddrTo FSR0L, FSR0H    ; Extract task's stack addr
1C06  50F5     MOVF TABLAT, W, ACCESS
1C08  6EE9     MOVWF FSR0, ACCESS
1C0A  0009     TBLRD*+
1C0C  50F5     MOVF TABLAT, W, ACCESS
1C0E  6EEA     MOVWF FSR0H, ACCESS
1C10  0009     TBLRD*+                            533:       loadNextCodeAddrTo startAddressL, startAddressH, startAddressU
1C12  50F5     MOVF TABLAT, W, ACCESS
1C14  6F74     MOVWF startAddressL, BANKED
1C16  0009     TBLRD*+
1C18  50F5     MOVF TABLAT, W, ACCESS
1C1A  6F75     MOVWF startAddressH, BANKED
1C1C  0009     TBLRD*+
1C1E  50F5     MOVF TABLAT, W, ACCESS
1C20  6F76     MOVWF startAddressU, BANKED
                                                  534:                                           ; Extract task's code addr
                                                  535:   ; Go chech whether the stack overflow occurred
1C22  EF73     GOTO 0x1CE6                        536:       goto    _checkPanic
1C24  F00E     NOP
                                                  537:   
                                                  538:   ; If the stack remains intact, restore the task's context
                                                  539:   _restore_now
                                                  540:       GLOBAL  _restore_now
1C26  0100     MOVLB 0x0                          541:       movlb   0
1C28  CFE5     MOVFF POSTDEC1, 0x6F               542:       movff   POSTDEC1, temp
1C2A  F06F     NOP
1C2C  CFE5     MOVFF POSTDEC1, 0x6F               543:       movff   POSTDEC1, temp              ; Extract # of H/W stack entries
1C2E  F06F     NOP
1C30  6AFC     CLRF STKPTR, ACCESS                544:       clrf    STKPTR                      ; backed up previously
                                                  545:       
                                                  546:   restoreNextHardwareStack
1C32  0005     PUSH                               547:       push                                ; push to make room for restoring
1C34  50E5     MOVF POSTDEC1, W, ACCESS           548:       movf    POSTDEC1, w                 ; hardware stack entries
1C36  6EFF     MOVWF TOSU, ACCESS                 549:       movwf   TOSU
1C38  50E5     MOVF POSTDEC1, W, ACCESS           550:       movf    POSTDEC1, w
1C3A  6EFE     MOVWF TOSH, ACCESS                 551:       movwf   TOSH
1C3C  50E5     MOVF POSTDEC1, W, ACCESS           552:       movf    POSTDEC1, w
1C3E  6EFD     MOVWF TOS, ACCESS                  553:       movwf   TOSL                        ; Restore one H/W stack entry
1C40  50FC     MOVF STKPTR, W, ACCESS             554:       movf    STKPTR, w
1C42  636F     CPFSEQ 0x6F, BANKED                555:       cpfseq  temp                        ; Is H/W stack restore done? 
1C44  D7F6     BRA 0x1C32                         556:       bra     restoreNextHardwareStack    ; Loopback to next restore If not
                                                  557:   
1C46  6AEA     CLRF FSR0H, ACCESS                 558:       setupFSR0    TEMP_SIZE-1            ; Load FSR0, to point to the end
1C48  0E1D     MOVLW 0x1D
1C4A  6EE9     MOVWF FSR0, ACCESS
                                                  559:                                           ; of .tmpdata + MATH_DATA section 
                                                  560:   restoreNextTmpdataByte
1C4C  CFE5     MOVFF POSTDEC1, POSTDEC0           561:       movff   POSTDEC1, POSTDEC0          ; Restore .tmpdata + MATH_DATA
1C4E  FFED     NOP
1C50  50E9     MOVF FSR0, W, ACCESS               562:       movf    FSR0L, w                    ; section
1C52  A8D8     BTFSS STATUS, 4, ACCESS            563:       btfss   STATUS, N
1C54  D7FB     BRA 0x1C4C                         564:       bra     restoreNextTmpdataByte
                                                  565:   
1C56  CFE5     MOVFF POSTDEC1, PCLATH             566:       movff   POSTDEC1, PCLATH            ; ==> Added
1C58  FFFA     NOP
1C5A  CFE5     MOVFF POSTDEC1, PCLATU             567:       movff   POSTDEC1, PCLATU            ; ==> Added
1C5C  FFFB     NOP
1C5E  CFE5     MOVFF POSTDEC1, PROD               568:       movff   POSTDEC1, PRODL             ; Restore the rest of SFRs saved
1C60  FFF3     NOP
1C62  CFE5     MOVFF POSTDEC1, PRODH              569:       movff   POSTDEC1, PRODH             ; in previously task swapping out
1C64  FFF4     NOP
1C66  CFE5     MOVFF POSTDEC1, TABLAT             570:       movff   POSTDEC1, TABLAT
1C68  FFF5     NOP
1C6A  CFE5     MOVFF POSTDEC1, TBLPTR             571:       movff   POSTDEC1, TBLPTRL
1C6C  FFF6     NOP
1C6E  CFE5     MOVFF POSTDEC1, TBLPTRH            572:       movff   POSTDEC1, TBLPTRH
1C70  FFF7     NOP
1C72  CFE5     MOVFF POSTDEC1, TBLPTRU            573:       movff   POSTDEC1, TBLPTRU
1C74  FFF8     NOP
1C76  CFE5     MOVFF POSTDEC1, FSR0H              574:       movff   POSTDEC1, FSR0H
1C78  FFEA     NOP
1C7A  CFE5     MOVFF POSTDEC1, FSR0               575:       movff   POSTDEC1, FSR0L
1C7C  FFE9     NOP
1C7E  CFE5     MOVFF POSTDEC1, FSR2H              576:       movff   POSTDEC1, FSR2H
1C80  FFDA     NOP
1C82  CFE5     MOVFF POSTDEC1, FSR2               577:       movff   POSTDEC1, FSR2L
1C84  FFD9     NOP
1C86  CFE5     MOVFF POSTDEC1, BSR                578:       movff   POSTDEC1, BSR
1C88  FFE0     NOP
1C8A  CFE5     MOVFF POSTDEC1, WREG               579:       movff   POSTDEC1, WREG
1C8C  FFE8     NOP
1C8E  CFE5     MOVFF POSTDEC1, STATUS             580:       movff   POSTDEC1, STATUS
1C90  FFD8     NOP
                                                  581:   
                                                  582:   ;    bsf     INTCON, 6                   ; ==> Removed Enable OS/low prior. interrupt
1C92  0010     RETFIE 0                           583:       retfie                              ; Exit to where TOS pointed at
                                                  584:       
                                                  585:   _schedTestEndOfCtrlTable
1C94  0EAF     MOVLW 0xAF                         586:       movlw   tsk_16_state_ID             ; Check for task ctrl table end
1C96  5CE9     SUBWF FSR0, W, ACCESS              587:       subwf   FSR0L, w
1C98  E18B     BNZ 0x1BB0                         588:       bnz     _schedTaskReadyOrNot
                                                  589:   
                                                  590:   	; ==> *********************** Changed and Added for Idle
1C9A  CE3B     MOVFF 0xE3B, 0x6C                  591:       movff   FSR1H_MAIN, stack_high           ; No more READY to run, swing
1C9C  F06C     NOP
1C9E  CE3C     MOVFF 0xE3C, 0x6B                  592:       movff   FSR1L_MAIN, stack_low           ; stack pointer back to point
1CA0  F06B     NOP
1CA2  0100     MOVLB 0x0                          593:       movlb   high(stack_low)
1CA4  0E02     MOVLW 0x2                          594:       movlw   0x02
1CA6  276B     ADDWF 0x6B, F, BANKED              595:       addwf   stack_low, f
1CA8  6AE8     CLRF WREG, ACCESS                  596:       clrf    WREG
1CAA  236C     ADDWFC 0x6C, F, BANKED             597:       addwfc  stack_high, f
1CAC  0E02     MOVLW 0x2                          598:       movlw   0x02
1CAE  256B     ADDWF 0x6B, W, BANKED              599:       addwf   stack_low, w
1CB0  6EE1     MOVWF FSR1, ACCESS                 600:       movwf   FSR1L
1CB2  6ED9     MOVWF FSR2, ACCESS                 601:       movwf   FSR2L
1CB4  6AE8     CLRF WREG, ACCESS                  602:       clrf    WREG
1CB6  216C     ADDWFC 0x6C, W, BANKED             603:       addwfc  stack_high, w
1CB8  6EE2     MOVWF FSR1H, ACCESS                604:       movwf   FSR1H
1CBA  6EDA     MOVWF FSR2H, ACCESS                605:       movwf   FSR2H
                                                  606:                                           ; to main AP stack
                                                  607:       ; ==> ***********************
1CBC  0100     MOVLB 0x0                          608:   _whileIdle    movlb   0                           ; No task running
1CBE  8CF2     BSF INTCON, 6, ACCESS              609:       bsf     INTCON, 6                   ; Enable OS/low prior. interrupt
1CC0  6AFC     CLRF STKPTR, ACCESS                610:       clrf    STKPTR                         ; waiting for any event to occur
1CC2  D7FC     BRA 0x1CBC                         611:       bra     _whileIdle
                                                  612:   
                                                  613:   
                                                  614:   immediat_ret
1CC4  CFE9     MOVFF FSR0, FSR1                   615:       movff   FSR0L, FSR1L                ; Here FSR0 seems to have task's
1CC6  FFE1     NOP
1CC8  CFE9     MOVFF FSR0, FSR2                   616:       movff   FSR0L, FSR2L                ; stack address + 2
1CCA  FFD9     NOP
1CCC  CFEA     MOVFF FSR0H, FSR1H                 617:       movff   FSR0H, FSR1H
1CCE  FFE2     NOP
1CD0  CFEA     MOVFF FSR0H, FSR2H                 618:       movff   FSR0H, FSR2H
1CD2  FFDA     NOP
                                                  619:   
1CD4  6AFC     CLRF STKPTR, ACCESS                620:       clrf    STKPTR                      ; Faking TOS with a pointer to
1CD6  2AFC     INCF STKPTR, F, ACCESS             621:       incf    STKPTR                      ; task's start Address as if
1CD8  5174     MOVF 0x74, W, BANKED               622:       movf    startAddressL, w            ; there was a CALL right before
1CDA  6EFD     MOVWF TOS, ACCESS                  623:       movwf   TOSL                        ; task's start Address
1CDC  5175     MOVF 0x75, W, BANKED               624:       movf    startAddressH, w
1CDE  6EFE     MOVWF TOSH, ACCESS                 625:       movwf   TOSH
1CE0  5176     MOVF 0x76, W, BANKED               626:       movf    startAddressU, w
1CE2  6EFF     MOVWF TOSU, ACCESS                 627:       movwf   TOSU
                                                  628:   ;    bsf     INTCON, 6                   ; ==> Removed Enable OS/low prior. interrupt
1CE4  0010     RETFIE 0                           629:       retfie                              ; Branch to Task's code
                                                  630:   
                                                  631:   ;/**********************************************************************
                                                  632:   ; * --------------------- CHECK STACK OVERFLOW -------------------------
                                                  633:   ; *
                                                  634:   ; **********************************************************************/
                                                  635:   _checkPanic
                                                  636:   
                                                  637:   ; Check 0xadde signature/sentinel before the start of the task's stack
1CE6  CFEE     MOVFF POSTINC0, FSR1               638:       ifSentinelDestroyGoto   _kernelPanicTrashedByNeighbor
1CE8  FFE1     NOP
1CEA  0EDE     MOVLW 0xDE
1CEC  62E1     CPFSEQ FSR1, ACCESS
1CEE  EFA8     GOTO 0x1D50
1CF0  F00E     NOP
1CF2  0EAD     MOVLW 0xAD
1CF4  CFEE     MOVFF POSTINC0, FSR1
1CF6  FFE1     NOP
1CF8  62E1     CPFSEQ FSR1, ACCESS
1CFA  EFA8     GOTO 0x1D50
1CFC  F00E     NOP
                                                  639:   
1CFE  CFE9     MOVFF FSR0, 0x6B                   640:       movff   FSR0L, stack_low            ; Save a copy of stack pointer
1D00  F06B     NOP
1D02  CFEA     MOVFF FSR0H, 0x6C                  641:       movff   FSR0H, stack_high           ; for later recovery
1D04  F06C     NOP
                                                  642:   
                                                  643:   ;    locateTaskDescEntry		; ==> Removed
1D06  0009     TBLRD*+                            644:       TBLRD   *+                          ; ==> Move TBLPTR to 
1D08  0009     TBLRD*+                            645:       TBLRD   *+                          ; ==> the stack size
1D0A  0009     TBLRD*+                            646:       addStackSizeTo  FSR0L, FSR0H
1D0C  50F5     MOVF TABLAT, W, ACCESS
1D0E  26E9     ADDWF FSR0, F, ACCESS
1D10  0009     TBLRD*+
1D12  50F5     MOVF TABLAT, W, ACCESS
1D14  22EA     ADDWFC FSR0H, F, ACCESS
1D16  0E04     MOVLW 0x4
1D18  5EE9     SUBWF FSR0, F, ACCESS
1D1A  6AE8     CLRF WREG, ACCESS
1D1C  5AEA     SUBWFB FSR0H, F, ACCESS
                                                  647:   
                                                  648:   ; Check 0xadde signature/sentinel before the end of the task's stack
1D1E  CFEE     MOVFF POSTINC0, FSR1               649:       ifSentinelDestroyGoto   _kernelPanicStackOverflow
1D20  FFE1     NOP
1D22  0EDE     MOVLW 0xDE
1D24  62E1     CPFSEQ FSR1, ACCESS
1D26  EFBA     GOTO 0x1D74
1D28  F00E     NOP
1D2A  0EAD     MOVLW 0xAD
1D2C  CFEE     MOVFF POSTINC0, FSR1
1D2E  FFE1     NOP
1D30  62E1     CPFSEQ FSR1, ACCESS
1D32  EFBA     GOTO 0x1D74
1D34  F00E     NOP
                                                  650:   
                                                  651:   _restore_stack                          ; ==> Added
                                                  652:       GLOBAL  _restore_stack              ; ==> Added
1D36  C06B     MOVFF 0x6B, FSR0                   653:       movff   stack_low, FSR0L            ; Restore FSR0 to task's 
1D38  FFE9     NOP
1D3A  C06C     MOVFF 0x6C, FSR0H                  654:       movff   stack_high, FSR0H           ; stack address
1D3C  FFEA     NOP
1D3E  CFEE     MOVFF POSTINC0, FSR1               655:       movff   POSTINC0, FSR1L             ; Popup from stack top,
1D40  FFE1     NOP
1D42  CFEE     MOVFF POSTINC0, FSR1H              656:       movff   POSTINC0, FSR1H             ; and setup FSR1 to point to
1D44  FFE2     NOP
                                                  657:                                           ; where context were saved
                                                  658:                                           ; ==> Any commands removed
1D46  50E1     MOVF FSR1, W, ACCESS               659:       movf    FSR1L, w                    ; Non-null means there is a
1D48  10E2     IORWF FSR1H, W, ACCESS             660:       iorwf   FSR1H, w                    ; previous saved context to
1D4A  B4D8     BTFSC STATUS, 2, ACCESS            661:       btfsc   STATUS, Z                   ; be restored
1D4C  D7BB     BRA 0x1CC4                         662:       bra     immediat_ret                ; Return immediately if FSR1==0
1D4E  D76B     BRA 0x1C26                         663:       bra     _restore_now                ; else restore the context
                                                  664:   
                                                  665:   _kernelPanicTrashedByNeighbor
1D50  6AEA     CLRF FSR0H, ACCESS                 666:       markRunningTaskSuspended            ; Chances are stack overflow of
1D52  0E9F     MOVLW 0x9F
1D54  6EE9     MOVWF FSR0, ACCESS
1D56  2AE9     INCF FSR0, F, ACCESS
1D58  0E0F     MOVLW 0xF
1D5A  14EF     ANDWF INDF0, W, ACCESS
1D5C  636D     CPFSEQ id_tsk_run, BANKED
1D5E  D7FB     BRA _27_nextTableEntry
1D60  9AEF     BCF INDF0, 5, ACCESS
1D62  9CEF     BCF INDF0, 6, ACCESS
1D64  9EEF     BCF INDF0, 7, ACCESS
1D66  C073     MOVFF 0x73, WREG                   667:       movff   kernelPanic, WREG           ; another task is jeopardizing
1D68  FFE8     NOP
1D6A  0BF0     ANDLW 0xF0                         668:       andlw   0xF0                        ; current task
1D6C  256D     ADDWF 0x6D, W, BANKED              669:       addwf   id_tsk_run, w
1D6E  CFE8     MOVFF WREG, 0x73                   670:       movff   WREG, kernelPanic           ; Log the task in right nibble
1D70  F073     NOP
1D72  D6E1     BRA 0x1B36                         671:       bra     _sched                      ; of the kernelpanic
                                                  672:   
                                                  673:   _kernelPanicStackOverflow
1D74  6AEA     CLRF FSR0H, ACCESS                 674:       markRunningTaskSuspended            ; Stack overflow found
1D76  0E9F     MOVLW 0x9F
1D78  6EE9     MOVWF FSR0, ACCESS
1D7A  2AE9     INCF FSR0, F, ACCESS
1D7C  0E0F     MOVLW 0xF
1D7E  14EF     ANDWF INDF0, W, ACCESS
1D80  636D     CPFSEQ id_tsk_run, BANKED
1D82  D7FB     BRA _29_nextTableEntry
1D84  9AEF     BCF INDF0, 5, ACCESS
1D86  9CEF     BCF INDF0, 6, ACCESS
1D88  9EEF     BCF INDF0, 7, ACCESS
                                                  675:       #IFDEF  RESET_ON_PANIC              ; Reset in case of KERNEL PANIC
                                                  676:           reset                           ; if so requested
                                                  677:       #ENDIF
1D8A  C073     MOVFF 0x73, WREG                   678:       movff   kernelPanic, WREG
1D8C  FFE8     NOP
1D8E  38E8     SWAPF WREG, W, ACCESS              679:       swapf   WREG, w
1D90  0BF0     ANDLW 0xF0                         680:       andlw   0xF0
1D92  256D     ADDWF 0x6D, W, BANKED              681:       addwf   id_tsk_run, w
1D94  38E8     SWAPF WREG, W, ACCESS              682:       swapf   WREG, w
1D96  CFE8     MOVFF WREG, 0x73                   683:       movff   WREG, kernelPanic           ; Log the task ID in left nibble
1D98  F073     NOP
1D9A  D6CD     BRA 0x1B36                         684:       bra     _sched                      ; of the kernelpanic
                                                  685:   
                                                  686:   ;/**********************************************************************
                                                  687:   ; * ----------------------- FOR BASIC TASK ONLY ------------------------
                                                  688:   ; *
                                                  689:   ; * After terminating a task, we loose the start address of the task, 
                                                  690:   ; * first located in the first place of the stack.
                                                  691:   ; *
                                                  692:   ; **********************************************************************/
                                                  693:   _restore_start_adr
                                                  694:       GLOBAL  _restore_start_adr
1D9C  CE3A     MOVFF 0xE3A, TBLPTRU               695:       locateTaskDescEntry
1D9E  FFF8     NOP
1DA0  CE39     MOVFF 0xE39, TBLPTRH
1DA2  FFF7     NOP
1DA4  CE38     MOVFF taskdesc_addr, TBLPTR
1DA6  FFF6     NOP
1DA8  0E07     MOVLW 0x7
1DAA  26F6     ADDWF TBLPTR, F, ACCESS
1DAC  6AE8     CLRF WREG, ACCESS
1DAE  22F7     ADDWFC TBLPTRH, F, ACCESS
1DB0  22F8     ADDWFC TBLPTRU, F, ACCESS
1DB2  0100     MOVLB 0x0
1DB4  516D     MOVF id_tsk_run, W, BANKED
1DB6  0009     TBLRD*+
1DB8  62F5     CPFSEQ TABLAT, ACCESS
1DBA  D001     BRA _31_nextTaskEntry
1DBC  D006     BRA _31_found
1DBE  0E09     MOVLW 0x9
1DC0  26F6     ADDWF TBLPTR, F, ACCESS
1DC2  6AE8     CLRF WREG, ACCESS
1DC4  22F7     ADDWFC TBLPTRH, F, ACCESS
1DC6  22F8     ADDWFC TBLPTRU, F, ACCESS
1DC8  D7F5     BRA _31_matchTaskID
1DCA  0E07     MOVLW 0x7                          696:       locateStackAddrField   
1DCC  5EF6     SUBWF TBLPTR, F, ACCESS
1DCE  6AE8     CLRF WREG, ACCESS
1DD0  5AF7     SUBWFB TBLPTRH, F, ACCESS
1DD2  5AF8     SUBWFB TBLPTRU, F, ACCESS
1DD4  0009     TBLRD*+                            697:       loadNextStackAddrTo FSR0L, FSR0H
1DD6  50F5     MOVF TABLAT, W, ACCESS
1DD8  6EE9     MOVWF FSR0, ACCESS
1DDA  0009     TBLRD*+
1DDC  50F5     MOVF TABLAT, W, ACCESS
1DDE  6EEA     MOVWF FSR0H, ACCESS
                                                  698:   
1DE0  0E02     MOVLW 0x2                          699:       movlw   0x02                        ; ==> Shift pointer to
1DE2  26E9     ADDWF FSR0, F, ACCESS              700:       addwf   FSR0L, f                    ; ==> the start address
1DE4  6AE8     CLRF WREG, ACCESS                  701:       clrf    WREG                        ; ==> of task
1DE6  22EA     ADDWFC FSR0H, F, ACCESS            702:       addwfc  FSR0H, f                    ;
1DE8  6EEE     MOVWF POSTINC0, ACCESS             703:       movwf   POSTINC0
1DEA  6EEF     MOVWF INDF0, ACCESS                704:       movwf   INDF0                       ; Set the value into STKPTR
1DEC  EF9B     GOTO 0x1B36                        705:       goto    _sched                      ; Determine the next RUNNING task
1DEE  F00D     NOP
                                                  706:   
                                                  707:       END                                 ; Directive 'end of program'
                                                  708:   
                                                  709:   ;/* End of File : kernel.asm */
                                                  710:   
---  F:/PICOS18/Kernel/even_man.c  ----------------------------------------------------------------------
1:             /**********************************************************************/
2:             /*                                                                    */
3:             /* File name: even_man.c                                              */
4:             /*                                                                    */
5:             /* Since:     2004-Sept-20                                            */
6:             /*                                                                    */
7:             /* Version:   PICos18 v3.00                                           */
8:             /*            Copyright (C) 2003, 2004, 2005 Pragmatec.               */
9:             /*                                                                    */
10:            /* Author:    Designed by Pragmatec S.A.R.L.        www.pragmatec.net */
11:            /*            MONTAGNE Xavier [XM]      xavier.montagne@pragmatec.net */
12:            /*                                                                    */
13:            /* Purpose:   The event manager is in charge of setting and clearing  */
14:            /*            the events waited by the tasks.                         */
15:            /*            2 areas are used to manage the arrival of events and    */
16:            /*            the fact that some tasks are waiting for these events.  */
17:            /*              - EVENT ram area : for events set by tasks or alarms  */
18:            /*              - WAIT  ram area : for events waited by tasks         */
19:            /*            The job of the event manager is to take care of task    */
20:            /*            activation in case of any similarity inbetween events   */
21:            /*            set and events waited.                                  */
22:            /*                                                                    */
23:            /* Distribution: This file is part of PICos18.                        */
24:            /*            PICos18 is free software; you can redistribute it       */
25:            /*            and/or modify it under the terms of the GNU General     */
26:            /*            Public License as published by the Free Software        */
27:            /*            Foundation; either version 2, or (at your option)       */
28:            /*            any later version.                                      */
29:            /*                                                                    */
30:            /*            PICos18 is distributed in the hope that it will be      */
31:            /*            useful, but WITHOUT ANY WARRANTY; without even the      */
32:            /*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
33:            /*            PARTICULAR PURPOSE.  See the GNU General Public         */
34:            /*            License for more details.                               */
35:            /*                                                                    */
36:            /*            You should have received a copy of the GNU General      */
37:            /*            Public License along with gpsim; see the file           */
38:            /*            COPYING.txt. If not, write to the Free Software         */
39:            /*            Foundation, 59 Temple Place - Suite 330,                */
40:            /*            Boston, MA 02111-1307, USA.                             */
41:            /*                                                                    */
42:            /*          > A special exception to the GPL can be applied should    */
43:            /*            you wish to distribute a combined work that includes    */
44:            /*            PICos18, without being obliged to provide the source    */
45:            /*            code for any proprietary components.                    */
46:            /*                                                                    */
47:            /* History:                                                           */
48:            /* 2004/09/20 [XM]  Create this file.                                 */
49:            /* 2005/10/29 [XM]  Added a critical section in WaitEvent (GIEL = 0). */
50:            /* 2006/05/17 [XM]  Removed the "temp" variable.                      */
51:            /*                                                                    */
52:            /**********************************************************************/
53:            
54:            #include "device.h"
55:            
56:            /**********************************************************************
57:             * Shared variables defined in other section.
58:             **********************************************************************/
59:            extern TaskType tsk_1_state_ID;
60:            extern TaskType tsk_1_activ_prio;
61:            extern char     id_tsk_run;
62:            extern char     kernelState;           /* ==> Added */
63:            
64:            /**********************************************************************
65:             * RAM area of the events set by the tasks or alarms.
66:             **********************************************************************/
67:            #pragma		udata	EVENT_MASK=0x0080
68:            EventMaskType event_1;
69:            EventMaskType event_2;
70:            EventMaskType event_3;
71:            EventMaskType event_4;
72:            EventMaskType event_5;
73:            EventMaskType event_6;
74:            EventMaskType event_7;
75:            EventMaskType event_8;
76:            EventMaskType event_9;
77:            EventMaskType event_10;
78:            EventMaskType event_11;
79:            EventMaskType event_12;
80:            EventMaskType event_13;
81:            EventMaskType event_14;
82:            EventMaskType event_15;
83:            EventMaskType event_16;
84:            
85:            
86:            /**********************************************************************
87:             * RAM area of the events waited by the tasks.
88:             **********************************************************************/
89:            #pragma		udata	WAIT_MASK=0x0090
90:            EventMaskType wait_1;
91:            EventMaskType wait_2;
92:            EventMaskType wait_3;
93:            EventMaskType wait_4;
94:            EventMaskType wait_5;
95:            EventMaskType wait_6;
96:            EventMaskType wait_7;
97:            EventMaskType wait_8;
98:            EventMaskType wait_9;
99:            EventMaskType wait_10;
100:           EventMaskType wait_11;
101:           EventMaskType wait_12;
102:           EventMaskType wait_13;
103:           EventMaskType wait_14;
104:           EventMaskType wait_15;
105:           EventMaskType wait_16;
106:           
107:           /**********************************************************************
108:            * ROM area of the event manager.
109:            **********************************************************************/
110:           #pragma		code	KERNEL_ROM
111:           
112:           /**********************************************************************
113:            * Set an event in the EVENT ram area of a task.
114:            * The event is reset if the task is already waiting for this event 
115:            * (task set into READY state).
116:            *
117:            * @param TaskID     IN  Reference of the task
118:            * @param Mask       IN  Bitmask of the event to set 
119:            * @return status    E_OK if no waiting task
120:            *                   E_OS_STATE if task suspended
121:            *                   E_OS_ID if ID is not correct
122:            *                   no return value otherwise
123:            **********************************************************************/
124:           StatusType SetEvent(TaskType TaskID, EventMaskType Mask)
162E  CFD9     MOVFF FSR2, POSTINC1
1630  FFE6     NOP
1632  CFDA     MOVFF FSR2H, POSTINC1
1634  FFE6     NOP
1636  CFE1     MOVFF FSR1, FSR2
1638  FFD9     NOP
163A  CFE2     MOVFF FSR1H, FSR2H
163C  FFDA     NOP
163E  52E6     MOVF POSTINC1, F, ACCESS
1640  52E6     MOVF POSTINC1, F, ACCESS
1642  52E6     MOVF POSTINC1, F, ACCESS
125:           {
126:             unsigned char i;
127:             TaskRefType ptr_task;
128:           
129:             ptr_task = (TaskRefType)&tsk_1_state_ID;
1644  50D9     MOVF FSR2, W, ACCESS
1646  0F01     ADDLW 0x1
1648  6EE9     MOVWF FSR0, ACCESS
164A  CFDA     MOVFF FSR2H, FSR0H
164C  FFEA     NOP
164E  0E00     MOVLW 0x0
1650  22EA     ADDWFC FSR0H, F, ACCESS
1652  0EA0     MOVLW 0xA0
1654  6EEE     MOVWF POSTINC0, ACCESS
1656  0E00     MOVLW 0x0
1658  6EED     MOVWF POSTDEC0, ACCESS
130:           
131:             for (i = 0; i < MAX_TASK_NB; i++, ptr_task++)
165A  6ADF     CLRF INDF2, ACCESS
165C  0E10     MOVLW 0x10
165E  5CDF     SUBWF INDF2, W, ACCESS
1660  E26E     BC 0x173E
1730  2ADF     INCF INDF2, F, ACCESS
1732  0E01     MOVLW 0x1
1734  2ADB     INCF PLUSW2, F, ACCESS
1736  0E02     MOVLW 0x2
1738  E301     BNC 0x173C
173A  2ADB     INCF PLUSW2, F, ACCESS
173C  D78F     BRA 0x165C
132:             {
133:               if ( (*ptr_task & MASK_ID) == TaskID )
1662  0E01     MOVLW 0x1
1664  CFDB     MOVFF PLUSW2, FSR0
1666  FFE9     NOP
1668  0E02     MOVLW 0x2
166A  CFDB     MOVFF PLUSW2, FSR0H
166C  FFEA     NOP
166E  50EF     MOVF INDF0, W, ACCESS
1670  0B0F     ANDLW 0xF
1672  6E14     MOVWF __tmp_0, ACCESS
1674  0EFD     MOVLW 0xFD
1676  50DB     MOVF PLUSW2, W, ACCESS
1678  5C14     SUBWF __tmp_0, W, ACCESS
167A  E15A     BNZ 0x1730
134:               {
135:                 if ((*ptr_task & READY) == SUSPENDED)
167C  0E01     MOVLW 0x1
167E  CFDB     MOVFF PLUSW2, FSR0
1680  FFE9     NOP
1682  0E02     MOVLW 0x2
1684  CFDB     MOVFF PLUSW2, FSR0H
1686  FFEA     NOP
1688  50EF     MOVF INDF0, W, ACCESS
168A  0B20     ANDLW 0x20
168C  E102     BNZ 0x1692
136:                 {
137:                   return (E_OS_STATE);
168E  0E07     MOVLW 0x7
1690  D058     BRA 0x1742
138:                 }
139:                 ptr_task = &event_1 + i;
1692  50DF     MOVF INDF2, W, ACCESS
1694  6A15     CLRF 0x15, ACCESS
1696  0F80     ADDLW 0x80
1698  6E14     MOVWF __tmp_0, ACCESS
169A  0E00     MOVLW 0x0
169C  2215     ADDWFC 0x15, F, ACCESS
169E  0E01     MOVLW 0x1
16A0  C014     MOVFF __tmp_0, PLUSW2
16A2  FFDB     NOP
16A4  0E02     MOVLW 0x2
16A6  C015     MOVFF 0x15, PLUSW2
16A8  FFDB     NOP
140:                 *ptr_task |= Mask;
16AA  0E01     MOVLW 0x1
16AC  CFDB     MOVFF PLUSW2, FSR0
16AE  FFE9     NOP
16B0  0E02     MOVLW 0x2
16B2  CFDB     MOVFF PLUSW2, FSR0H
16B4  FFEA     NOP
16B6  0EFC     MOVLW 0xFC
16B8  50DB     MOVF PLUSW2, W, ACCESS
16BA  12EF     IORWF INDF0, F, ACCESS
141:                 ptr_task = &wait_1 + i;
16BC  50DF     MOVF INDF2, W, ACCESS
16BE  6A15     CLRF 0x15, ACCESS
16C0  0F90     ADDLW 0x90
16C2  6E14     MOVWF __tmp_0, ACCESS
16C4  0E00     MOVLW 0x0
16C6  2215     ADDWFC 0x15, F, ACCESS
16C8  0E01     MOVLW 0x1
16CA  C014     MOVFF __tmp_0, PLUSW2
16CC  FFDB     NOP
16CE  0E02     MOVLW 0x2
16D0  C015     MOVFF 0x15, PLUSW2
16D2  FFDB     NOP
142:           
143:                 /* any task waiting for at least one event */
144:                 if (*ptr_task & Mask)     /* ==> Changed  and remove */
16D4  0EFC     MOVLW 0xFC
16D6  CFDB     MOVFF PLUSW2, POSTINC1
16D8  FFE6     NOP
16DA  0E01     MOVLW 0x1
16DC  CFDB     MOVFF PLUSW2, FSR0
16DE  FFE9     NOP
16E0  0E02     MOVLW 0x2
16E2  CFDB     MOVFF PLUSW2, FSR0H
16E4  FFEA     NOP
16E6  50EF     MOVF INDF0, W, ACCESS
16E8  52E5     MOVF POSTDEC1, F, ACCESS
16EA  14E7     ANDWF INDF1, W, ACCESS
16EC  E01F     BZ 0x172C
145:                 {
146:                   ptr_task = (TaskRefType)&tsk_1_state_ID + i;
16EE  50DF     MOVF INDF2, W, ACCESS
16F0  6A15     CLRF 0x15, ACCESS
16F2  0FA0     ADDLW 0xA0
16F4  6E14     MOVWF __tmp_0, ACCESS
16F6  0E00     MOVLW 0x0
16F8  2215     ADDWFC 0x15, F, ACCESS
16FA  0E01     MOVLW 0x1
16FC  C014     MOVFF __tmp_0, PLUSW2
16FE  FFDB     NOP
1700  0E02     MOVLW 0x2
1702  C015     MOVFF 0x15, PLUSW2
1704  FFDB     NOP
147:                   *ptr_task &= MASK_ID;
1706  0E0F     MOVLW 0xF
1708  6E14     MOVWF __tmp_0, ACCESS
170A  0E01     MOVLW 0x1
170C  CFDB     MOVFF PLUSW2, FSR0
170E  FFE9     NOP
1710  0E02     MOVLW 0x2
1712  CFDB     MOVFF PLUSW2, FSR0H
1714  FFEA     NOP
1716  5014     MOVF __tmp_0, W, ACCESS
1718  16EF     ANDWF INDF0, F, ACCESS
148:                   *ptr_task |= READY;
171A  0E01     MOVLW 0x1
171C  CFDB     MOVFF PLUSW2, FSR0
171E  FFE9     NOP
1720  0E02     MOVLW 0x2
1722  CFDB     MOVFF PLUSW2, FSR0H
1724  FFEA     NOP
1726  8AEF     BSF INDF0, 5, ACCESS
149:                   Schedule();
1728  EC07     CALL 0x120E, 0
172A  F009     NOP
150:                 }
151:                 return (E_OK);
172C  0E00     MOVLW 0x0
172E  D009     BRA 0x1742
152:               } 
153:             }
154:           /* ==> Changed  and remove */
155:             return (E_OS_ID);
173E  0E03     MOVLW 0x3
1740  D000     BRA 0x1742
156:           }
1742  52E5     MOVF POSTDEC1, F, ACCESS
1744  52E5     MOVF POSTDEC1, F, ACCESS
1746  52E5     MOVF POSTDEC1, F, ACCESS
1748  52E5     MOVF POSTDEC1, F, ACCESS
174A  CFE5     MOVFF POSTDEC1, FSR2H
174C  FFDA     NOP
174E  CFE7     MOVFF INDF1, FSR2
1750  FFD9     NOP
1752  0012     RETURN 0
157:           
158:           /**********************************************************************
159:            * Clear an event in the EVENT ram area and the WAIT ram area of the
160:            * calling task.
161:            * Should be called by a task just after the waitevent service call.
162:            *
163:            * @param Mask       IN  Bitmask of the event to set 
164:            * @return status    Always E_OK
165:            **********************************************************************/
166:           StatusType ClearEvent(EventMaskType Mask)
1754  CFD9     MOVFF FSR2, POSTINC1
1756  FFE6     NOP
1758  CFDA     MOVFF FSR2H, POSTINC1
175A  FFE6     NOP
175C  CFE1     MOVFF FSR1, FSR2
175E  FFD9     NOP
1760  CFE2     MOVFF FSR1H, FSR2H
1762  FFDA     NOP
1764  52E6     MOVF POSTINC1, F, ACCESS
1766  52E6     MOVF POSTINC1, F, ACCESS
1768  52E6     MOVF POSTINC1, F, ACCESS
167:           {
168:             unsigned char i;
169:             TaskRefType ptr_task;
170:           
171:             ptr_task = (TaskRefType)&tsk_1_state_ID;
176A  50D9     MOVF FSR2, W, ACCESS
176C  0F01     ADDLW 0x1
176E  6EE9     MOVWF FSR0, ACCESS
1770  CFDA     MOVFF FSR2H, FSR0H
1772  FFEA     NOP
1774  0E00     MOVLW 0x0
1776  22EA     ADDWFC FSR0H, F, ACCESS
1778  0EA0     MOVLW 0xA0
177A  6EEE     MOVWF POSTINC0, ACCESS
177C  0E00     MOVLW 0x0
177E  6EED     MOVWF POSTDEC0, ACCESS
172:           
173:             for (i = 0; i < MAX_TASK_NB; i++, ptr_task++)
1780  6ADF     CLRF INDF2, ACCESS
1782  0E10     MOVLW 0x10
1784  5CDF     SUBWF INDF2, W, ACCESS
1786  E242     BC 0x180C
17FE  2ADF     INCF INDF2, F, ACCESS
1800  0E01     MOVLW 0x1
1802  2ADB     INCF PLUSW2, F, ACCESS
1804  0E02     MOVLW 0x2
1806  E301     BNC 0x180A
1808  2ADB     INCF PLUSW2, F, ACCESS
180A  D7BB     BRA 0x1782
174:             {
175:               if ( (*ptr_task & MASK_ID) == id_tsk_run )
1788  0E01     MOVLW 0x1
178A  CFDB     MOVFF PLUSW2, FSR0
178C  FFE9     NOP
178E  0E02     MOVLW 0x2
1790  CFDB     MOVFF PLUSW2, FSR0H
1792  FFEA     NOP
1794  50EF     MOVF INDF0, W, ACCESS
1796  0B0F     ANDLW 0xF
1798  0100     MOVLB 0x0
179A  5D6D     SUBWF id_tsk_run, W, BANKED
179C  E130     BNZ 0x17FE
176:               {
177:                 ptr_task = &event_1 + i;
179E  50DF     MOVF INDF2, W, ACCESS
17A0  6A15     CLRF 0x15, ACCESS
17A2  0F80     ADDLW 0x80
17A4  6E14     MOVWF __tmp_0, ACCESS
17A6  0E00     MOVLW 0x0
17A8  2215     ADDWFC 0x15, F, ACCESS
17AA  0E01     MOVLW 0x1
17AC  C014     MOVFF __tmp_0, PLUSW2
17AE  FFDB     NOP
17B0  0E02     MOVLW 0x2
17B2  C015     MOVFF 0x15, PLUSW2
17B4  FFDB     NOP
178:                 *ptr_task &= ~Mask;
17B6  0EFD     MOVLW 0xFD
17B8  1CDB     COMF PLUSW2, W, ACCESS
17BA  6E14     MOVWF __tmp_0, ACCESS
17BC  0E01     MOVLW 0x1
17BE  CFDB     MOVFF PLUSW2, FSR0
17C0  FFE9     NOP
17C2  0E02     MOVLW 0x2
17C4  CFDB     MOVFF PLUSW2, FSR0H
17C6  FFEA     NOP
17C8  5014     MOVF __tmp_0, W, ACCESS
17CA  16EF     ANDWF INDF0, F, ACCESS
179:                 ptr_task = &wait_1 + i;
17CC  50DF     MOVF INDF2, W, ACCESS
17CE  6A15     CLRF 0x15, ACCESS
17D0  0F90     ADDLW 0x90
17D2  6E14     MOVWF __tmp_0, ACCESS
17D4  0E00     MOVLW 0x0
17D6  2215     ADDWFC 0x15, F, ACCESS
17D8  0E01     MOVLW 0x1
17DA  C014     MOVFF __tmp_0, PLUSW2
17DC  FFDB     NOP
17DE  0E02     MOVLW 0x2
17E0  C015     MOVFF 0x15, PLUSW2
17E2  FFDB     NOP
180:                 *ptr_task &= ~Mask;
17E4  0EFD     MOVLW 0xFD
17E6  1CDB     COMF PLUSW2, W, ACCESS
17E8  6E14     MOVWF __tmp_0, ACCESS
17EA  0E01     MOVLW 0x1
17EC  CFDB     MOVFF PLUSW2, FSR0
17EE  FFE9     NOP
17F0  0E02     MOVLW 0x2
17F2  CFDB     MOVFF PLUSW2, FSR0H
17F4  FFEA     NOP
17F6  5014     MOVF __tmp_0, W, ACCESS
17F8  16EF     ANDWF INDF0, F, ACCESS
181:                 return (E_OK);
17FA  0E00     MOVLW 0x0
17FC  D009     BRA 0x1810
182:               }
183:             }
184:           
185:             return (E_OK);
180C  0E00     MOVLW 0x0
180E  D000     BRA 0x1810
186:           }
1810  52E5     MOVF POSTDEC1, F, ACCESS
1812  52E5     MOVF POSTDEC1, F, ACCESS
1814  52E5     MOVF POSTDEC1, F, ACCESS
1816  52E5     MOVF POSTDEC1, F, ACCESS
1818  CFE5     MOVFF POSTDEC1, FSR2H
181A  FFDA     NOP
181C  CFE7     MOVFF INDF1, FSR2
181E  FFD9     NOP
1820  0012     RETURN 0
187:           
188:           /**********************************************************************
189:            * Get all the event (byte value)from the EVENT ram area of a task.
190:            * Allow the task to guess from which event it is waked up.
191:            *
192:            * @param TaskID     IN  Reference of the task
193:            * @param Mask       IN  Reference of the event to get 
194:            * @return status    E_OS_STATE if task suspended
195:            *                   E_OS_ID if ID is not correct
196:            *                   E_OK otherwise
197:            **********************************************************************/
198:           StatusType GetEvent(TaskType TaskID, EventMaskRefType Mask)
1822  CFD9     MOVFF FSR2, POSTINC1
1824  FFE6     NOP
1826  CFDA     MOVFF FSR2H, POSTINC1
1828  FFE6     NOP
182A  CFE1     MOVFF FSR1, FSR2
182C  FFD9     NOP
182E  CFE2     MOVFF FSR1H, FSR2H
1830  FFDA     NOP
1832  52E6     MOVF POSTINC1, F, ACCESS
1834  52E6     MOVF POSTINC1, F, ACCESS
1836  52E6     MOVF POSTINC1, F, ACCESS
199:           {
200:             unsigned char i;
201:             TaskRefType ptr_task;
202:           
203:             ptr_task = (TaskRefType)&tsk_1_state_ID;
1838  50D9     MOVF FSR2, W, ACCESS
183A  0F01     ADDLW 0x1
183C  6EE9     MOVWF FSR0, ACCESS
183E  CFDA     MOVFF FSR2H, FSR0H
1840  FFEA     NOP
1842  0E00     MOVLW 0x0
1844  22EA     ADDWFC FSR0H, F, ACCESS
1846  0EA0     MOVLW 0xA0
1848  6EEE     MOVWF POSTINC0, ACCESS
184A  0E00     MOVLW 0x0
184C  6EED     MOVWF POSTDEC0, ACCESS
204:               
205:             for (i = 0; i < MAX_TASK_NB; i++, ptr_task++)
184E  6ADF     CLRF INDF2, ACCESS
1850  0E10     MOVLW 0x10
1852  5CDF     SUBWF INDF2, W, ACCESS
1854  E23E     BC 0x18D2
18C4  2ADF     INCF INDF2, F, ACCESS
18C6  0E01     MOVLW 0x1
18C8  2ADB     INCF PLUSW2, F, ACCESS
18CA  0E02     MOVLW 0x2
18CC  E301     BNC 0x18D0
18CE  2ADB     INCF PLUSW2, F, ACCESS
18D0  D7BF     BRA 0x1850
206:             {
207:               if ( (*ptr_task & MASK_ID) == TaskID )
1856  0E01     MOVLW 0x1
1858  CFDB     MOVFF PLUSW2, FSR0
185A  FFE9     NOP
185C  0E02     MOVLW 0x2
185E  CFDB     MOVFF PLUSW2, FSR0H
1860  FFEA     NOP
1862  50EF     MOVF INDF0, W, ACCESS
1864  0B0F     ANDLW 0xF
1866  6E14     MOVWF __tmp_0, ACCESS
1868  0EFD     MOVLW 0xFD
186A  50DB     MOVF PLUSW2, W, ACCESS
186C  5C14     SUBWF __tmp_0, W, ACCESS
186E  E12A     BNZ 0x18C4
208:               {
209:                 if ((*ptr_task & MASK_STATE) == SUSPENDED)
1870  0E01     MOVLW 0x1
1872  CFDB     MOVFF PLUSW2, FSR0
1874  FFE9     NOP
1876  0E02     MOVLW 0x2
1878  CFDB     MOVFF PLUSW2, FSR0H
187A  FFEA     NOP
187C  50EF     MOVF INDF0, W, ACCESS
187E  0BE0     ANDLW 0xE0
1880  E102     BNZ 0x1886
210:                   return (E_OS_STATE);
1882  0E07     MOVLW 0x7
1884  D028     BRA 0x18D6
211:                 ptr_task = &event_1 + i;
1886  50DF     MOVF INDF2, W, ACCESS
1888  6A15     CLRF 0x15, ACCESS
188A  0F80     ADDLW 0x80
188C  6E14     MOVWF __tmp_0, ACCESS
188E  0E00     MOVLW 0x0
1890  2215     ADDWFC 0x15, F, ACCESS
1892  0E01     MOVLW 0x1
1894  C014     MOVFF __tmp_0, PLUSW2
1896  FFDB     NOP
1898  0E02     MOVLW 0x2
189A  C015     MOVFF 0x15, PLUSW2
189C  FFDB     NOP
212:                 *Mask = (EventMaskType)(*ptr_task);
189E  0E01     MOVLW 0x1
18A0  CFDB     MOVFF PLUSW2, FSR0
18A2  FFE9     NOP
18A4  0E02     MOVLW 0x2
18A6  CFDB     MOVFF PLUSW2, FSR0H
18A8  FFEA     NOP
18AA  50EF     MOVF INDF0, W, ACCESS
18AC  6EE6     MOVWF POSTINC1, ACCESS
18AE  0EFB     MOVLW 0xFB
18B0  CFDB     MOVFF PLUSW2, FSR0
18B2  FFE9     NOP
18B4  0EFC     MOVLW 0xFC
18B6  CFDB     MOVFF PLUSW2, FSR0H
18B8  FFEA     NOP
18BA  52E5     MOVF POSTDEC1, F, ACCESS
18BC  50E7     MOVF INDF1, W, ACCESS
18BE  6EEF     MOVWF INDF0, ACCESS
213:                 return (E_OK);
18C0  0E00     MOVLW 0x0
18C2  D009     BRA 0x18D6
214:               }
215:             }
216:           /* ==> Changed  and remove */
217:             return (E_OS_ID);
18D2  0E03     MOVLW 0x3
18D4  D000     BRA 0x18D6
218:           }
18D6  52E5     MOVF POSTDEC1, F, ACCESS
18D8  52E5     MOVF POSTDEC1, F, ACCESS
18DA  52E5     MOVF POSTDEC1, F, ACCESS
18DC  52E5     MOVF POSTDEC1, F, ACCESS
18DE  CFE5     MOVFF POSTDEC1, FSR2H
18E0  FFDA     NOP
18E2  CFE7     MOVFF INDF1, FSR2
18E4  FFD9     NOP
18E6  0012     RETURN 0
219:           
220:           /**********************************************************************
221:            * Set an event in the WAIT ram area of a task.
222:            * If the same event is set in the EVENT ram area, the function 
223:            * immediatly returns. If not the task is set in WAITING state.
224:            *
225:            * @param Mask       IN  Bitmask of the event to wait 
226:            * @return status    E_OK if the event exists
227:            *                   E_OS_ID if ID is not correct 
228:            *                   no return value otherwise
229:            **********************************************************************/
230:           StatusType WaitEvent(EventMaskType Mask)
18E8  CFD9     MOVFF FSR2, POSTINC1
18EA  FFE6     NOP
18EC  CFDA     MOVFF FSR2H, POSTINC1
18EE  FFE6     NOP
18F0  CFE1     MOVFF FSR1, FSR2
18F2  FFD9     NOP
18F4  CFE2     MOVFF FSR1H, FSR2H
18F6  FFDA     NOP
18F8  52E6     MOVF POSTINC1, F, ACCESS
18FA  52E6     MOVF POSTINC1, F, ACCESS
18FC  52E6     MOVF POSTINC1, F, ACCESS
231:           {
232:             unsigned char i;
233:             TaskRefType ptr_task;
234:           
235:             ptr_task = (TaskRefType)&tsk_1_state_ID; 
18FE  50D9     MOVF FSR2, W, ACCESS
1900  0F01     ADDLW 0x1
1902  6EE9     MOVWF FSR0, ACCESS
1904  CFDA     MOVFF FSR2H, FSR0H
1906  FFEA     NOP
1908  0E00     MOVLW 0x0
190A  22EA     ADDWFC FSR0H, F, ACCESS
190C  0EA0     MOVLW 0xA0
190E  6EEE     MOVWF POSTINC0, ACCESS
1910  0E00     MOVLW 0x0
1912  6EED     MOVWF POSTDEC0, ACCESS
236:           
237:             for (i = 0; i < MAX_TASK_NB; i++, ptr_task++)
1914  6ADF     CLRF INDF2, ACCESS
1916  0E10     MOVLW 0x10
1918  5CDF     SUBWF INDF2, W, ACCESS
191A  E25C     BC 0x19D4
19C6  2ADF     INCF INDF2, F, ACCESS
19C8  0E01     MOVLW 0x1
19CA  2ADB     INCF PLUSW2, F, ACCESS
19CC  0E02     MOVLW 0x2
19CE  E301     BNC 0x19D2
19D0  2ADB     INCF PLUSW2, F, ACCESS
19D2  D7A1     BRA 0x1916
238:             {
239:               if ( (*ptr_task & MASK_ID) == id_tsk_run )
191C  0E01     MOVLW 0x1
191E  CFDB     MOVFF PLUSW2, FSR0
1920  FFE9     NOP
1922  0E02     MOVLW 0x2
1924  CFDB     MOVFF PLUSW2, FSR0H
1926  FFEA     NOP
1928  50EF     MOVF INDF0, W, ACCESS
192A  0B0F     ANDLW 0xF
192C  0100     MOVLB 0x0
192E  5D6D     SUBWF id_tsk_run, W, BANKED
1930  E14A     BNZ 0x19C6
240:               {
241:                 INTCONbits.GIEL = 0;
1932  9CF2     BCF INTCON, 6, ACCESS
242:                 ptr_task = &wait_1 + i;
1934  50DF     MOVF INDF2, W, ACCESS
1936  6A15     CLRF 0x15, ACCESS
1938  0F90     ADDLW 0x90
193A  6E14     MOVWF __tmp_0, ACCESS
193C  0E00     MOVLW 0x0
193E  2215     ADDWFC 0x15, F, ACCESS
1940  0E01     MOVLW 0x1
1942  C014     MOVFF __tmp_0, PLUSW2
1944  FFDB     NOP
1946  0E02     MOVLW 0x2
1948  C015     MOVFF 0x15, PLUSW2
194A  FFDB     NOP
243:                 *ptr_task = Mask;
194C  0E01     MOVLW 0x1
194E  CFDB     MOVFF PLUSW2, FSR0
1950  FFE9     NOP
1952  0E02     MOVLW 0x2
1954  CFDB     MOVFF PLUSW2, FSR0H
1956  FFEA     NOP
1958  0EFD     MOVLW 0xFD
195A  CFDB     MOVFF PLUSW2, INDF0
195C  FFEF     NOP
244:                 ptr_task = &event_1 + i;
195E  50DF     MOVF INDF2, W, ACCESS
1960  6A15     CLRF 0x15, ACCESS
1962  0F80     ADDLW 0x80
1964  6E14     MOVWF __tmp_0, ACCESS
1966  0E00     MOVLW 0x0
1968  2215     ADDWFC 0x15, F, ACCESS
196A  0E01     MOVLW 0x1
196C  C014     MOVFF __tmp_0, PLUSW2
196E  FFDB     NOP
1970  0E02     MOVLW 0x2
1972  C015     MOVFF 0x15, PLUSW2
1974  FFDB     NOP
245:           
246:                 /* Not any event waited present */
247:                 if ( (*ptr_task & Mask) == 0 )
1976  0EFD     MOVLW 0xFD
1978  CFDB     MOVFF PLUSW2, POSTINC1
197A  FFE6     NOP
197C  0E01     MOVLW 0x1
197E  CFDB     MOVFF PLUSW2, FSR0
1980  FFE9     NOP
1982  0E02     MOVLW 0x2
1984  CFDB     MOVFF PLUSW2, FSR0H
1986  FFEA     NOP
1988  50EF     MOVF INDF0, W, ACCESS
198A  52E5     MOVF POSTDEC1, F, ACCESS
198C  14E7     ANDWF INDF1, W, ACCESS
198E  E118     BNZ 0x19C0
248:                 {
249:                   ptr_task = (TaskRefType)&tsk_1_state_ID + i;
1990  50DF     MOVF INDF2, W, ACCESS
1992  6A15     CLRF 0x15, ACCESS
1994  0FA0     ADDLW 0xA0
1996  6E14     MOVWF __tmp_0, ACCESS
1998  0E00     MOVLW 0x0
199A  2215     ADDWFC 0x15, F, ACCESS
199C  0E01     MOVLW 0x1
199E  C014     MOVFF __tmp_0, PLUSW2
19A0  FFDB     NOP
19A2  0E02     MOVLW 0x2
19A4  C015     MOVFF 0x15, PLUSW2
19A6  FFDB     NOP
250:                   *ptr_task += WAITING;
19A8  0E80     MOVLW 0x80
19AA  6E14     MOVWF __tmp_0, ACCESS
19AC  0E01     MOVLW 0x1
19AE  CFDB     MOVFF PLUSW2, FSR0
19B0  FFE9     NOP
19B2  0E02     MOVLW 0x2
19B4  CFDB     MOVFF PLUSW2, FSR0H
19B6  FFEA     NOP
19B8  5014     MOVF __tmp_0, W, ACCESS
19BA  26EF     ADDWF INDF0, F, ACCESS
251:                   Schedule();
19BC  EC07     CALL 0x120E, 0
19BE  F009     NOP
252:                 }
253:                 INTCONbits.GIEL = 1;
19C0  8CF2     BSF INTCON, 6, ACCESS
254:                 return (E_OK);
19C2  0E00     MOVLW 0x0
19C4  D009     BRA 0x19D8
255:               }
256:             }
257:           /* ==> Changed  and remove */
258:             return (E_OS_ID);
19D4  0E03     MOVLW 0x3
19D6  D000     BRA 0x19D8
259:           }
19D8  52E5     MOVF POSTDEC1, F, ACCESS
19DA  52E5     MOVF POSTDEC1, F, ACCESS
19DC  52E5     MOVF POSTDEC1, F, ACCESS
19DE  52E5     MOVF POSTDEC1, F, ACCESS
19E0  CFE5     MOVFF POSTDEC1, FSR2H
19E2  FFDA     NOP
19E4  CFE7     MOVFF INDF1, FSR2
19E6  FFD9     NOP
19E8  0012     RETURN 0
260:           
261:           
262:           /* End of File : even_man.c */
---  F:/PICOS18/Kernel/alarm.c  -------------------------------------------------------------------------
1:             /**********************************************************************/
2:             /*                                                                    */
3:             /* File name: alarm.c                                                 */
4:             /*                                                                    */
5:             /* Since:     2004-Sept-20                                            */
6:             /*                                                                    */
7:             /* Version:   PICos18 v3.00                                           */
8:             /*            Copyright (C) 2003, 2004, 2005 Pragmatec.               */
9:             /*                                                                    */
10:            /* Author:    Designed by Pragmatec S.A.R.L.        www.pragmatec.net */
11:            /*            MONTAGNE Xavier [XM]      xavier.montagne@pragmatec.net */
12:            /*            NIELSEN  Peter  [PN]                   pnielsen@tuug.fi */
13:            /*            KUSHNIR  Sergey [SK]                     icd2usb@tut.by */
14:            /*                                                                    */
15:            /* Purpose:   The alarm manager is in charge of setting the           */
16:            /*            alarm-timers or updating the alarm-counter from         */
17:            /*            application layer.                                      */
18:            /*                                                                    */
19:            /* Distribution: This file is part of PICos18.                        */
20:            /*            PICos18 is free software; you can redistribute it       */
21:            /*            and/or modify it under the terms of the GNU General     */
22:            /*            Public License as published by the Free Software        */
23:            /*            Foundation; either version 2, or (at your option)       */
24:            /*            any later version.                                      */
25:            /*                                                                    */
26:            /*            PICos18 is distributed in the hope that it will be      */
27:            /*            useful, but WITHOUT ANY WARRANTY; without even the      */
28:            /*            implied warranty of MERCHANTABILITY or FITNESS FOR A    */
29:            /*            PARTICULAR PURPOSE.  See the GNU General Public         */
30:            /*            License for more details.                               */
31:            /*                                                                    */
32:            /*            You should have received a copy of the GNU General      */
33:            /*            Public License along with gpsim; see the file           */
34:            /*            COPYING.txt. If not, write to the Free Software         */
35:            /*            Foundation, 59 Temple Place - Suite 330,                */
36:            /*            Boston, MA 02111-1307, USA.                             */
37:            /*                                                                    */
38:            /*          > A special exception to the GPL can be applied should    */
39:            /*            you wish to distribute a combined work that includes    */
40:            /*            PICos18, without being obliged to provide the source    */
41:            /*            code for any proprietary components.                    */
42:            /*                                                                    */
43:            /* History:                                                           */
44:            /* 2004/09/20 [XM]  Create this file.                                 */
45:            /* 2005/04/01 [XM]  Suppress "kernelState |= SERVICES;" at the end of */
46:            /*                  the file to avoid a systematic switch context.    */
47:            /* 2006/01/18 [XM]  Removed functions like _SetEvent.                 */
48:            /*                  Completed IncCounter and GetCounter functions.    */
49:            /*                  Added "kernelState |= SERVICES;" in AddOneTick(). */
50:            /* 2007/01/01 [PN]  Improved alarm accuracy in TMR0 ISR.              */
51:            /* 2007/11/14 [SK]  Added 26 for delay between TMR0 read and write.   */
52:            /*                  Look at define.h for new formula.                 */
53:            /*                                                                    */
54:            /**********************************************************************/
55:            
56:            #include "device.h"
57:            
58:            
59:            /**********************************************************************
60:             * Shared variables defined in other section.
61:             **********************************************************************/
62:            extern char id_tsk_run;
63:            extern unsigned char stack_low, stack_high;
64:            extern char kernelState;
65:            extern TaskType tsk_1_state_ID;
66:            extern EventMaskType event_1;
67:            extern EventMaskType wait_1;
68:            
69:            extern Counter Counter_list[];
70:            extern Counter Counter_kernel;
71:            extern AlarmObject Alarm_list[];
72:            extern unsigned char ALARMNUMBER;
73:            extern unsigned char COUNTERNUMBER;
74:            extern unsigned long global_counter;
75:            
76:            union Timers Tmr0;
77:            
78:            /**********************************************************************
79:             * ROM area of the alarm manager.
80:             **********************************************************************/
81:            #pragma		code	KERNEL_ROM
82:            
83:            /**********************************************************************
84:             * Program an alarm in relative mode with a number of tick to run from 
85:             * the current count value.
86:             *
87:             * @param ID         IN  ID of the alarm to update 
88:             * @param increment  IN  Number of ticks to run
89:             * @param cycle      IN  Number of cycle to process 
90:             * @return Status    E_OK if the alarm is not used
91:             *                   E_OS_STATE if in USED mode
92:             *                   E_OS_ID if ID is not correct
93:             **********************************************************************/
94:            StatusType SetRelAlarm(AlarmType ID, TickType increment, TickType cycle)
0146  CFD9     MOVFF FSR2, POSTINC1
0148  FFE6     NOP
014A  CFDA     MOVFF FSR2H, POSTINC1
014C  FFE6     NOP
014E  CFE1     MOVFF FSR1, FSR2
0150  FFD9     NOP
0152  CFE2     MOVFF FSR1H, FSR2H
0154  FFDA     NOP
95:            {
96:              if (ID >= ALARMNUMBER)
0156  010E     MOVLB 0xE
0158  512E     MOVF 0x2E, W, BANKED
015A  6EF3     MOVWF PROD, ACCESS
015C  0EFD     MOVLW 0xFD
015E  CFDB     MOVFF PLUSW2, PRODH
0160  FFF4     NOP
0162  50F3     MOVF PROD, W, ACCESS
0164  5CF4     SUBWF PRODH, W, ACCESS
0166  E302     BNC 0x16C
97:                return (E_OS_ID);
0168  0E03     MOVLW 0x3
016A  D0D4     BRA 0x314
98:                
99:              if (Alarm_list[ID].State == ON)
016C  0EFD     MOVLW 0xFD
016E  50DB     MOVF PLUSW2, W, ACCESS
0170  0D0D     MULLW 0xD
0172  CFF3     MOVFF PROD, FSR0
0174  FFE9     NOP
0176  CFF4     MOVFF PRODH, FSR0H
0178  FFEA     NOP
017A  0E14     MOVLW 0x14
017C  26E9     ADDWF FSR0, F, ACCESS
017E  0E0E     MOVLW 0xE
0180  22EA     ADDWFC FSR0H, F, ACCESS
0182  04EF     DECF INDF0, W, ACCESS
0184  E102     BNZ 0x18A
100:               return (E_OS_STATE);
0186  0E07     MOVLW 0x7
0188  D0C5     BRA 0x314
101:           
102:             if ((increment > Alarm_list[ID].ptrCounter->Base.maxAllowedValue))
018A  0EFB     MOVLW 0xFB
018C  CFDB     MOVFF PLUSW2, __tmp_0
018E  F014     NOP
0190  0EFC     MOVLW 0xFC
0192  CFDB     MOVFF PLUSW2, 0x15
0194  F015     NOP
0196  0EFD     MOVLW 0xFD
0198  50DB     MOVF PLUSW2, W, ACCESS
019A  0D0D     MULLW 0xD
019C  CFF3     MOVFF PROD, FSR0
019E  FFE9     NOP
01A0  CFF4     MOVFF PRODH, FSR0H
01A2  FFEA     NOP
01A4  0E14     MOVLW 0x14
01A6  26E9     ADDWF FSR0, F, ACCESS
01A8  0E0E     MOVLW 0xE
01AA  22EA     ADDWFC FSR0H, F, ACCESS
01AC  0E05     MOVLW 0x5
01AE  26E9     ADDWF FSR0, F, ACCESS
01B0  0E00     MOVLW 0x0
01B2  22EA     ADDWFC FSR0H, F, ACCESS
01B4  50EE     MOVF POSTINC0, W, ACCESS
01B6  CFEF     MOVFF INDF0, FSR0H
01B8  FFEA     NOP
01BA  6EE9     MOVWF FSR0, ACCESS
01BC  CFEE     MOVFF POSTINC0, 0x16
01BE  F016     NOP
01C0  CFEF     MOVFF INDF0, 0x17
01C2  F017     NOP
01C4  5014     MOVF __tmp_0, W, ACCESS
01C6  5C16     SUBWF 0x16, W, ACCESS
01C8  5015     MOVF 0x15, W, ACCESS
01CA  5817     SUBWFB 0x17, W, ACCESS
01CC  E202     BC 0x1D2
103:               return (E_OS_VALUE);
01CE  0E08     MOVLW 0x8
01D0  D0A1     BRA 0x314
104:           
105:             if ((cycle < Alarm_list[ID].ptrCounter->Base.minCycle) || 
01D2  0EF9     MOVLW 0xF9
01D4  CFDB     MOVFF PLUSW2, __tmp_0
01D6  F014     NOP
01D8  0EFA     MOVLW 0xFA
01DA  CFDB     MOVFF PLUSW2, 0x15
01DC  F015     NOP
01DE  0EFD     MOVLW 0xFD
01E0  50DB     MOVF PLUSW2, W, ACCESS
01E2  0D0D     MULLW 0xD
01E4  CFF3     MOVFF PROD, FSR0
01E6  FFE9     NOP
01E8  CFF4     MOVFF PRODH, FSR0H
01EA  FFEA     NOP
01EC  0E14     MOVLW 0x14
01EE  26E9     ADDWF FSR0, F, ACCESS
01F0  0E0E     MOVLW 0xE
01F2  22EA     ADDWFC FSR0H, F, ACCESS
01F4  0E05     MOVLW 0x5
01F6  26E9     ADDWF FSR0, F, ACCESS
01F8  0E00     MOVLW 0x0
01FA  22EA     ADDWFC FSR0H, F, ACCESS
01FC  50EE     MOVF POSTINC0, W, ACCESS
01FE  CFEF     MOVFF INDF0, FSR0H
0200  FFEA     NOP
0202  6EE9     MOVWF FSR0, ACCESS
0204  0E04     MOVLW 0x4
0206  26E9     ADDWF FSR0, F, ACCESS
0208  0E00     MOVLW 0x0
020A  22EA     ADDWFC FSR0H, F, ACCESS
020C  CFEE     MOVFF POSTINC0, 0x16
020E  F016     NOP
0210  CFEF     MOVFF INDF0, 0x17
0212  F017     NOP
0214  5016     MOVF 0x16, W, ACCESS
0216  5C14     SUBWF __tmp_0, W, ACCESS
0218  5017     MOVF 0x17, W, ACCESS
021A  5815     SUBWFB 0x15, W, ACCESS
106:                 (cycle > Alarm_list[ID].ptrCounter->Base.maxAllowedValue))
021C  E322     BNC 0x262
021E  0EF9     MOVLW 0xF9
0220  CFDB     MOVFF PLUSW2, 0x18
0222  F018     NOP
0224  0EFA     MOVLW 0xFA
0226  CFDB     MOVFF PLUSW2, 0x19
0228  F019     NOP
022A  0EFD     MOVLW 0xFD
022C  50DB     MOVF PLUSW2, W, ACCESS
022E  0D0D     MULLW 0xD
0230  CFF3     MOVFF PROD, FSR0
0232  FFE9     NOP
0234  CFF4     MOVFF PRODH, FSR0H
0236  FFEA     NOP
0238  0E14     MOVLW 0x14
023A  26E9     ADDWF FSR0, F, ACCESS
023C  0E0E     MOVLW 0xE
023E  22EA     ADDWFC FSR0H, F, ACCESS
0240  0E05     MOVLW 0x5
0242  26E9     ADDWF FSR0, F, ACCESS
0244  0E00     MOVLW 0x0
0246  22EA     ADDWFC FSR0H, F, ACCESS
0248  50EE     MOVF POSTINC0, W, ACCESS
024A  CFEF     MOVFF INDF0, FSR0H
024C  FFEA     NOP
024E  6EE9     MOVWF FSR0, ACCESS
0250  CFEE     MOVFF POSTINC0, 0x1A
0252  F01A     NOP
0254  CFEF     MOVFF INDF0, 0x1B
0256  F01B     NOP
0258  5018     MOVF 0x18, W, ACCESS
025A  5C1A     SUBWF 0x1A, W, ACCESS
025C  5019     MOVF 0x19, W, ACCESS
025E  581B     SUBWFB 0x1B, W, ACCESS
0260  E202     BC 0x266
107:               return (E_OS_VALUE);
0262  0E08     MOVLW 0x8
0264  D057     BRA 0x314
108:           
109:             Alarm_list[ID].AlarmValue = Alarm_list[ID].ptrCounter->CounterValue + \
0266  0EFB     MOVLW 0xFB
0268  CFDB     MOVFF PLUSW2, 0x16
026A  F016     NOP
026C  0EFC     MOVLW 0xFC
026E  CFDB     MOVFF PLUSW2, 0x17
0270  F017     NOP
0272  0EFD     MOVLW 0xFD
0274  50DB     MOVF PLUSW2, W, ACCESS
0276  0D0D     MULLW 0xD
0278  CFF3     MOVFF PROD, FSR0
027A  FFE9     NOP
027C  CFF4     MOVFF PRODH, FSR0H
027E  FFEA     NOP
0280  0E14     MOVLW 0x14
0282  26E9     ADDWF FSR0, F, ACCESS
0284  0E0E     MOVLW 0xE
0286  22EA     ADDWFC FSR0H, F, ACCESS
0288  0E05     MOVLW 0x5
028A  26E9     ADDWF FSR0, F, ACCESS
028C  0E00     MOVLW 0x0
028E  22EA     ADDWFC FSR0H, F, ACCESS
0290  50EE     MOVF POSTINC0, W, ACCESS
0292  CFEF     MOVFF INDF0, FSR0H
0294  FFEA     NOP
0296  6EE9     MOVWF FSR0, ACCESS
0298  0E06     MOVLW 0x6
029A  26E9     ADDWF FSR0, F, ACCESS
029C  0E00     MOVLW 0x0
029E  22EA     ADDWFC FSR0H, F, ACCESS
02A0  5016     MOVF 0x16, W, ACCESS
02A2  24EE     ADDWF POSTINC0, W, ACCESS
02A4  6E14     MOVWF __tmp_0, ACCESS
02A6  5017     MOVF 0x17, W, ACCESS
02A8  20EE     ADDWFC POSTINC0, W, ACCESS
02AA  6E15     MOVWF 0x15, ACCESS
02AC  0EFD     MOVLW 0xFD
02AE  50DB     MOVF PLUSW2, W, ACCESS
02B0  0D0D     MULLW 0xD
02B2  CFF3     MOVFF PROD, FSR0
02B4  FFE9     NOP
02B6  CFF4     MOVFF PRODH, FSR0H
02B8  FFEA     NOP
02BA  0E14     MOVLW 0x14
02BC  26E9     ADDWF FSR0, F, ACCESS
02BE  0E0E     MOVLW 0xE
02C0  22EA     ADDWFC FSR0H, F, ACCESS
02C2  52EE     MOVF POSTINC0, F, ACCESS
02C4  C014     MOVFF __tmp_0, POSTINC0
02C6  FFEE     NOP
02C8  C015     MOVFF 0x15, POSTDEC0
02CA  FFED     NOP
110:                                         increment;
111:             Alarm_list[ID].Cycle      = cycle;
02CC  0EFD     MOVLW 0xFD
02CE  50DB     MOVF PLUSW2, W, ACCESS
02D0  0D0D     MULLW 0xD
02D2  CFF3     MOVFF PROD, FSR0
02D4  FFE9     NOP
02D6  CFF4     MOVFF PRODH, FSR0H
02D8  FFEA     NOP
02DA  0E14     MOVLW 0x14
02DC  26E9     ADDWF FSR0, F, ACCESS
02DE  0E0E     MOVLW 0xE
02E0  22EA     ADDWFC FSR0H, F, ACCESS
02E2  0E03     MOVLW 0x3
02E4  26E9     ADDWF FSR0, F, ACCESS
02E6  0E00     MOVLW 0x0
02E8  22EA     ADDWFC FSR0H, F, ACCESS
02EA  0EF9     MOVLW 0xF9
02EC  CFDB     MOVFF PLUSW2, POSTINC0
02EE  FFEE     NOP
02F0  0EFA     MOVLW 0xFA
02F2  CFDB     MOVFF PLUSW2, POSTDEC0
02F4  FFED     NOP
112:             Alarm_list[ID].State      = ON;
02F6  0EFD     MOVLW 0xFD
02F8  50DB     MOVF PLUSW2, W, ACCESS
02FA  0D0D     MULLW 0xD
02FC  CFF3     MOVFF PROD, FSR0
02FE  FFE9     NOP
0300  CFF4     MOVFF PRODH, FSR0H
0302  FFEA     NOP
0304  0E14     MOVLW 0x14
0306  26E9     ADDWF FSR0, F, ACCESS
0308  0E0E     MOVLW 0xE
030A  22EA     ADDWFC FSR0H, F, ACCESS
030C  0E01     MOVLW 0x1
030E  6EEF     MOVWF INDF0, ACCESS
113:             return (E_OK);
0310  0E00     MOVLW 0x0
0312  D000     BRA 0x314
114:           }
0314  52E5     MOVF POSTDEC1, F, ACCESS
0316  CFE5     MOVFF POSTDEC1, FSR2H
0318  FFDA     NOP
031A  CFE7     MOVFF INDF1, FSR2
031C  FFD9     NOP
031E  0012     RETURN 0
115:           
116:           /**********************************************************************
117:            * Program an alarm in absolute mode with a number of tick to run from 
118:            * the start count value.
119:            *
120:            * @param ID         IN  ID of the alarm to update 
121:            * @param start      IN  Nb of ticks to run from start
122:            * @param cycle      IN  Number of cycle to process 
123:            * @return Status    E_OK if the alarm is not used
124:            *                   E_OS_STATE if in used mode
125:            *                   E_OS_ID if ID is not correct
126:            **********************************************************************/
127:           StatusType SetAbsAlarm(AlarmType ID, TickType start, TickType cycle)
0320  CFD9     MOVFF FSR2, POSTINC1
0322  FFE6     NOP
0324  CFDA     MOVFF FSR2H, POSTINC1
0326  FFE6     NOP
0328  CFE1     MOVFF FSR1, FSR2
032A  FFD9     NOP
032C  CFE2     MOVFF FSR1H, FSR2H
032E  FFDA     NOP
128:           {
129:             if (ID >= ALARMNUMBER)
0330  010E     MOVLB 0xE
0332  512E     MOVF 0x2E, W, BANKED
0334  6EF3     MOVWF PROD, ACCESS
0336  0EFD     MOVLW 0xFD
0338  CFDB     MOVFF PLUSW2, PRODH
033A  FFF4     NOP
033C  50F3     MOVF PROD, W, ACCESS
033E  5CF4     SUBWF PRODH, W, ACCESS
0340  E302     BNC 0x346
130:               return (E_OS_ID);
0342  0E03     MOVLW 0x3
0344  D0B3     BRA 0x4AC
131:               
132:             if (Alarm_list[ID].State == ON)
0346  0EFD     MOVLW 0xFD
0348  50DB     MOVF PLUSW2, W, ACCESS
034A  0D0D     MULLW 0xD
034C  CFF3     MOVFF PROD, FSR0
034E  FFE9     NOP
0350  CFF4     MOVFF PRODH, FSR0H
0352  FFEA     NOP
0354  0E14     MOVLW 0x14
0356  26E9     ADDWF FSR0, F, ACCESS
0358  0E0E     MOVLW 0xE
035A  22EA     ADDWFC FSR0H, F, ACCESS
035C  04EF     DECF INDF0, W, ACCESS
035E  E102     BNZ 0x364
133:               return (E_OS_STATE);
0360  0E07     MOVLW 0x7
0362  D0A4     BRA 0x4AC
134:           
135:             if ((start > Alarm_list[ID].ptrCounter->Base.maxAllowedValue))
0364  0EFB     MOVLW 0xFB
0366  CFDB     MOVFF PLUSW2, __tmp_0
0368  F014     NOP
036A  0EFC     MOVLW 0xFC
036C  CFDB     MOVFF PLUSW2, 0x15
036E  F015     NOP
0370  0EFD     MOVLW 0xFD
0372  50DB     MOVF PLUSW2, W, ACCESS
0374  0D0D     MULLW 0xD
0376  CFF3     MOVFF PROD, FSR0
0378  FFE9     NOP
037A  CFF4     MOVFF PRODH, FSR0H
037C  FFEA     NOP
037E  0E14     MOVLW 0x14
0380  26E9     ADDWF FSR0, F, ACCESS
0382  0E0E     MOVLW 0xE
0384  22EA     ADDWFC FSR0H, F, ACCESS
0386  0E05     MOVLW 0x5
0388  26E9     ADDWF FSR0, F, ACCESS
038A  0E00     MOVLW 0x0
038C  22EA     ADDWFC FSR0H, F, ACCESS
038E  50EE     MOVF POSTINC0, W, ACCESS
0390  CFEF     MOVFF INDF0, FSR0H
0392  FFEA     NOP
0394  6EE9     MOVWF FSR0, ACCESS
0396  CFEE     MOVFF POSTINC0, 0x16
0398  F016     NOP
039A  CFEF     MOVFF INDF0, 0x17
039C  F017     NOP
039E  5014     MOVF __tmp_0, W, ACCESS
03A0  5C16     SUBWF 0x16, W, ACCESS
03A2  5015     MOVF 0x15, W, ACCESS
03A4  5817     SUBWFB 0x17, W, ACCESS
03A6  E202     BC 0x3AC
136:               return (E_OS_VALUE);
03A8  0E08     MOVLW 0x8
03AA  D080     BRA 0x4AC
137:           
138:             if ((cycle < Alarm_list[ID].ptrCounter->Base.minCycle) || 
03AC  0EF9     MOVLW 0xF9
03AE  CFDB     MOVFF PLUSW2, __tmp_0
03B0  F014     NOP
03B2  0EFA     MOVLW 0xFA
03B4  CFDB     MOVFF PLUSW2, 0x15
03B6  F015     NOP
03B8  0EFD     MOVLW 0xFD
03BA  50DB     MOVF PLUSW2, W, ACCESS
03BC  0D0D     MULLW 0xD
03BE  CFF3     MOVFF PROD, FSR0
03C0  FFE9     NOP
03C2  CFF4     MOVFF PRODH, FSR0H
03C4  FFEA     NOP
03C6  0E14     MOVLW 0x14
03C8  26E9     ADDWF FSR0, F, ACCESS
03CA  0E0E     MOVLW 0xE
03CC  22EA     ADDWFC FSR0H, F, ACCESS
03CE  0E05     MOVLW 0x5
03D0  26E9     ADDWF FSR0, F, ACCESS
03D2  0E00     MOVLW 0x0
03D4  22EA     ADDWFC FSR0H, F, ACCESS
03D6  50EE     MOVF POSTINC0, W, ACCESS
03D8  CFEF     MOVFF INDF0, FSR0H
03DA  FFEA     NOP
03DC  6EE9     MOVWF FSR0, ACCESS
03DE  0E04     MOVLW 0x4
03E0  26E9     ADDWF FSR0, F, ACCESS
03E2  0E00     MOVLW 0x0
03E4  22EA     ADDWFC FSR0H, F, ACCESS
03E6  CFEE     MOVFF POSTINC0, 0x16
03E8  F016     NOP
03EA  CFEF     MOVFF INDF0, 0x17
03EC  F017     NOP
03EE  5016     MOVF 0x16, W, ACCESS
03F0  5C14     SUBWF __tmp_0, W, ACCESS
03F2  5017     MOVF 0x17, W, ACCESS
03F4  5815     SUBWFB 0x15, W, ACCESS
139:                 (cycle > Alarm_list[ID].ptrCounter->Base.maxAllowedValue))
03F6  E322     BNC 0x43C
03F8  0EF9     MOVLW 0xF9
03FA  CFDB     MOVFF PLUSW2, 0x18
03FC  F018     NOP
03FE  0EFA     MOVLW 0xFA
0400  CFDB     MOVFF PLUSW2, 0x19
0402  F019     NOP
0404  0EFD     MOVLW 0xFD
0406  50DB     MOVF PLUSW2, W, ACCESS
0408  0D0D     MULLW 0xD
040A  CFF3     MOVFF PROD, FSR0
040C  FFE9     NOP
040E  CFF4     MOVFF PRODH, FSR0H
0410  FFEA     NOP
0412  0E14     MOVLW 0x14
0414  26E9     ADDWF FSR0, F, ACCESS
0416  0E0E     MOVLW 0xE
0418  22EA     ADDWFC FSR0H, F, ACCESS
041A  0E05     MOVLW 0x5
041C  26E9     ADDWF FSR0, F, ACCESS
041E  0E00     MOVLW 0x0
0420  22EA     ADDWFC FSR0H, F, ACCESS
0422  50EE     MOVF POSTINC0, W, ACCESS
0424  CFEF     MOVFF INDF0, FSR0H
0426  FFEA     NOP
0428  6EE9     MOVWF FSR0, ACCESS
042A  CFEE     MOVFF POSTINC0, 0x1A
042C  F01A     NOP
042E  CFEF     MOVFF INDF0, 0x1B
0430  F01B     NOP
0432  5018     MOVF 0x18, W, ACCESS
0434  5C1A     SUBWF 0x1A, W, ACCESS
0436  5019     MOVF 0x19, W, ACCESS
0438  581B     SUBWFB 0x1B, W, ACCESS
043A  E202     BC 0x440
140:               return (E_OS_VALUE);
043C  0E08     MOVLW 0x8
043E  D036     BRA 0x4AC
141:           
142:             Alarm_list[ID].AlarmValue = start;
0440  0EFD     MOVLW 0xFD
0442  50DB     MOVF PLUSW2, W, ACCESS
0444  0D0D     MULLW 0xD
0446  CFF3     MOVFF PROD, FSR0
0448  FFE9     NOP
044A  CFF4     MOVFF PRODH, FSR0H
044C  FFEA     NOP
044E  0E14     MOVLW 0x14
0450  26E9     ADDWF FSR0, F, ACCESS
0452  0E0E     MOVLW 0xE
0454  22EA     ADDWFC FSR0H, F, ACCESS
0456  52EE     MOVF POSTINC0, F, ACCESS
0458  0EFB     MOVLW 0xFB
045A  CFDB     MOVFF PLUSW2, POSTINC0
045C  FFEE     NOP
045E  0EFC     MOVLW 0xFC
0460  CFDB     MOVFF PLUSW2, POSTDEC0
0462  FFED     NOP
143:             Alarm_list[ID].Cycle      = cycle;
0464  0EFD     MOVLW 0xFD
0466  50DB     MOVF PLUSW2, W, ACCESS
0468  0D0D     MULLW 0xD
046A  CFF3     MOVFF PROD, FSR0
046C  FFE9     NOP
046E  CFF4     MOVFF PRODH, FSR0H
0470  FFEA     NOP
0472  0E14     MOVLW 0x14
0474  26E9     ADDWF FSR0, F, ACCESS
0476  0E0E     MOVLW 0xE
0478  22EA     ADDWFC FSR0H, F, ACCESS
047A  0E03     MOVLW 0x3
047C  26E9     ADDWF FSR0, F, ACCESS
047E  0E00     MOVLW 0x0
0480  22EA     ADDWFC FSR0H, F, ACCESS
0482  0EF9     MOVLW 0xF9
0484  CFDB     MOVFF PLUSW2, POSTINC0
0486  FFEE     NOP
0488  0EFA     MOVLW 0xFA
048A  CFDB     MOVFF PLUSW2, POSTDEC0
048C  FFED     NOP
144:             Alarm_list[ID].State      = ON;
048E  0EFD     MOVLW 0xFD
0490  50DB     MOVF PLUSW2, W, ACCESS
0492  0D0D     MULLW 0xD
0494  CFF3     MOVFF PROD, FSR0
0496  FFE9     NOP
0498  CFF4     MOVFF PRODH, FSR0H
049A  FFEA     NOP
049C  0E14     MOVLW 0x14
049E  26E9     ADDWF FSR0, F, ACCESS
04A0  0E0E     MOVLW 0xE
04A2  22EA     ADDWFC FSR0H, F, ACCESS
04A4  0E01     MOVLW 0x1
04A6  6EEF     MOVWF INDF0, ACCESS
145:             return (E_OK);
04A8  0E00     MOVLW 0x0
04AA  D000     BRA 0x4AC
146:           }
04AC  52E5     MOVF POSTDEC1, F, ACCESS
04AE  CFE5     MOVFF POSTDEC1, FSR2H
04B0  FFDA     NOP
04B2  CFE7     MOVFF INDF1, FSR2
04B4  FFD9     NOP
04B6  0012     RETURN 0
147:           
148:           /**********************************************************************
149:            * Give the number of tick to run to set the alarm.
150:            *
151:            * @param ID         IN  ID of the alarm to update 
152:            * @param Tick       IN  Reference of tick number
153:            * @return Status    E_OK if the alarm is in USED mode
154:            *                   E_OS_NOFUNC if not used
155:            *                   E_OS_ID if ID is not correct
156:            **********************************************************************/
157:           StatusType GetAlarm(AlarmType ID, TickRefType Tick)
04B8  CFD9     MOVFF FSR2, POSTINC1
04BA  FFE6     NOP
04BC  CFDA     MOVFF FSR2H, POSTINC1
04BE  FFE6     NOP
04C0  CFE1     MOVFF FSR1, FSR2
04C2  FFD9     NOP
04C4  CFE2     MOVFF FSR1H, FSR2H
04C6  FFDA     NOP
158:           {
159:             if (ID >= ALARMNUMBER)
04C8  010E     MOVLB 0xE
04CA  512E     MOVF 0x2E, W, BANKED
04CC  6EF3     MOVWF PROD, ACCESS
04CE  0EFD     MOVLW 0xFD
04D0  CFDB     MOVFF PLUSW2, PRODH
04D2  FFF4     NOP
04D4  50F3     MOVF PROD, W, ACCESS
04D6  5CF4     SUBWF PRODH, W, ACCESS
04D8  E302     BNC 0x4DE
160:               return (E_OS_ID);
04DA  0E03     MOVLW 0x3
04DC  D048     BRA 0x56E
161:               
162:             if (Alarm_list[ID].State == OFF)
04DE  0EFD     MOVLW 0xFD
04E0  50DB     MOVF PLUSW2, W, ACCESS
04E2  0D0D     MULLW 0xD
04E4  CFF3     MOVFF PROD, FSR0
04E6  FFE9     NOP
04E8  CFF4     MOVFF PRODH, FSR0H
04EA  FFEA     NOP
04EC  0E14     MOVLW 0x14
04EE  26E9     ADDWF FSR0, F, ACCESS
04F0  0E0E     MOVLW 0xE
04F2  22EA     ADDWFC FSR0H, F, ACCESS
04F4  50EF     MOVF INDF0, W, ACCESS
04F6  E102     BNZ 0x4FC
163:               return (E_OS_NOFUNC);
04F8  0E05     MOVLW 0x5
04FA  D039     BRA 0x56E
164:           
165:             *Tick = Alarm_list[ID].AlarmValue - \
04FC  0EFD     MOVLW 0xFD
04FE  50DB     MOVF PLUSW2, W, ACCESS
0500  0D0D     MULLW 0xD
0502  CFF3     MOVFF PROD, FSR0
0504  FFE9     NOP
0506  CFF4     MOVFF PRODH, FSR0H
0508  FFEA     NOP
050A  0E14     MOVLW 0x14
050C  26E9     ADDWF FSR0, F, ACCESS
050E  0E0E     MOVLW 0xE
0510  22EA     ADDWFC FSR0H, F, ACCESS
0512  52EE     MOVF POSTINC0, F, ACCESS
0514  CFEE     MOVFF POSTINC0, 0x16
0516  F016     NOP
0518  CFEF     MOVFF INDF0, 0x17
051A  F017     NOP
051C  0EFD     MOVLW 0xFD
051E  50DB     MOVF PLUSW2, W, ACCESS
0520  0D0D     MULLW 0xD
0522  CFF3     MOVFF PROD, FSR0
0524  FFE9     NOP
0526  CFF4     MOVFF PRODH, FSR0H
0528  FFEA     NOP
052A  0E14     MOVLW 0x14
052C  26E9     ADDWF FSR0, F, ACCESS
052E  0E0E     MOVLW 0xE
0530  22EA     ADDWFC FSR0H, F, ACCESS
0532  0E05     MOVLW 0x5
0534  26E9     ADDWF FSR0, F, ACCESS
0536  0E00     MOVLW 0x0
0538  22EA     ADDWFC FSR0H, F, ACCESS
053A  50EE     MOVF POSTINC0, W, ACCESS
053C  CFEF     MOVFF INDF0, FSR0H
053E  FFEA     NOP
0540  6EE9     MOVWF FSR0, ACCESS
0542  0E06     MOVLW 0x6
0544  26E9     ADDWF FSR0, F, ACCESS
0546  0E00     MOVLW 0x0
0548  22EA     ADDWFC FSR0H, F, ACCESS
054A  50EE     MOVF POSTINC0, W, ACCESS
054C  5C16     SUBWF 0x16, W, ACCESS
054E  6E14     MOVWF __tmp_0, ACCESS
0550  50EE     MOVF POSTINC0, W, ACCESS
0552  5817     SUBWFB 0x17, W, ACCESS
0554  6E15     MOVWF 0x15, ACCESS
0556  0EFB     MOVLW 0xFB
0558  CFDB     MOVFF PLUSW2, FSR0
055A  FFE9     NOP
055C  0EFC     MOVLW 0xFC
055E  CFDB     MOVFF PLUSW2, FSR0H
0560  FFEA     NOP
0562  C014     MOVFF __tmp_0, POSTINC0
0564  FFEE     NOP
0566  C015     MOVFF 0x15, POSTDEC0
0568  FFED     NOP
166:                     Alarm_list[ID].ptrCounter->CounterValue;
167:             return (E_OK);
056A  0E00     MOVLW 0x0
056C  D000     BRA 0x56E
168:           }
056E  52E5     MOVF POSTDEC1, F, ACCESS
0570  CFE5     MOVFF POSTDEC1, FSR2H
0572  FFDA     NOP
0574  CFE7     MOVFF INDF1, FSR2
0576  FFD9     NOP
0578  0012     RETURN 0
169:           
170:           /**********************************************************************
171:            * Set the alarm in UNUSED mode.
172:            *
173:            * @param ID         IN  ID of the alarm to update
174:            * @return Status    E_OK if the alarm is in USE mode
175:            *                   E_OS_NOFUNC if not used
176:            *                   E_OS_ID if ID is not correct
177:            **********************************************************************/
178:           StatusType CancelAlarm(AlarmType ID)
057A  CFD9     MOVFF FSR2, POSTINC1
057C  FFE6     NOP
057E  CFDA     MOVFF FSR2H, POSTINC1
0580  FFE6     NOP
0582  CFE1     MOVFF FSR1, FSR2
0584  FFD9     NOP
0586  CFE2     MOVFF FSR1H, FSR2H
0588  FFDA     NOP
179:           {
180:             if (ID >= ALARMNUMBER)
058A  010E     MOVLB 0xE
058C  512E     MOVF 0x2E, W, BANKED
058E  6EF3     MOVWF PROD, ACCESS
0590  0EFD     MOVLW 0xFD
0592  CFDB     MOVFF PLUSW2, PRODH
0594  FFF4     NOP
0596  50F3     MOVF PROD, W, ACCESS
0598  5CF4     SUBWF PRODH, W, ACCESS
059A  E302     BNC 0x5A0
181:               return (E_OS_ID);
059C  0E03     MOVLW 0x3
059E  D01D     BRA 0x5DA
182:               
183:             if (Alarm_list[ID].State == OFF)
05A0  0EFD     MOVLW 0xFD
05A2  50DB     MOVF PLUSW2, W, ACCESS
05A4  0D0D     MULLW 0xD
05A6  CFF3     MOVFF PROD, FSR0
05A8  FFE9     NOP
05AA  CFF4     MOVFF PRODH, FSR0H
05AC  FFEA     NOP
05AE  0E14     MOVLW 0x14
05B0  26E9     ADDWF FSR0, F, ACCESS
05B2  0E0E     MOVLW 0xE
05B4  22EA     ADDWFC FSR0H, F, ACCESS
05B6  50EF     MOVF INDF0, W, ACCESS
05B8  E102     BNZ 0x5BE
184:               return (E_OS_NOFUNC);
05BA  0E05     MOVLW 0x5
05BC  D00E     BRA 0x5DA
185:           
186:             Alarm_list[ID].State = OFF;
05BE  0EFD     MOVLW 0xFD
05C0  50DB     MOVF PLUSW2, W, ACCESS
05C2  0D0D     MULLW 0xD
05C4  CFF3     MOVFF PROD, FSR0
05C6  FFE9     NOP
05C8  CFF4     MOVFF PRODH, FSR0H
05CA  FFEA     NOP
05CC  0E14     MOVLW 0x14
05CE  26E9     ADDWF FSR0, F, ACCESS
05D0  0E0E     MOVLW 0xE
05D2  22EA     ADDWFC FSR0H, F, ACCESS
05D4  6AEF     CLRF INDF0, ACCESS
187:             return (E_OK);
05D6  0E00     MOVLW 0x0
05D8  D000     BRA 0x5DA
188:           }
05DA  52E5     MOVF POSTDEC1, F, ACCESS
05DC  CFE5     MOVFF POSTDEC1, FSR2H
05DE  FFDA     NOP
05E0  CFE7     MOVFF INDF1, FSR2
05E2  FFD9     NOP
05E4  0012     RETURN 0
189:           
190:           /*********************************************************************
191:            * Give the info relative to Alarm Base.
192:            *
193:            * @param ID         IN  ID of the alarm to update
194:            * @param Info       IN  Reference to the alarm base 
195:            * @return Status    E_OK if the ID is correct
196:            *                   E_OS_ID if not
197:            *********************************************************************/
198:           StatusType GetAlarmBase(AlarmType ID, AlarmBaseRefType Info)
05E6  CFD9     MOVFF FSR2, POSTINC1
05E8  FFE6     NOP
05EA  CFDA     MOVFF FSR2H, POSTINC1
05EC  FFE6     NOP
05EE  CFE1     MOVFF FSR1, FSR2
05F0  FFD9     NOP
05F2  CFE2     MOVFF FSR1H, FSR2H
05F4  FFDA     NOP
199:           {
200:             if (ID >= ALARMNUMBER)
05F6  010E     MOVLB 0xE
05F8  512E     MOVF 0x2E, W, BANKED
05FA  6EF3     MOVWF PROD, ACCESS
05FC  0EFD     MOVLW 0xFD
05FE  CFDB     MOVFF PLUSW2, PRODH
0600  FFF4     NOP
0602  50F3     MOVF PROD, W, ACCESS
0604  5CF4     SUBWF PRODH, W, ACCESS
0606  E302     BNC 0x60C
201:               return (E_OS_ID);
0608  0E03     MOVLW 0x3
060A  D01F     BRA 0x64A
202:               
203:             Info = &(Alarm_list[ID].ptrCounter->Base);
060C  0EFD     MOVLW 0xFD
060E  50DB     MOVF PLUSW2, W, ACCESS
0610  0D0D     MULLW 0xD
0612  CFF3     MOVFF PROD, FSR0
0614  FFE9     NOP
0616  CFF4     MOVFF PRODH, FSR0H
0618  FFEA     NOP
061A  0E14     MOVLW 0x14
061C  26E9     ADDWF FSR0, F, ACCESS
061E  0E0E     MOVLW 0xE
0620  22EA     ADDWFC FSR0H, F, ACCESS
0622  0E05     MOVLW 0x5
0624  26E9     ADDWF FSR0, F, ACCESS
0626  0E00     MOVLW 0x0
0628  22EA     ADDWFC FSR0H, F, ACCESS
062A  50EE     MOVF POSTINC0, W, ACCESS
062C  CFEF     MOVFF INDF0, FSR0H
062E  FFEA     NOP
0630  6EE9     MOVWF FSR0, ACCESS
0632  CFE9     MOVFF FSR0, __tmp_0
0634  F014     NOP
0636  CFEA     MOVFF FSR0H, 0x15
0638  F015     NOP
063A  0EFB     MOVLW 0xFB
063C  C014     MOVFF __tmp_0, PLUSW2
063E  FFDB     NOP
0640  0EFC     MOVLW 0xFC
0642  C015     MOVFF 0x15, PLUSW2
0644  FFDB     NOP
204:             return (E_OK);
0646  0E00     MOVLW 0x0
0648  D000     BRA 0x64A
205:           }
064A  52E5     MOVF POSTDEC1, F, ACCESS
064C  CFE5     MOVFF POSTDEC1, FSR2H
064E  FFDA     NOP
0650  CFE7     MOVFF INDF1, FSR2
0652  FFD9     NOP
0654  0012     RETURN 0
206:           
207:           /*********************************************************************
208:            * Increment the counter in case of alarm with COUNTER mode.
209:            *
210:            * @param ID         IN  ID of the alarm to update
211:            * @return Status    E_OK if the ID is correct
212:            *                   E_OS_ACCESS if counter is OFF
213:            *                   E_OS_ID if ID is not correct
214:            *********************************************************************/
215:           StatusType IncCounter(AlarmType ID)
0656  CFD9     MOVFF FSR2, POSTINC1
0658  FFE6     NOP
065A  CFDA     MOVFF FSR2H, POSTINC1
065C  FFE6     NOP
065E  CFE1     MOVFF FSR1, FSR2
0660  FFD9     NOP
0662  CFE2     MOVFF FSR1H, FSR2H
0664  FFDA     NOP
216:           {
217:             if (ID >= ALARMNUMBER)
0666  010E     MOVLB 0xE
0668  512E     MOVF 0x2E, W, BANKED
066A  6EF3     MOVWF PROD, ACCESS
066C  0EFD     MOVLW 0xFD
066E  CFDB     MOVFF PLUSW2, PRODH
0670  FFF4     NOP
0672  50F3     MOVF PROD, W, ACCESS
0674  5CF4     SUBWF PRODH, W, ACCESS
0676  E302     BNC 0x67C
218:               return (E_OS_ID);
0678  0E03     MOVLW 0x3
067A  D160     BRA 0x93C
219:           
220:             if (Alarm_list[ID].State == OFF)
067C  0EFD     MOVLW 0xFD
067E  50DB     MOVF PLUSW2, W, ACCESS
0680  0D0D     MULLW 0xD
0682  CFF3     MOVFF PROD, FSR0
0684  FFE9     NOP
0686  CFF4     MOVFF PRODH, FSR0H
0688  FFEA     NOP
068A  0E14     MOVLW 0x14
068C  26E9     ADDWF FSR0, F, ACCESS
068E  0E0E     MOVLW 0xE
0690  22EA     ADDWFC FSR0H, F, ACCESS
0692  50EF     MOVF INDF0, W, ACCESS
0694  E102     BNZ 0x69A
221:               return(E_OS_ACCESS);
0696  0E01     MOVLW 0x1
0698  D151     BRA 0x93C
222:           
223:             Alarm_list[ID].ptrCounter->CounterValue++;
069A  0EFD     MOVLW 0xFD
069C  50DB     MOVF PLUSW2, W, ACCESS
069E  0D0D     MULLW 0xD
06A0  CFF3     MOVFF PROD, FSR0
06A2  FFE9     NOP
06A4  CFF4     MOVFF PRODH, FSR0H
06A6  FFEA     NOP
06A8  0E14     MOVLW 0x14
06AA  26E9     ADDWF FSR0, F, ACCESS
06AC  0E0E     MOVLW 0xE
06AE  22EA     ADDWFC FSR0H, F, ACCESS
06B0  0E05     MOVLW 0x5
06B2  26E9     ADDWF FSR0, F, ACCESS
06B4  0E00     MOVLW 0x0
06B6  22EA     ADDWFC FSR0H, F, ACCESS
06B8  50EE     MOVF POSTINC0, W, ACCESS
06BA  CFEF     MOVFF INDF0, FSR0H
06BC  FFEA     NOP
06BE  6EE9     MOVWF FSR0, ACCESS
06C0  0E06     MOVLW 0x6
06C2  26E9     ADDWF FSR0, F, ACCESS
06C4  0E00     MOVLW 0x0
06C6  22EA     ADDWFC FSR0H, F, ACCESS
06C8  2AEE     INCF POSTINC0, F, ACCESS
06CA  22EF     ADDWFC INDF0, F, ACCESS
224:             if (Alarm_list[ID].ptrCounter->CounterValue == 
06CC  0EFD     MOVLW 0xFD
06CE  50DB     MOVF PLUSW2, W, ACCESS
06D0  0D0D     MULLW 0xD
06D2  CFF3     MOVFF PROD, FSR0
06D4  FFE9     NOP
06D6  CFF4     MOVFF PRODH, FSR0H
06D8  FFEA     NOP
06DA  0E14     MOVLW 0x14
06DC  26E9     ADDWF FSR0, F, ACCESS
06DE  0E0E     MOVLW 0xE
06E0  22EA     ADDWFC FSR0H, F, ACCESS
06E2  0E05     MOVLW 0x5
06E4  26E9     ADDWF FSR0, F, ACCESS
06E6  0E00     MOVLW 0x0
06E8  22EA     ADDWFC FSR0H, F, ACCESS
06EA  50EE     MOVF POSTINC0, W, ACCESS
06EC  CFEF     MOVFF INDF0, FSR0H
06EE  FFEA     NOP
06F0  6EE9     MOVWF FSR0, ACCESS
06F2  0E06     MOVLW 0x6
06F4  26E9     ADDWF FSR0, F, ACCESS
06F6  0E00     MOVLW 0x0
06F8  22EA     ADDWFC FSR0H, F, ACCESS
06FA  CFEE     MOVFF POSTINC0, __tmp_0
06FC  F014     NOP
06FE  CFEF     MOVFF INDF0, 0x15
0700  F015     NOP
225:                 Alarm_list[ID].AlarmValue)
0702  0EFD     MOVLW 0xFD
0704  50DB     MOVF PLUSW2, W, ACCESS
0706  0D0D     MULLW 0xD
0708  CFF3     MOVFF PROD, FSR0
070A  FFE9     NOP
070C  CFF4     MOVFF PRODH, FSR0H
070E  FFEA     NOP
0710  0E14     MOVLW 0x14
0712  26E9     ADDWF FSR0, F, ACCESS
0714  0E0E     MOVLW 0xE
0716  22EA     ADDWFC FSR0H, F, ACCESS
0718  52EE     MOVF POSTINC0, F, ACCESS
071A  CFEE     MOVFF POSTINC0, 0x16
071C  F016     NOP
071E  CFEF     MOVFF INDF0, 0x17
0720  F017     NOP
0722  5016     MOVF 0x16, W, ACCESS
0724  1814     XORWF __tmp_0, W, ACCESS
0726  E102     BNZ 0x72C
0728  5017     MOVF 0x17, W, ACCESS
072A  1815     XORWF 0x15, W, ACCESS
072C  E001     BZ 0x730
072E  D104     BRA 0x938
226:             {
227:               if (Alarm_list[ID].Cycle == 0)
0730  0EFD     MOVLW 0xFD
0732  50DB     MOVF PLUSW2, W, ACCESS
0734  0D0D     MULLW 0xD
0736  CFF3     MOVFF PROD, FSR0
0738  FFE9     NOP
073A  CFF4     MOVFF PRODH, FSR0H
073C  FFEA     NOP
073E  0E14     MOVLW 0x14
0740  26E9     ADDWF FSR0, F, ACCESS
0742  0E0E     MOVLW 0xE
0744  22EA     ADDWFC FSR0H, F, ACCESS
0746  0E03     MOVLW 0x3
0748  26E9     ADDWF FSR0, F, ACCESS
074A  0E00     MOVLW 0x0
074C  22EA     ADDWFC FSR0H, F, ACCESS
074E  50EE     MOVF POSTINC0, W, ACCESS
0750  10ED     IORWF POSTDEC0, W, ACCESS
0752  E10D     BNZ 0x76E
228:                 Alarm_list[ID].State = OFF;
0754  0EFD     MOVLW 0xFD
0756  50DB     MOVF PLUSW2, W, ACCESS
0758  0D0D     MULLW 0xD
075A  CFF3     MOVFF PROD, FSR0
075C  FFE9     NOP
075E  CFF4     MOVFF PRODH, FSR0H
0760  FFEA     NOP
0762  0E14     MOVLW 0x14
0764  26E9     ADDWF FSR0, F, ACCESS
0766  0E0E     MOVLW 0xE
0768  22EA     ADDWFC FSR0H, F, ACCESS
076A  6AEF     CLRF INDF0, ACCESS
229:               else
076C  D040     BRA 0x7EE
230:               {
231:                 Alarm_list[ID].AlarmValue = \
076E  0EFD     MOVLW 0xFD
0770  50DB     MOVF PLUSW2, W, ACCESS
0772  0D0D     MULLW 0xD
0774  CFF3     MOVFF PROD, FSR0
0776  FFE9     NOP
0778  CFF4     MOVFF PRODH, FSR0H
077A  FFEA     NOP
077C  0E14     MOVLW 0x14
077E  26E9     ADDWF FSR0, F, ACCESS
0780  0E0E     MOVLW 0xE
0782  22EA     ADDWFC FSR0H, F, ACCESS
0784  0E05     MOVLW 0x5
0786  26E9     ADDWF FSR0, F, ACCESS
0788  0E00     MOVLW 0x0
078A  22EA     ADDWFC FSR0H, F, ACCESS
078C  50EE     MOVF POSTINC0, W, ACCESS
078E  CFEF     MOVFF INDF0, FSR0H
0790  FFEA     NOP
0792  6EE9     MOVWF FSR0, ACCESS
0794  0E06     MOVLW 0x6
0796  26E9     ADDWF FSR0, F, ACCESS
0798  0E00     MOVLW 0x0
079A  22EA     ADDWFC FSR0H, F, ACCESS
079C  CFEE     MOVFF POSTINC0, 0x16
079E  F016     NOP
07A0  CFEF     MOVFF INDF0, 0x17
07A2  F017     NOP
07A4  0EFD     MOVLW 0xFD
07A6  50DB     MOVF PLUSW2, W, ACCESS
07A8  0D0D     MULLW 0xD
07AA  CFF3     MOVFF PROD, FSR0
07AC  FFE9     NOP
07AE  CFF4     MOVFF PRODH, FSR0H
07B0  FFEA     NOP
07B2  0E14     MOVLW 0x14
07B4  26E9     ADDWF FSR0, F, ACCESS
07B6  0E0E     MOVLW 0xE
07B8  22EA     ADDWFC FSR0H, F, ACCESS
07BA  0E03     MOVLW 0x3
07BC  26E9     ADDWF FSR0, F, ACCESS
07BE  0E00     MOVLW 0x0
07C0  22EA     ADDWFC FSR0H, F, ACCESS
07C2  5016     MOVF 0x16, W, ACCESS
07C4  24EE     ADDWF POSTINC0, W, ACCESS
07C6  6E14     MOVWF __tmp_0, ACCESS
07C8  5017     MOVF 0x17, W, ACCESS
07CA  20EE     ADDWFC POSTINC0, W, ACCESS
07CC  6E15     MOVWF 0x15, ACCESS
07CE  0EFD     MOVLW 0xFD
07D0  50DB     MOVF PLUSW2, W, ACCESS
07D2  0D0D     MULLW 0xD
07D4  CFF3     MOVFF PROD, FSR0
07D6  FFE9     NOP
07D8  CFF4     MOVFF PRODH, FSR0H
07DA  FFEA     NOP
07DC  0E14     MOVLW 0x14
07DE  26E9     ADDWF FSR0, F, ACCESS
07E0  0E0E     MOVLW 0xE
07E2  22EA     ADDWFC FSR0H, F, ACCESS
07E4  52EE     MOVF POSTINC0, F, ACCESS
07E6  C014     MOVFF __tmp_0, POSTINC0
07E8  FFEE     NOP
07EA  C015     MOVFF 0x15, POSTDEC0
07EC  FFED     NOP
232:                   Alarm_list[ID].ptrCounter->CounterValue + \
233:                   Alarm_list[ID].Cycle;
234:               }
235:               if (Alarm_list[ID].EventToPost != 0)
07EE  0EFD     MOVLW 0xFD
07F0  50DB     MOVF PLUSW2, W, ACCESS
07F2  0D0D     MULLW 0xD
07F4  CFF3     MOVFF PROD, FSR0
07F6  FFE9     NOP
07F8  CFF4     MOVFF PRODH, FSR0H
07FA  FFEA     NOP
07FC  0E14     MOVLW 0x14
07FE  26E9     ADDWF FSR0, F, ACCESS
0800  0E0E     MOVLW 0xE
0802  22EA     ADDWFC FSR0H, F, ACCESS
0804  0E08     MOVLW 0x8
0806  26E9     ADDWF FSR0, F, ACCESS
0808  0E00     MOVLW 0x0
080A  22EA     ADDWFC FSR0H, F, ACCESS
080C  50EE     MOVF POSTINC0, W, ACCESS
080E  10ED     IORWF POSTDEC0, W, ACCESS
0810  E026     BZ 0x85E
236:                 SetEvent(Alarm_list[ID].TaskID2Activate, 
0834  0EFD     MOVLW 0xFD
0836  50DB     MOVF PLUSW2, W, ACCESS
0838  0D0D     MULLW 0xD
083A  CFF3     MOVFF PROD, FSR0
083C  FFE9     NOP
083E  CFF4     MOVFF PRODH, FSR0H
0840  FFEA     NOP
0842  0E14     MOVLW 0x14
0844  26E9     ADDWF FSR0, F, ACCESS
0846  0E0E     MOVLW 0xE
0848  22EA     ADDWFC FSR0H, F, ACCESS
084A  0E07     MOVLW 0x7
084C  26E9     ADDWF FSR0, F, ACCESS
084E  0E00     MOVLW 0x0
0850  22EA     ADDWFC FSR0H, F, ACCESS
0852  50EF     MOVF INDF0, W, ACCESS
0854  6EE6     MOVWF POSTINC1, ACCESS
237:                          Alarm_list[ID].EventToPost);
0812  0EFD     MOVLW 0xFD
0814  50DB     MOVF PLUSW2, W, ACCESS
0816  0D0D     MULLW 0xD
0818  CFF3     MOVFF PROD, FSR0
081A  FFE9     NOP
081C  CFF4     MOVFF PRODH, FSR0H
081E  FFEA     NOP
0820  0E14     MOVLW 0x14
0822  26E9     ADDWF FSR0, F, ACCESS
0824  0E0E     MOVLW 0xE
0826  22EA     ADDWFC FSR0H, F, ACCESS
0828  0E08     MOVLW 0x8
082A  26E9     ADDWF FSR0, F, ACCESS
082C  0E00     MOVLW 0x0
082E  22EA     ADDWFC FSR0H, F, ACCESS
0830  50EF     MOVF INDF0, W, ACCESS
0832  6EE6     MOVWF POSTINC1, ACCESS
0856  EC17     CALL 0x162E, 0
0858  F00B     NOP
085A  52E5     MOVF POSTDEC1, F, ACCESS
085C  52E5     MOVF POSTDEC1, F, ACCESS
238:               if ((Alarm_list[ID].TaskID2Activate != 0) &&
085E  0EFD     MOVLW 0xFD
0860  50DB     MOVF PLUSW2, W, ACCESS
0862  0D0D     MULLW 0xD
0864  CFF3     MOVFF PROD, FSR0
0866  FFE9     NOP
0868  CFF4     MOVFF PRODH, FSR0H
086A  FFEA     NOP
086C  0E14     MOVLW 0x14
086E  26E9     ADDWF FSR0, F, ACCESS
0870  0E0E     MOVLW 0xE
0872  22EA     ADDWFC FSR0H, F, ACCESS
0874  0E07     MOVLW 0x7
0876  26E9     ADDWF FSR0, F, ACCESS
0878  0E00     MOVLW 0x0
087A  22EA     ADDWFC FSR0H, F, ACCESS
087C  50EF     MOVF INDF0, W, ACCESS
239:                   (Alarm_list[ID].EventToPost == 0))
087E  E026     BZ 0x8CC
0880  0EFD     MOVLW 0xFD
0882  50DB     MOVF PLUSW2, W, ACCESS
0884  0D0D     MULLW 0xD
0886  CFF3     MOVFF PROD, FSR0
0888  FFE9     NOP
088A  CFF4     MOVFF PRODH, FSR0H
088C  FFEA     NOP
088E  0E14     MOVLW 0x14
0890  26E9     ADDWF FSR0, F, ACCESS
0892  0E0E     MOVLW 0xE
0894  22EA     ADDWFC FSR0H, F, ACCESS
0896  0E08     MOVLW 0x8
0898  26E9     ADDWF FSR0, F, ACCESS
089A  0E00     MOVLW 0x0
089C  22EA     ADDWFC FSR0H, F, ACCESS
089E  50EE     MOVF POSTINC0, W, ACCESS
08A0  10ED     IORWF POSTDEC0, W, ACCESS
08A2  E114     BNZ 0x8CC
240:                 ActivateTask(Alarm_list[ID].TaskID2Activate);
08A4  0EFD     MOVLW 0xFD
08A6  50DB     MOVF PLUSW2, W, ACCESS
08A8  0D0D     MULLW 0xD
08AA  CFF3     MOVFF PROD, FSR0
08AC  FFE9     NOP
08AE  CFF4     MOVFF PRODH, FSR0H
08B0  FFEA     NOP
08B2  0E14     MOVLW 0x14
08B4  26E9     ADDWF FSR0, F, ACCESS
08B6  0E0E     MOVLW 0xE
08B8  22EA     ADDWFC FSR0H, F, ACCESS
08BA  0E07     MOVLW 0x7
08BC  26E9     ADDWF FSR0, F, ACCESS
08BE  0E00     MOVLW 0x0
08C0  22EA     ADDWFC FSR0H, F, ACCESS
08C2  50EF     MOVF INDF0, W, ACCESS
08C4  6EE6     MOVWF POSTINC1, ACCESS
08C6  ECA7     CALL 0xF4E, 0
08C8  F007     NOP
08CA  52E5     MOVF POSTDEC1, F, ACCESS
241:               if (Alarm_list[ID].CallBack != 0)
08CC  0EFD     MOVLW 0xFD
08CE  50DB     MOVF PLUSW2, W, ACCESS
08D0  0D0D     MULLW 0xD
08D2  CFF3     MOVFF PROD, FSR0
08D4  FFE9     NOP
08D6  CFF4     MOVFF PRODH, FSR0H
08D8  FFEA     NOP
08DA  0E14     MOVLW 0x14
08DC  26E9     ADDWF FSR0, F, ACCESS
08DE  0E0E     MOVLW 0xE
08E0  22EA     ADDWFC FSR0H, F, ACCESS
08E2  0E0A     MOVLW 0xA
08E4  26E9     ADDWF FSR0, F, ACCESS
08E6  0E00     MOVLW 0x0
08E8  22EA     ADDWFC FSR0H, F, ACCESS
08EA  CFEE     MOVFF POSTINC0, __tmp_0
08EC  F014     NOP
08EE  CFEE     MOVFF POSTINC0, 0x15
08F0  F015     NOP
08F2  CFEF     MOVFF INDF0, 0x16
08F4  F016     NOP
08F6  5014     MOVF __tmp_0, W, ACCESS
08F8  1015     IORWF 0x15, W, ACCESS
08FA  1016     IORWF 0x16, W, ACCESS
08FC  E01D     BZ 0x938
242:                 Alarm_list[ID].CallBack();
08FE  0EFD     MOVLW 0xFD
0900  50DB     MOVF PLUSW2, W, ACCESS
0902  0D0D     MULLW 0xD
0904  CFF3     MOVFF PROD, FSR0
0906  FFE9     NOP
0908  CFF4     MOVFF PRODH, FSR0H
090A  FFEA     NOP
090C  0E14     MOVLW 0x14
090E  26E9     ADDWF FSR0, F, ACCESS
0910  0E0E     MOVLW 0xE
0912  22EA     ADDWFC FSR0H, F, ACCESS
0914  0E0A     MOVLW 0xA
0916  26E9     ADDWF FSR0, F, ACCESS
0918  0E00     MOVLW 0x0
091A  22EA     ADDWFC FSR0H, F, ACCESS
091C  CFEE     MOVFF POSTINC0, __tmp_0
091E  F014     NOP
0920  CFEE     MOVFF POSTINC0, 0x15
0922  F015     NOP
0924  CFEF     MOVFF INDF0, 0x16
0926  F016     NOP
0928  D006     BRA 0x936
092A  C016     MOVFF 0x16, PCLATU
092C  FFFB     NOP
092E  C015     MOVFF 0x15, PCLATH
0930  FFFA     NOP
0932  5014     MOVF __tmp_0, W, ACCESS
0934  6EF9     MOVWF PCL, ACCESS
0936  DFF9     RCALL 0x92A
243:             }
244:             return (E_OK);
0938  0E00     MOVLW 0x0
093A  D000     BRA 0x93C
245:           }
093C  52E5     MOVF POSTDEC1, F, ACCESS
093E  CFE5     MOVFF POSTDEC1, FSR2H
0940  FFDA     NOP
0942  CFE7     MOVFF INDF1, FSR2
0944  FFD9     NOP
0946  0012     RETURN 0
246:           
247:           /*********************************************************************
248:            * Give the current number of tick of the alarm in COUNTER mode. 
249:            * Work also with alarm in TIMER mode.
250:            *
251:            * @param ID         IN  ID of the alarm to update 
252:            * @param Tick       IN  Reference of tick number
253:            * @return Status    E_OK if ID is correct
254:            *                   E_OS_ACCESS if counter is OFF
255:            *                   E_OS_ID if not correct
256:            *********************************************************************/
257:           StatusType GetCounterValue(AlarmType ID, TickRefType tick)
0948  CFD9     MOVFF FSR2, POSTINC1
094A  FFE6     NOP
094C  CFDA     MOVFF FSR2H, POSTINC1
094E  FFE6     NOP
0950  CFE1     MOVFF FSR1, FSR2
0952  FFD9     NOP
0954  CFE2     MOVFF FSR1H, FSR2H
0956  FFDA     NOP
258:           {
259:             if (ID >= ALARMNUMBER)
0958  010E     MOVLB 0xE
095A  512E     MOVF 0x2E, W, BANKED
095C  6EF3     MOVWF PROD, ACCESS
095E  0EFD     MOVLW 0xFD
0960  CFDB     MOVFF PLUSW2, PRODH
0962  FFF4     NOP
0964  50F3     MOVF PROD, W, ACCESS
0966  5CF4     SUBWF PRODH, W, ACCESS
0968  E302     BNC 0x96E
260:               return (E_OS_ID);
096A  0E03     MOVLW 0x3
096C  D036     BRA 0x9DA
261:           
262:             if (Alarm_list[ID].State == OFF)
096E  0EFD     MOVLW 0xFD
0970  50DB     MOVF PLUSW2, W, ACCESS
0972  0D0D     MULLW 0xD
0974  CFF3     MOVFF PROD, FSR0
0976  FFE9     NOP
0978  CFF4     MOVFF PRODH, FSR0H
097A  FFEA     NOP
097C  0E14     MOVLW 0x14
097E  26E9     ADDWF FSR0, F, ACCESS
0980  0E0E     MOVLW 0xE
0982  22EA     ADDWFC FSR0H, F, ACCESS
0984  50EF     MOVF INDF0, W, ACCESS
0986  E102     BNZ 0x98C
263:               return(E_OS_ACCESS);
0988  0E01     MOVLW 0x1
098A  D027     BRA 0x9DA
264:           
265:             *tick = Alarm_list[ID].ptrCounter->CounterValue;
098C  0EFD     MOVLW 0xFD
098E  50DB     MOVF PLUSW2, W, ACCESS
0990  0D0D     MULLW 0xD
0992  CFF3     MOVFF PROD, FSR0
0994  FFE9     NOP
0996  CFF4     MOVFF PRODH, FSR0H
0998  FFEA     NOP
099A  0E14     MOVLW 0x14
099C  26E9     ADDWF FSR0, F, ACCESS
099E  0E0E     MOVLW 0xE
09A0  22EA     ADDWFC FSR0H, F, ACCESS
09A2  0E05     MOVLW 0x5
09A4  26E9     ADDWF FSR0, F, ACCESS
09A6  0E00     MOVLW 0x0
09A8  22EA     ADDWFC FSR0H, F, ACCESS
09AA  50EE     MOVF POSTINC0, W, ACCESS
09AC  CFEF     MOVFF INDF0, FSR0H
09AE  FFEA     NOP
09B0  6EE9     MOVWF FSR0, ACCESS
09B2  0E06     MOVLW 0x6
09B4  26E9     ADDWF FSR0, F, ACCESS
09B6  0E00     MOVLW 0x0
09B8  22EA     ADDWFC FSR0H, F, ACCESS
09BA  CFEE     MOVFF POSTINC0, __tmp_0
09BC  F014     NOP
09BE  CFEF     MOVFF INDF0, 0x15
09C0  F015     NOP
09C2  0EFB     MOVLW 0xFB
09C4  CFDB     MOVFF PLUSW2, FSR0
09C6  FFE9     NOP
09C8  0EFC     MOVLW 0xFC
09CA  CFDB     MOVFF PLUSW2, FSR0H
09CC  FFEA     NOP
09CE  C014     MOVFF __tmp_0, POSTINC0
09D0  FFEE     NOP
09D2  C015     MOVFF 0x15, POSTDEC0
09D4  FFED     NOP
266:             return (E_OK);
09D6  0E00     MOVLW 0x0
09D8  D000     BRA 0x9DA
267:           }
09DA  52E5     MOVF POSTDEC1, F, ACCESS
09DC  CFE5     MOVFF POSTDEC1, FSR2H
09DE  FFDA     NOP
09E0  CFE7     MOVFF INDF1, FSR2
09E2  FFD9     NOP
09E4  0012     RETURN 0
268:           
269:           /**********************************************************************
270:            * Parse the chained list of alarms (timer & counter).
271:            * Increment timer only.
272:            * Check if alarm event has to be treated according to AlarmTickValue 
273:            * and CurrentTickValue.
274:            * Do it for number of cycle positive or null.
275:            * Check if a task or event has to be activated. 
276:            * If a task is waiting the event, clear the event and wait flags 
277:            * (cf event.c) and set the task READY.
278:            * Call the SCHEDULER at the end.
279:            *
280:            * @return void 
281:            **********************************************************************/
282:           void AddOneTick (void)
09E6  CFD9     MOVFF FSR2, POSTINC1
09E8  FFE6     NOP
09EA  CFDA     MOVFF FSR2H, POSTINC1
09EC  FFE6     NOP
09EE  CFE1     MOVFF FSR1, FSR2
09F0  FFD9     NOP
09F2  CFE2     MOVFF FSR1H, FSR2H
09F4  FFDA     NOP
09F6  52E6     MOVF POSTINC1, F, ACCESS
09F8  52E6     MOVF POSTINC1, F, ACCESS
09FA  52E6     MOVF POSTINC1, F, ACCESS
283:           {
284:             unsigned char index;
285:           
286:             /* To setup 1 tick at 1ms */
287:             /*TMR0H = Tmr0.bt[1];*/
288:             /*TMR0L = Tmr0.bt[0];*/
289:             
290:             /* To setup 1 tick at 1ms (improved no-drag version) */ 
291:             union Timers tmr;  /* Temp for holding timer value */ 
292:             tmr.bt[0] = TMR0L; /* Read TMR0 */ 
09FC  0E01     MOVLW 0x1
09FE  CFD6     MOVFF TMR0, PLUSW2
0A00  FFDB     NOP
293:             tmr.bt[1] = TMR0H; 
0A02  0E02     MOVLW 0x2
0A04  CFD7     MOVFF TMR0H, PLUSW2
0A06  FFDB     NOP
294:             tmr.lt += Tmr0.lt; /* Add offset value to TMR0 */ 
0A08  50D9     MOVF FSR2, W, ACCESS
0A0A  0F01     ADDLW 0x1
0A0C  6EE9     MOVWF FSR0, ACCESS
0A0E  0E00     MOVLW 0x0
0A10  20DA     ADDWFC FSR2H, W, ACCESS
0A12  6EEA     MOVWF FSR0H, ACCESS
0A14  0107     MOVLB 0x7
0A16  51FE     MOVF 0xFE, W, BANKED
0A18  26EE     ADDWF POSTINC0, F, ACCESS
0A1A  51FF     MOVF 0xFF, W, BANKED
0A1C  22ED     ADDWFC POSTDEC0, F, ACCESS
295:             tmr.lt += 26;      /* time from read TMR0 to update TMR0 */ 
0A1E  50D9     MOVF FSR2, W, ACCESS
0A20  0F01     ADDLW 0x1
0A22  6EE9     MOVWF FSR0, ACCESS
0A24  0E00     MOVLW 0x0
0A26  20DA     ADDWFC FSR2H, W, ACCESS
0A28  6EEA     MOVWF FSR0H, ACCESS
0A2A  0E1A     MOVLW 0x1A
0A2C  26EE     ADDWF POSTINC0, F, ACCESS
0A2E  0E00     MOVLW 0x0
0A30  22ED     ADDWFC POSTDEC0, F, ACCESS
296:             TMR0H = tmr.bt[1]; 
0A32  0E02     MOVLW 0x2
0A34  50DB     MOVF PLUSW2, W, ACCESS
0A36  6ED7     MOVWF TMR0H, ACCESS
297:             TMR0L = tmr.bt[0]; /* Update TMR0 */ 
0A38  0E01     MOVLW 0x1
0A3A  50DB     MOVF PLUSW2, W, ACCESS
0A3C  6ED6     MOVWF TMR0, ACCESS
298:           
299:           
300:             INTCONbits.TMR0IF = 0;
0A3E  94F2     BCF INTCON, 2, ACCESS
301:             Counter_kernel.CounterValue++;
0A40  010E     MOVLB 0xE
0A42  2B10     INCF 0x10, F, BANKED
0A44  0E00     MOVLW 0x0
0A46  2311     ADDWFC 0x11, F, BANKED
302:             global_counter++;
0A48  010E     MOVLB 0xE
0A4A  2B30     INCF 0x30, F, BANKED
0A4C  2331     ADDWFC 0x31, F, BANKED
0A4E  2332     ADDWFC 0x32, F, BANKED
0A50  2333     ADDWFC 0x33, F, BANKED
303:             for (index = 0; index < ALARMNUMBER; index++)
0A52  6ADF     CLRF INDF2, ACCESS
0A54  010E     MOVLB 0xE
0A56  512E     MOVF 0x2E, W, BANKED
0A58  5CDF     SUBWF INDF2, W, ACCESS
0A5A  E301     BNC 0xA5E
0A5C  D136     BRA 0xCCA
0CC6  2ADF     INCF INDF2, F, ACCESS
0CC8  D6C5     BRA 0xA54
304:             {
305:               if (Alarm_list[index].State == OFF)
0A5E  50DF     MOVF INDF2, W, ACCESS
0A60  0D0D     MULLW 0xD
0A62  CFF3     MOVFF PROD, FSR0
0A64  FFE9     NOP
0A66  CFF4     MOVFF PRODH, FSR0H
0A68  FFEA     NOP
0A6A  0E14     MOVLW 0x14
0A6C  26E9     ADDWF FSR0, F, ACCESS
0A6E  0E0E     MOVLW 0xE
0A70  22EA     ADDWFC FSR0H, F, ACCESS
0A72  50EF     MOVF INDF0, W, ACCESS
0A74  E101     BNZ 0xA78
306:                 continue;
0A76  D127     BRA 0xCC6
307:           
308:               if (Alarm_list[index].ptrCounter->CounterValue == 
0A78  50DF     MOVF INDF2, W, ACCESS
0A7A  0D0D     MULLW 0xD
0A7C  CFF3     MOVFF PROD, FSR0
0A7E  FFE9     NOP
0A80  CFF4     MOVFF PRODH, FSR0H
0A82  FFEA     NOP
0A84  0E14     MOVLW 0x14
0A86  26E9     ADDWF FSR0, F, ACCESS
0A88  0E0E     MOVLW 0xE
0A8A  22EA     ADDWFC FSR0H, F, ACCESS
0A8C  0E05     MOVLW 0x5
0A8E  26E9     ADDWF FSR0, F, ACCESS
0A90  0E00     MOVLW 0x0
0A92  22EA     ADDWFC FSR0H, F, ACCESS
0A94  50EE     MOVF POSTINC0, W, ACCESS
0A96  CFEF     MOVFF INDF0, FSR0H
0A98  FFEA     NOP
0A9A  6EE9     MOVWF FSR0, ACCESS
0A9C  0E06     MOVLW 0x6
0A9E  26E9     ADDWF FSR0, F, ACCESS
0AA0  0E00     MOVLW 0x0
0AA2  22EA     ADDWFC FSR0H, F, ACCESS
0AA4  CFEE     MOVFF POSTINC0, __tmp_0
0AA6  F014     NOP
0AA8  CFEF     MOVFF INDF0, 0x15
0AAA  F015     NOP
309:                   Alarm_list[index].AlarmValue)
0AAC  50DF     MOVF INDF2, W, ACCESS
0AAE  0D0D     MULLW 0xD
0AB0  CFF3     MOVFF PROD, FSR0
0AB2  FFE9     NOP
0AB4  CFF4     MOVFF PRODH, FSR0H
0AB6  FFEA     NOP
0AB8  0E14     MOVLW 0x14
0ABA  26E9     ADDWF FSR0, F, ACCESS
0ABC  0E0E     MOVLW 0xE
0ABE  22EA     ADDWFC FSR0H, F, ACCESS
0AC0  52EE     MOVF POSTINC0, F, ACCESS
0AC2  CFEE     MOVFF POSTINC0, 0x16
0AC4  F016     NOP
0AC6  CFEF     MOVFF INDF0, 0x17
0AC8  F017     NOP
0ACA  5016     MOVF 0x16, W, ACCESS
0ACC  1814     XORWF __tmp_0, W, ACCESS
0ACE  E102     BNZ 0xAD4
0AD0  5017     MOVF 0x17, W, ACCESS
0AD2  1815     XORWF 0x15, W, ACCESS
0AD4  E001     BZ 0xAD8
0AD6  D0F7     BRA 0xCC6
310:               {
311:                 if (Alarm_list[index].Cycle == 0)
0AD8  50DF     MOVF INDF2, W, ACCESS
0ADA  0D0D     MULLW 0xD
0ADC  CFF3     MOVFF PROD, FSR0
0ADE  FFE9     NOP
0AE0  CFF4     MOVFF PRODH, FSR0H
0AE2  FFEA     NOP
0AE4  0E14     MOVLW 0x14
0AE6  26E9     ADDWF FSR0, F, ACCESS
0AE8  0E0E     MOVLW 0xE
0AEA  22EA     ADDWFC FSR0H, F, ACCESS
0AEC  0E03     MOVLW 0x3
0AEE  26E9     ADDWF FSR0, F, ACCESS
0AF0  0E00     MOVLW 0x0
0AF2  22EA     ADDWFC FSR0H, F, ACCESS
0AF4  50EE     MOVF POSTINC0, W, ACCESS
0AF6  10ED     IORWF POSTDEC0, W, ACCESS
0AF8  E10C     BNZ 0xB12
312:                   Alarm_list[index].State = OFF;
0AFA  50DF     MOVF INDF2, W, ACCESS
0AFC  0D0D     MULLW 0xD
0AFE  CFF3     MOVFF PROD, FSR0
0B00  FFE9     NOP
0B02  CFF4     MOVFF PRODH, FSR0H
0B04  FFEA     NOP
0B06  0E14     MOVLW 0x14
0B08  26E9     ADDWF FSR0, F, ACCESS
0B0A  0E0E     MOVLW 0xE
0B0C  22EA     ADDWFC FSR0H, F, ACCESS
0B0E  6AEF     CLRF INDF0, ACCESS
313:                 else
0B10  D03D     BRA 0xB8C
314:                 {
315:                   Alarm_list[index].AlarmValue = \
0B12  50DF     MOVF INDF2, W, ACCESS
0B14  0D0D     MULLW 0xD
0B16  CFF3     MOVFF PROD, FSR0
0B18  FFE9     NOP
0B1A  CFF4     MOVFF PRODH, FSR0H
0B1C  FFEA     NOP
0B1E  0E14     MOVLW 0x14
0B20  26E9     ADDWF FSR0, F, ACCESS
0B22  0E0E     MOVLW 0xE
0B24  22EA     ADDWFC FSR0H, F, ACCESS
0B26  0E05     MOVLW 0x5
0B28  26E9     ADDWF FSR0, F, ACCESS
0B2A  0E00     MOVLW 0x0
0B2C  22EA     ADDWFC FSR0H, F, ACCESS
0B2E  50EE     MOVF POSTINC0, W, ACCESS
0B30  CFEF     MOVFF INDF0, FSR0H
0B32  FFEA     NOP
0B34  6EE9     MOVWF FSR0, ACCESS
0B36  0E06     MOVLW 0x6
0B38  26E9     ADDWF FSR0, F, ACCESS
0B3A  0E00     MOVLW 0x0
0B3C  22EA     ADDWFC FSR0H, F, ACCESS
0B3E  CFEE     MOVFF POSTINC0, 0x16
0B40  F016     NOP
0B42  CFEF     MOVFF INDF0, 0x17
0B44  F017     NOP
0B46  50DF     MOVF INDF2, W, ACCESS
0B48  0D0D     MULLW 0xD
0B4A  CFF3     MOVFF PROD, FSR0
0B4C  FFE9     NOP
0B4E  CFF4     MOVFF PRODH, FSR0H
0B50  FFEA     NOP
0B52  0E14     MOVLW 0x14
0B54  26E9     ADDWF FSR0, F, ACCESS
0B56  0E0E     MOVLW 0xE
0B58  22EA     ADDWFC FSR0H, F, ACCESS
0B5A  0E03     MOVLW 0x3
0B5C  26E9     ADDWF FSR0, F, ACCESS
0B5E  0E00     MOVLW 0x0
0B60  22EA     ADDWFC FSR0H, F, ACCESS
0B62  5016     MOVF 0x16, W, ACCESS
0B64  24EE     ADDWF POSTINC0, W, ACCESS
0B66  6E14     MOVWF __tmp_0, ACCESS
0B68  5017     MOVF 0x17, W, ACCESS
0B6A  20EE     ADDWFC POSTINC0, W, ACCESS
0B6C  6E15     MOVWF 0x15, ACCESS
0B6E  50DF     MOVF INDF2, W, ACCESS
0B70  0D0D     MULLW 0xD
0B72  CFF3     MOVFF PROD, FSR0
0B74  FFE9     NOP
0B76  CFF4     MOVFF PRODH, FSR0H
0B78  FFEA     NOP
0B7A  0E14     MOVLW 0x14
0B7C  26E9     ADDWF FSR0, F, ACCESS
0B7E  0E0E     MOVLW 0xE
0B80  22EA     ADDWFC FSR0H, F, ACCESS
0B82  52EE     MOVF POSTINC0, F, ACCESS
0B84  C014     MOVFF __tmp_0, POSTINC0
0B86  FFEE     NOP
0B88  C015     MOVFF 0x15, POSTDEC0
0B8A  FFED     NOP
316:                     Alarm_list[index].ptrCounter->CounterValue + \
317:                     Alarm_list[index].Cycle;
318:                 }
319:                 
320:                 if (Alarm_list[index].EventToPost != 0)
0B8C  50DF     MOVF INDF2, W, ACCESS
0B8E  0D0D     MULLW 0xD
0B90  CFF3     MOVFF PROD, FSR0
0B92  FFE9     NOP
0B94  CFF4     MOVFF PRODH, FSR0H
0B96  FFEA     NOP
0B98  0E14     MOVLW 0x14
0B9A  26E9     ADDWF FSR0, F, ACCESS
0B9C  0E0E     MOVLW 0xE
0B9E  22EA     ADDWFC FSR0H, F, ACCESS
0BA0  0E08     MOVLW 0x8
0BA2  26E9     ADDWF FSR0, F, ACCESS
0BA4  0E00     MOVLW 0x0
0BA6  22EA     ADDWFC FSR0H, F, ACCESS
0BA8  50EE     MOVF POSTINC0, W, ACCESS
0BAA  10ED     IORWF POSTDEC0, W, ACCESS
0BAC  E024     BZ 0xBF6
321:                   SetEvent(Alarm_list[index].TaskID2Activate, 
0BCE  50DF     MOVF INDF2, W, ACCESS
0BD0  0D0D     MULLW 0xD
0BD2  CFF3     MOVFF PROD, FSR0
0BD4  FFE9     NOP
0BD6  CFF4     MOVFF PRODH, FSR0H
0BD8  FFEA     NOP
0BDA  0E14     MOVLW 0x14
0BDC  26E9     ADDWF FSR0, F, ACCESS
0BDE  0E0E     MOVLW 0xE
0BE0  22EA     ADDWFC FSR0H, F, ACCESS
0BE2  0E07     MOVLW 0x7
0BE4  26E9     ADDWF FSR0, F, ACCESS
0BE6  0E00     MOVLW 0x0
0BE8  22EA     ADDWFC FSR0H, F, ACCESS
0BEA  50EF     MOVF INDF0, W, ACCESS
0BEC  6EE6     MOVWF POSTINC1, ACCESS
322:                             Alarm_list[index].EventToPost);
0BAE  50DF     MOVF INDF2, W, ACCESS
0BB0  0D0D     MULLW 0xD
0BB2  CFF3     MOVFF PROD, FSR0
0BB4  FFE9     NOP
0BB6  CFF4     MOVFF PRODH, FSR0H
0BB8  FFEA     NOP
0BBA  0E14     MOVLW 0x14
0BBC  26E9     ADDWF FSR0, F, ACCESS
0BBE  0E0E     MOVLW 0xE
0BC0  22EA     ADDWFC FSR0H, F, ACCESS
0BC2  0E08     MOVLW 0x8
0BC4  26E9     ADDWF FSR0, F, ACCESS
0BC6  0E00     MOVLW 0x0
0BC8  22EA     ADDWFC FSR0H, F, ACCESS
0BCA  50EF     MOVF INDF0, W, ACCESS
0BCC  6EE6     MOVWF POSTINC1, ACCESS
0BEE  EC17     CALL 0x162E, 0
0BF0  F00B     NOP
0BF2  52E5     MOVF POSTDEC1, F, ACCESS
0BF4  52E5     MOVF POSTDEC1, F, ACCESS
323:           
324:                 if ((Alarm_list[index].TaskID2Activate != 0) &&
0BF6  50DF     MOVF INDF2, W, ACCESS
0BF8  0D0D     MULLW 0xD
0BFA  CFF3     MOVFF PROD, FSR0
0BFC  FFE9     NOP
0BFE  CFF4     MOVFF PRODH, FSR0H
0C00  FFEA     NOP
0C02  0E14     MOVLW 0x14
0C04  26E9     ADDWF FSR0, F, ACCESS
0C06  0E0E     MOVLW 0xE
0C08  22EA     ADDWFC FSR0H, F, ACCESS
0C0A  0E07     MOVLW 0x7
0C0C  26E9     ADDWF FSR0, F, ACCESS
0C0E  0E00     MOVLW 0x0
0C10  22EA     ADDWFC FSR0H, F, ACCESS
0C12  50EF     MOVF INDF0, W, ACCESS
325:                     (Alarm_list[index].EventToPost == 0))
0C14  E024     BZ 0xC5E
0C16  50DF     MOVF INDF2, W, ACCESS
0C18  0D0D     MULLW 0xD
0C1A  CFF3     MOVFF PROD, FSR0
0C1C  FFE9     NOP
0C1E  CFF4     MOVFF PRODH, FSR0H
0C20  FFEA     NOP
0C22  0E14     MOVLW 0x14
0C24  26E9     ADDWF FSR0, F, ACCESS
0C26  0E0E     MOVLW 0xE
0C28  22EA     ADDWFC FSR0H, F, ACCESS
0C2A  0E08     MOVLW 0x8
0C2C  26E9     ADDWF FSR0, F, ACCESS
0C2E  0E00     MOVLW 0x0
0C30  22EA     ADDWFC FSR0H, F, ACCESS
0C32  50EE     MOVF POSTINC0, W, ACCESS
0C34  10ED     IORWF POSTDEC0, W, ACCESS
0C36  E113     BNZ 0xC5E
326:                   ActivateTask(Alarm_list[index].TaskID2Activate);
0C38  50DF     MOVF INDF2, W, ACCESS
0C3A  0D0D     MULLW 0xD
0C3C  CFF3     MOVFF PROD, FSR0
0C3E  FFE9     NOP
0C40  CFF4     MOVFF PRODH, FSR0H
0C42  FFEA     NOP
0C44  0E14     MOVLW 0x14
0C46  26E9     ADDWF FSR0, F, ACCESS
0C48  0E0E     MOVLW 0xE
0C4A  22EA     ADDWFC FSR0H, F, ACCESS
0C4C  0E07     MOVLW 0x7
0C4E  26E9     ADDWF FSR0, F, ACCESS
0C50  0E00     MOVLW 0x0
0C52  22EA     ADDWFC FSR0H, F, ACCESS
0C54  50EF     MOVF INDF0, W, ACCESS
0C56  6EE6     MOVWF POSTINC1, ACCESS
0C58  ECA7     CALL 0xF4E, 0
0C5A  F007     NOP
0C5C  52E5     MOVF POSTDEC1, F, ACCESS
327:           
328:                 if (Alarm_list[index].CallBack != 0)
0C5E  50DF     MOVF INDF2, W, ACCESS
0C60  0D0D     MULLW 0xD
0C62  CFF3     MOVFF PROD, FSR0
0C64  FFE9     NOP
0C66  CFF4     MOVFF PRODH, FSR0H
0C68  FFEA     NOP
0C6A  0E14     MOVLW 0x14
0C6C  26E9     ADDWF FSR0, F, ACCESS
0C6E  0E0E     MOVLW 0xE
0C70  22EA     ADDWFC FSR0H, F, ACCESS
0C72  0E0A     MOVLW 0xA
0C74  26E9     ADDWF FSR0, F, ACCESS
0C76  0E00     MOVLW 0x0
0C78  22EA     ADDWFC FSR0H, F, ACCESS
0C7A  CFEE     MOVFF POSTINC0, __tmp_0
0C7C  F014     NOP
0C7E  CFEE     MOVFF POSTINC0, 0x15
0C80  F015     NOP
0C82  CFEF     MOVFF INDF0, 0x16
0C84  F016     NOP
0C86  5014     MOVF __tmp_0, W, ACCESS
0C88  1015     IORWF 0x15, W, ACCESS
0C8A  1016     IORWF 0x16, W, ACCESS
0C8C  E01C     BZ 0xCC6
329:                   Alarm_list[index].CallBack();
0C8E  50DF     MOVF INDF2, W, ACCESS
0C90  0D0D     MULLW 0xD
0C92  CFF3     MOVFF PROD, FSR0
0C94  FFE9     NOP
0C96  CFF4     MOVFF PRODH, FSR0H
0C98  FFEA     NOP
0C9A  0E14     MOVLW 0x14
0C9C  26E9     ADDWF FSR0, F, ACCESS
0C9E  0E0E     MOVLW 0xE
0CA0  22EA     ADDWFC FSR0H, F, ACCESS
0CA2  0E0A     MOVLW 0xA
0CA4  26E9     ADDWF FSR0, F, ACCESS
0CA6  0E00     MOVLW 0x0
0CA8  22EA     ADDWFC FSR0H, F, ACCESS
0CAA  CFEE     MOVFF POSTINC0, __tmp_0
0CAC  F014     NOP
0CAE  CFEE     MOVFF POSTINC0, 0x15
0CB0  F015     NOP
0CB2  CFEF     MOVFF INDF0, 0x16
0CB4  F016     NOP
0CB6  D006     BRA 0xCC4
0CB8  C016     MOVFF 0x16, PCLATU
0CBA  FFFB     NOP
0CBC  C015     MOVFF 0x15, PCLATH
0CBE  FFFA     NOP
0CC0  5014     MOVF __tmp_0, W, ACCESS
0CC2  6EF9     MOVWF PCL, ACCESS
0CC4  DFF9     RCALL 0xCB8
330:               }
331:             }
332:           
333:             kernelState |= SERVICES;
0CCA  0100     MOVLB 0x0
0CCC  8572     BSF kernelState, 2, BANKED
334:           }
0CCE  52E5     MOVF POSTDEC1, F, ACCESS
0CD0  52E5     MOVF POSTDEC1, F, ACCESS
0CD2  52E5     MOVF POSTDEC1, F, ACCESS
0CD4  52E5     MOVF POSTDEC1, F, ACCESS
0CD6  CFE5     MOVFF POSTDEC1, FSR2H
0CD8  FFDA     NOP
0CDA  CFE7     MOVFF INDF1, FSR2
0CDC  FFD9     NOP
0CDE  0012     RETURN 0
335:           
336:           
337:           /* End of File : alarm.c */
---  C:/MCC18/src/traditional/proc/p18F45J50.asm  -------------------------------------------------------
3484  0EC0     MOVLW 0xC0
3486  6EF3     MOVWF PROD, ACCESS
3488  EE00     LFSR 0, 0x0
348A  F000     NOP
348C  0E0E     MOVLW 0xE
348E  D801     RCALL zero_block
3490  0012     RETURN 0
3492  60EA     CPFSLT FSR0H, ACCESS
3494  D002     BRA compare_l
3496  6AEE     CLRF POSTINC0, ACCESS
3498  D7FC     BRA zero_block
349A  50F3     MOVF PROD, W, ACCESS
349C  60E9     CPFSLT FSR0, ACCESS
349E  0012     RETURN 0
34A0  6AEE     CLRF POSTINC0, ACCESS
34A2  D7FC     BRA loop_l
---  C:/MCC18/src/traditional/math/packFP.asm  ----------------------------------------------------------
2E88  0E7F     MOVLW 0x7F
2E8A  6E08     MOVWF 0x8, ACCESS
2E8C  0EFF     MOVLW 0xFF
2E8E  6E07     MOVWF 0x7, ACCESS
2E90  6E06     MOVWF 0x6, ACCESS
2E92  6E05     MOVWF 0x5, ACCESS
2E94  0012     RETURN 0
2E96  0E7F     MOVLW 0x7F
2E98  BE0F     BTFSC 0xF, 7, ACCESS
2E9A  0EFF     MOVLW 0xFF
2E9C  6E08     MOVWF 0x8, ACCESS
2E9E  D002     BRA jReturnPosInf0
2EA0  0E7F     MOVLW 0x7F
2EA2  6E08     MOVWF 0x8, ACCESS
2EA4  0E80     MOVLW 0x80
2EA6  6E07     MOVWF 0x7, ACCESS
2EA8  6A06     CLRF 0x6, ACCESS
2EAA  6A05     CLRF 0x5, ACCESS
2EAC  D7F3     BRA __FpExit
2EAE  AE0F     BTFSS 0xF, 7, ACCESS
2EB0  D004     BRA __FpReturnPosZero
2EB2  0E80     MOVLW 0x80
2EB4  6E08     MOVWF 0x8, ACCESS
2EB6  6A07     CLRF 0x7, ACCESS
2EB8  D7F7     BRA jZero1and2
2EBA  6A08     CLRF 0x8, ACCESS
2EBC  6A07     CLRF 0x7, ACCESS
2EBE  D7F4     BRA jZero1and2
2EC0  5001     MOVF tmr, W, ACCESS
2EC2  1000     IORWF index, W, ACCESS
2EC4  1013     IORWF 0x13, W, ACCESS
2EC6  1012     IORWF 0x12, W, ACCESS
2EC8  E0F8     BZ __FpReturnPosZero
2ECA  BE03     BTFSC 0x3, 7, ACCESS
2ECC  D7F0     BRA __FpReturnSignZero
2ECE  BE01     BTFSC tmr, 7, ACCESS
2ED0  D00C     BRA jPkShiftDone
2ED2  5002     MOVF j, W, ACCESS
2ED4  1003     IORWF 0x3, W, ACCESS
2ED6  E0EB     BZ __FpReturnSignZero
2ED8  90D8     BCF STATUS, 0, ACCESS
2EDA  3612     RLCF 0x12, F, ACCESS
2EDC  3613     RLCF 0x13, F, ACCESS
2EDE  3600     RLCF index, F, ACCESS
2EE0  3601     RLCF tmr, F, ACCESS
2EE2  0602     DECF j, F, ACCESS
2EE4  A0D8     BTFSS STATUS, 0, ACCESS
2EE6  0603     DECF 0x3, F, ACCESS
2EE8  D7F2     BRA jPkLoop
2EEA  5003     MOVF 0x3, W, ACCESS
2EEC  E1D4     BNZ __FpReturnSignInf
2EEE  2802     INCF j, W, ACCESS
2EF0  E0D2     BZ __FpReturnSignInf
2EF2  AE12     BTFSS 0x12, 7, ACCESS
2EF4  D011     BRA jPkRoundDone
2EF6  0E7F     MOVLW 0x7F
2EF8  1412     ANDWF 0x12, W, ACCESS
2EFA  E102     BNZ jPkRoundIt
2EFC  A013     BTFSS 0x13, 0, ACCESS
2EFE  D00C     BRA jPkRoundDone
2F00  2A13     INCF 0x13, F, ACCESS
2F02  6AE8     CLRF WREG, ACCESS
2F04  2200     ADDWFC index, F, ACCESS
2F06  2201     ADDWFC tmr, F, ACCESS
2F08  E307     BNC jPkRoundDone
2F0A  80D8     BSF STATUS, 0, ACCESS
2F0C  3201     RRCF tmr, F, ACCESS
2F0E  3200     RRCF index, F, ACCESS
2F10  3213     RRCF 0x13, F, ACCESS
2F12  2A02     INCF j, F, ACCESS
2F14  2802     INCF j, W, ACCESS
2F16  E0BF     BZ __FpReturnSignInf
2F18  5002     MOVF j, W, ACCESS
2F1A  E0C9     BZ __FpReturnSignZero
2F1C  C013     MOVFF 0x13, 0x5
2F1E  F005     NOP
2F20  C000     MOVFF index, 0x6
2F22  F006     NOP
2F24  3401     RLCF tmr, W, ACCESS
2F26  6E07     MOVWF 0x7, ACCESS
2F28  3002     RRCF j, W, ACCESS
2F2A  6E08     MOVWF 0x8, ACCESS
2F2C  3207     RRCF 0x7, F, ACCESS
2F2E  9E08     BCF 0x8, 7, ACCESS
2F30  BE0F     BTFSC 0xF, 7, ACCESS
2F32  8E08     BSF 0x8, 7, ACCESS
2F34  EF4A     GOTO 0x2E94
2F36  F017     NOP
---  C:/MCC18/src/traditional/math/divFP.asm  -----------------------------------------------------------
2DE2  6A0F     CLRF 0xF, ACCESS
2DE4  EC9C     CALL 0x2F38, 0
2DE6  F017     NOP
2DE8  ECB4     CALL 0x2F68, 0
2DEA  F017     NOP
2DEC  B60F     BTFSC 0xF, 3, ACCESS
2DEE  EF44     GOTO 0x2E88
2DF0  F017     NOP
2DF2  A20F     BTFSS 0xF, 1, ACCESS
2DF4  D005     BRA jANotInf
2DF6  BA0F     BTFSC 0xF, 5, ACCESS
2DF8  EF44     GOTO 0x2E88
2DFA  F017     NOP
2DFC  EF4B     GOTO 0x2E96
2DFE  F017     NOP
2E00  BA0F     BTFSC 0xF, 5, ACCESS
2E02  EF57     GOTO 0x2EAE
2E04  F017     NOP
2E06  A00F     BTFSS 0xF, 0, ACCESS
2E08  D005     BRA jANotZero
2E0A  B80F     BTFSC 0xF, 4, ACCESS
2E0C  EF44     GOTO 0x2E88
2E0E  F017     NOP
2E10  EF57     GOTO 0x2EAE
2E12  F017     NOP
2E14  B80F     BTFSC 0xF, 4, ACCESS
2E16  EF4B     GOTO 0x2E96
2E18  F017     NOP
2E1A  6A03     CLRF 0x3, ACCESS
2E1C  0E7F     MOVLW 0x7F
2E1E  2408     ADDWF 0x8, W, ACCESS
2E20  6E02     MOVWF j, ACCESS
2E22  6AE8     CLRF WREG, ACCESS
2E24  2203     ADDWFC 0x3, F, ACCESS
2E26  500D     MOVF 0xD, W, ACCESS
2E28  5E02     SUBWF j, F, ACCESS
2E2A  6AE8     CLRF WREG, ACCESS
2E2C  5A03     SUBWFB 0x3, F, ACCESS
2E2E  0E1A     MOVLW 0x1A
2E30  6E10     MOVWF 0x10, ACCESS
2E32  6A08     CLRF 0x8, ACCESS
2E34  6A12     CLRF 0x12, ACCESS
2E36  6A13     CLRF 0x13, ACCESS
2E38  6A00     CLRF index, ACCESS
2E3A  6A01     CLRF tmr, ACCESS
2E3C  500A     MOVF 0xA, W, ACCESS
2E3E  5E05     SUBWF 0x5, F, ACCESS
2E40  500B     MOVF 0xB, W, ACCESS
2E42  5A06     SUBWFB 0x6, F, ACCESS
2E44  500C     MOVF 0xC, W, ACCESS
2E46  5A07     SUBWFB 0x7, F, ACCESS
2E48  0E00     MOVLW 0x0
2E4A  5A08     SUBWFB 0x8, F, ACCESS
2E4C  E709     BNN jNoAdjust
2E4E  500A     MOVF 0xA, W, ACCESS
2E50  2605     ADDWF 0x5, F, ACCESS
2E52  500B     MOVF 0xB, W, ACCESS
2E54  2206     ADDWFC 0x6, F, ACCESS
2E56  500C     MOVF 0xC, W, ACCESS
2E58  2207     ADDWFC 0x7, F, ACCESS
2E5A  0E00     MOVLW 0x0
2E5C  2208     ADDWFC 0x8, F, ACCESS
2E5E  D001     BRA jNext
2E60  8A12     BSF 0x12, 5, ACCESS
2E62  90D8     BCF STATUS, 0, ACCESS
2E64  3605     RLCF 0x5, F, ACCESS
2E66  3606     RLCF 0x6, F, ACCESS
2E68  3607     RLCF 0x7, F, ACCESS
2E6A  3608     RLCF 0x8, F, ACCESS
2E6C  90D8     BCF STATUS, 0, ACCESS
2E6E  3612     RLCF 0x12, F, ACCESS
2E70  3613     RLCF 0x13, F, ACCESS
2E72  3600     RLCF index, F, ACCESS
2E74  3601     RLCF tmr, F, ACCESS
2E76  2E10     DECFSZ 0x10, F, ACCESS
2E78  D7E1     BRA jLoop
2E7A  5007     MOVF 0x7, W, ACCESS
2E7C  1006     IORWF 0x6, W, ACCESS
2E7E  1005     IORWF 0x5, W, ACCESS
2E80  A4D8     BTFSS STATUS, 2, ACCESS
2E82  8A12     BSF 0x12, 5, ACCESS
2E84  EF60     GOTO 0x2EC0
2E86  F017     NOP
---  C:/MCC18/src/traditional/math/cast08FP.asm  --------------------------------------------------------
2C92  9E0F     BCF 0xF, 7, ACCESS
2C94  D005     BRA jI2F08Beg
2C96  9E0F     BCF 0xF, 7, ACCESS
2C98  AE07     BTFSS 0x7, 7, ACCESS
2C9A  D002     BRA jI2F08Beg
2C9C  6C07     NEGF 0x7, ACCESS
2C9E  8E0F     BSF 0xF, 7, ACCESS
2CA0  C007     MOVFF 0x7, tmr
2CA2  F001     NOP
2CA4  6A00     CLRF index, ACCESS
2CA6  6A13     CLRF 0x13, ACCESS
2CA8  6A12     CLRF 0x12, ACCESS
2CAA  0E86     MOVLW 0x86
2CAC  6E02     MOVWF j, ACCESS
2CAE  6A03     CLRF 0x3, ACCESS
2CB0  EF60     GOTO 0x2EC0
2CB2  F017     NOP
---  C:/MCC18/src/traditional/math/addFP.asm  -----------------------------------------------------------
2CB4  7E0D     BTG 0xD, 7, ACCESS
2CB6  6A0F     CLRF 0xF, ACCESS
2CB8  EC9C     CALL 0x2F38, 0
2CBA  F017     NOP
2CBC  ECB4     CALL 0x2F68, 0
2CBE  F017     NOP
2CC0  B60F     BTFSC 0xF, 3, ACCESS
2CC2  EF44     GOTO 0x2E88
2CC4  F017     NOP
2CC6  A20F     BTFSS 0xF, 1, ACCESS
2CC8  D00A     BRA jANotInf
2CCA  AA0F     BTFSS 0xF, 5, ACCESS
2CCC  D003     BRA jBANotInf
2CCE  BE0F     BTFSC 0xF, 7, ACCESS
2CD0  EF44     GOTO 0x2E88
2CD2  F017     NOP
2CD4  A40F     BTFSS 0xF, 2, ACCESS
2CD6  EF50     GOTO 0x2EA0
2CD8  F017     NOP
2CDA  EF4D     GOTO 0x2E9A
2CDC  F017     NOP
2CDE  AA0F     BTFSS 0xF, 5, ACCESS
2CE0  D005     BRA jBNotInf
2CE2  AC0F     BTFSS 0xF, 6, ACCESS
2CE4  EF50     GOTO 0x2EA0
2CE6  F017     NOP
2CE8  EF4D     GOTO 0x2E9A
2CEA  F017     NOP
2CEC  A00F     BTFSS 0xF, 0, ACCESS
2CEE  D00A     BRA jNotBothZero
2CF0  A80F     BTFSS 0xF, 4, ACCESS
2CF2  D008     BRA jNotBothZero
2CF4  BE0F     BTFSC 0xF, 7, ACCESS
2CF6  D004     BRA jDifOrPosSign
2CF8  A40F     BTFSS 0xF, 2, ACCESS
2CFA  D002     BRA jDifOrPosSign
2CFC  EF59     GOTO 0x2EB2
2CFE  F017     NOP
2D00  EF5D     GOTO 0x2EBA
2D02  F017     NOP
2D04  6A12     CLRF 0x12, ACCESS
2D06  6A03     CLRF 0x3, ACCESS
2D08  500D     MOVF 0xD, W, ACCESS
2D0A  5C08     SUBWF 0x8, W, ACCESS
2D0C  6E11     MOVWF 0x11, ACCESS
2D0E  E310     BNC jAltBexp
2D10  C005     MOVFF 0x5, 0x13
2D12  F013     NOP
2D14  C006     MOVFF 0x6, index
2D16  F000     NOP
2D18  C007     MOVFF 0x7, tmr
2D1A  F001     NOP
2D1C  C008     MOVFF 0x8, 0x10
2D1E  F010     NOP
2D20  C00A     MOVFF 0xA, 0x5
2D22  F005     NOP
2D24  C00B     MOVFF 0xB, 0x6
2D26  F006     NOP
2D28  C00C     MOVFF 0xC, 0x7
2D2A  F007     NOP
2D2C  3A0F     SWAPF 0xF, F, ACCESS
2D2E  D009     BRA jAandWsetup
2D30  C00A     MOVFF 0xA, 0x13
2D32  F013     NOP
2D34  C00B     MOVFF 0xB, index
2D36  F000     NOP
2D38  C00C     MOVFF 0xC, tmr
2D3A  F001     NOP
2D3C  C00D     MOVFF 0xD, 0x10
2D3E  F010     NOP
2D40  6C11     NEGF 0x11, ACCESS
2D42  9E0F     BCF 0xF, 7, ACCESS
2D44  BC0F     BTFSC 0xF, 6, ACCESS
2D46  8E0F     BSF 0xF, 7, ACCESS
2D48  C010     MOVFF 0x10, j
2D4A  F002     NOP
2D4C  B00F     BTFSC 0xF, 0, ACCESS
2D4E  EF8C     GOTO 0x2F18
2D50  F017     NOP
2D52  0E1A     MOVLW 0x1A
2D54  6011     CPFSLT 0x11, ACCESS
2D56  EF8C     GOTO 0x2F18
2D58  F017     NOP
2D5A  6A02     CLRF j, ACCESS
2D5C  6A08     CLRF 0x8, ACCESS
2D5E  A40F     BTFSS 0xF, 2, ACCESS
2D60  D008     BRA jANotNeg
2D62  6C05     NEGF 0x5, ACCESS
2D64  1E06     COMF 0x6, F, ACCESS
2D66  1E07     COMF 0x7, F, ACCESS
2D68  1E08     COMF 0x8, F, ACCESS
2D6A  6AE8     CLRF WREG, ACCESS
2D6C  2206     ADDWFC 0x6, F, ACCESS
2D6E  2207     ADDWFC 0x7, F, ACCESS
2D70  2208     ADDWFC 0x8, F, ACCESS
2D72  AC0F     BTFSS 0xF, 6, ACCESS
2D74  D008     BRA jWNotNeg
2D76  6C13     NEGF 0x13, ACCESS
2D78  1E00     COMF index, F, ACCESS
2D7A  1E01     COMF tmr, F, ACCESS
2D7C  1E02     COMF j, F, ACCESS
2D7E  6AE8     CLRF WREG, ACCESS
2D80  2200     ADDWFC index, F, ACCESS
2D82  2201     ADDWFC tmr, F, ACCESS
2D84  2202     ADDWFC j, F, ACCESS
2D86  6A04     CLRF 0x4, ACCESS
2D88  5211     MOVF 0x11, F, ACCESS
2D8A  E007     BZ jShiftDone
2D8C  3408     RLCF 0x8, W, ACCESS
2D8E  3207     RRCF 0x7, F, ACCESS
2D90  3206     RRCF 0x6, F, ACCESS
2D92  3205     RRCF 0x5, F, ACCESS
2D94  3204     RRCF 0x4, F, ACCESS
2D96  2E11     DECFSZ 0x11, F, ACCESS
2D98  D7F9     BRA jShiftLoop
2D9A  5005     MOVF 0x5, W, ACCESS
2D9C  2613     ADDWF 0x13, F, ACCESS
2D9E  5006     MOVF 0x6, W, ACCESS
2DA0  2200     ADDWFC index, F, ACCESS
2DA2  5007     MOVF 0x7, W, ACCESS
2DA4  2201     ADDWFC tmr, F, ACCESS
2DA6  5008     MOVF 0x8, W, ACCESS
2DA8  2202     ADDWFC j, F, ACCESS
2DAA  C004     MOVFF 0x4, 0x12
2DAC  F012     NOP
2DAE  9E0F     BCF 0xF, 7, ACCESS
2DB0  AE02     BTFSS j, 7, ACCESS
2DB2  D00B     BRA jSignDone
2DB4  6C12     NEGF 0x12, ACCESS
2DB6  1E13     COMF 0x13, F, ACCESS
2DB8  1E00     COMF index, F, ACCESS
2DBA  1E01     COMF tmr, F, ACCESS
2DBC  1E02     COMF j, F, ACCESS
2DBE  6AE8     CLRF WREG, ACCESS
2DC0  2213     ADDWFC 0x13, F, ACCESS
2DC2  2200     ADDWFC index, F, ACCESS
2DC4  2201     ADDWFC tmr, F, ACCESS
2DC6  2202     ADDWFC j, F, ACCESS
2DC8  8E0F     BSF 0xF, 7, ACCESS
2DCA  A002     BTFSS j, 0, ACCESS
2DCC  D006     BRA jFinalSign
2DCE  80D8     BSF STATUS, 0, ACCESS
2DD0  3201     RRCF tmr, F, ACCESS
2DD2  3200     RRCF index, F, ACCESS
2DD4  3213     RRCF 0x13, F, ACCESS
2DD6  3212     RRCF 0x12, F, ACCESS
2DD8  2A10     INCF 0x10, F, ACCESS
2DDA  C010     MOVFF 0x10, j
2DDC  F002     NOP
2DDE  EF60     GOTO 0x2EC0
2DE0  F017     NOP
---  C:/MCC18/src/traditional/math/UnpackFP.asm  --------------------------------------------------------
2F38  3607     RLCF 0x7, F, ACCESS
2F3A  3608     RLCF 0x8, F, ACCESS
2F3C  E302     BNC jUnpkA1
2F3E  840F     BSF 0xF, 2, ACCESS
2F40  7E0F     BTG 0xF, 7, ACCESS
2F42  E106     BNZ jUnpkANZ
2F44  800F     BSF 0xF, 0, ACCESS
2F46  6A08     CLRF 0x8, ACCESS
2F48  6A07     CLRF 0x7, ACCESS
2F4A  6A06     CLRF 0x6, ACCESS
2F4C  6A05     CLRF 0x5, ACCESS
2F4E  0012     RETURN 0
2F50  2808     INCF 0x8, W, ACCESS
2F52  E003     BZ jUnpkA2
2F54  80D8     BSF STATUS, 0, ACCESS
2F56  3207     RRCF 0x7, F, ACCESS
2F58  0012     RETURN 0
2F5A  90D8     BCF STATUS, 0, ACCESS
2F5C  3207     RRCF 0x7, F, ACCESS
2F5E  E102     BNZ jUnpkNaN
2F60  820F     BSF 0xF, 1, ACCESS
2F62  0012     RETURN 0
2F64  860F     BSF 0xF, 3, ACCESS
2F66  0012     RETURN 0
2F68  360C     RLCF 0xC, F, ACCESS
2F6A  360D     RLCF 0xD, F, ACCESS
2F6C  E302     BNC jUnpkB1
2F6E  8C0F     BSF 0xF, 6, ACCESS
2F70  7E0F     BTG 0xF, 7, ACCESS
2F72  E106     BNZ jUnpkBNZ
2F74  880F     BSF 0xF, 4, ACCESS
2F76  6A0D     CLRF 0xD, ACCESS
2F78  6A0C     CLRF 0xC, ACCESS
2F7A  6A0B     CLRF 0xB, ACCESS
2F7C  6A0A     CLRF 0xA, ACCESS
2F7E  0012     RETURN 0
2F80  280D     INCF 0xD, W, ACCESS
2F82  E003     BZ jUnpkB2
2F84  80D8     BSF STATUS, 0, ACCESS
2F86  320C     RRCF 0xC, F, ACCESS
2F88  0012     RETURN 0
2F8A  90D8     BCF STATUS, 0, ACCESS
2F8C  320C     RRCF 0xC, F, ACCESS
2F8E  E1EA     BNZ jUnpkNaN
2F90  8A0F     BSF 0xF, 5, ACCESS
2F92  0012     RETURN 0
---  C:/MCC18/src/traditional/delays/d10ktcyx.asm  ------------------------------------------------------
2F94  0EFF     MOVLW 0xFF
2F96  50E3     MOVF PLUSW1, W, ACCESS
2F98  6E27     MOVWF DelayCounter1, ACCESS
2F9A  0EEF     MOVLW 0xEF
2F9C  D001     BRA D10K_1
2F9E  0EF3     MOVLW 0xF3
2FA0  6EE7     MOVWF INDF1, ACCESS
2FA2  2EE7     DECFSZ INDF1, F, ACCESS
2FA4  EFD1     GOTO 0x2FA2
2FA6  F017     NOP
2FA8  0E0C     MOVLW 0xC
2FAA  6E26     MOVWF DelayCounter2, ACCESS
2FAC  6AE7     CLRF INDF1, ACCESS
2FAE  2EE7     DECFSZ INDF1, F, ACCESS
2FB0  EFD7     GOTO 0x2FAE
2FB2  F017     NOP
2FB4  2E26     DECFSZ DelayCounter2, F, ACCESS
2FB6  EFD6     GOTO 0x2FAC
2FB8  F017     NOP
2FBA  2E27     DECFSZ DelayCounter1, F, ACCESS
2FBC  EFCF     GOTO 0x2F9E
2FBE  F017     NOP
2FC0  0012     RETURN 0
